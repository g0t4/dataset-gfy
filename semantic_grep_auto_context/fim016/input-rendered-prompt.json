{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1766852426,
  "id": "chatcmpl-FewPq3IEQmpAk91dCPnIHZj9ADgdtlv1",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 0,
    "prompt_n": 5170,
    "prompt_ms": 685.003,
    "prompt_per_token_ms": 0.13249574468085107,
    "prompt_per_second": 7547.412201114446,
    "predicted_n": 355,
    "predicted_ms": 2079.234,
    "predicted_per_token_ms": 5.856997183098591,
    "predicted_per_second": 170.73595372141858
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 3,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 355,
    "tokens_evaluated": 5170,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-27\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n\n\n<|end|><|start|>user<|message|>Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        elif event.key == \"cmd+down\":\n            cycle_fixed_zoom(event)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\ncycle_fixed_zoom\n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:53-62\ndef zoom_fixed_to_gap(self, window: GapWindow) -> None:\n        # fixed zoom level with gap centered (not full window, just the gap of silence...\n        start_seconds = window.gap.start_seconds()\n        end_seconds = window.gap.end_seconds()\n        middle = middle = (start_seconds + end_seconds) / 2\n        fixed_width_seconds = 2\n        half_in_seconds = fixed_width_seconds / 2\n        self.ax.set_xlim(middle - half_in_seconds, middle + half_in_seconds)\n        self.toggle_zoom_level_elements()\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:19-311\nclass SegmentPlotter:\n\n    aligned_markers: list[AlignedMarker]\n    arrows: list[Annotation]\n\n    @staticmethod\n    def for_window(analysis: AudioAnalysisResult, window: GapWindow):\n        segments = window.all_segments()\n        return SegmentPlotter(analysis, segments, windows_subset=[window])\n\n    @staticmethod\n    def for_entire(analysis: AudioAnalysisResult):\n        return SegmentPlotter(analysis, analysis.merged_segments, windows_subset=analysis.windows)\n\n    def __init__(\n        self,\n        analysis: AudioAnalysisResult,\n        segments_subset: list[DetectedSegment] | None = None,\n        windows_subset: list[GapWindow] | None = None,\n    ):\n        self.analysis = analysis\n        # simple idea => pass a subset of either OR just use all available on the analysis\n\n        self.aligned_markers = []\n        self.arrows = []\n\n        self.segments = segments_subset or []\n        self.windows = windows_subset or []\n\n        self.fig, self.ax = plt.subplots(figsize=(20, 10))\n\n        self._setup_plot()\n        setup_events(self)\n\n    def zoom_fixed_to_gap(self, window: GapWindow) -> None:\n        # fixed zoom level with gap centered (not full window, just the gap of silence...\n        start_seconds = window.gap.start_seconds()\n        end_seconds = window.gap.end_seconds()\n        middle = middle = (start_seconds + end_seconds) / 2\n        fixed_width_seconds = 2\n        half_in_seconds = fixed_width_seconds / 2\n        self.ax.set_xlim(middle - half_in_seconds, middle + half_in_seconds)\n        self.toggle_zoom_level_elements()\n        self.fig.canvas.draw_idle()\n\n    def zoom_to_window(self, window: GapWindow) -> None:\n        \"\"\"Zoom the plot to the given GapWindow.\n\n        Adjusts the x‑axis limits to the start and end seconds of ``window``\n        and redraws the figure. If the window does not provide valid bounds,\n        the function does nothing.\n        \"\"\"\n        start_seconds = window.start_seconds()\n        end_seconds = window.end_seconds()\n        if start_seconds is None or end_seconds is None:\n            return\n        self.ax.set_xlim(start_seconds, end_seconds)\n        self.fig.canvas.draw_idle()\n\n    def _play_segment(self, start: float, end: float) -> None:\n        sr = self.analysis.sample_rate\n        audio = self.analysis.audio.samples\n        start_idx = int(start * sr)\n        end_idx = int(end * sr)\n        segment = audio[start_idx:end_idx]\n        sd.play(segment, sr)\n\n    def setup_ticks(self) -> None:\n\n        # keep in mind we don't necessarily plot all segments in the analysis\n        start_seconds = min(seg.start_seconds for seg in self.segments)\n        end_seconds = max(seg.end_seconds for seg in self.segments)\n\n        self.ax.set_xlim(start_seconds, end_seconds)\n\n        # major ticks: every second\n        major_interval = 1.0\n        major_start = np.ceil(start_seconds / major_interval) * major_interval\n        major_ticks = np.arange(major_start, end_seconds + major_interval, major_interval)\n        self.ax.set_xticks(major_ticks)\n\n        # labels show frame number for each major tick\n        major_labels = [f\"{int(t)}\" for t in major_ticks]\n        self.ax.set_xticklabels(major_labels)\n\n        # minor ticks: every frame\n        fps = self.analysis.fps\n        frame_interval = 1.0 / fps\n        minor_start = np.ceil(start_seconds / frame_interval) * frame_interval\n        minor_ticks = np.arange(minor_start, end_seconds + frame_interval, frame_interval)\n        self.ax.set_xticks(minor_ticks, minor=True)\n        frame_numbers = [round(t * fps % fps) for t in minor_ticks]\n\n        minor_labels = [str(f) if f % 5 == 0 else \"\" for f in frame_numbers]\n        self.ax.set_xticklabels(minor_labels, minor=True)\n\n        self.ax.tick_params(axis=\"x\", which=\"minor\", length=4, colors=\"gray\")\n        self.ax.tick_params(axis=\"x\", which=\"major\", length=8, colors=\"black\")\n\n    def _setup_plot(self) -> None:\n\n        self.setup_ticks()\n\n        for seg in self.segments:\n            times = np.linspace(seg.start_seconds, seg.end_seconds, len(seg.rms_values))\n            if len(seg.rms_values) == 1:\n                self.ax.scatter(\n                    times,\n                    seg.rms_values,\n                    color=seg.plot_color(),\n                    label=seg.get_plot_message(self.analysis.fps),\n                    s=10,\n                )\n            else:\n                self.ax.plot(\n                    times,\n                    seg.rms_values,\n                    color=seg.plot_color(),\n                    label=seg.get_plot_message(self.analysis.fps),\n                    linewidth=0.5,\n                )\n\n        if self.windows:\n            for win in self.windows:\n                start_seconds = win.start_seconds()\n                end_seconds = win.end_seconds()\n                if start_seconds is None or end_seconds is None:\n                    continue\n                self.ax.axvspan(\n                    start_seconds,\n                    end_seconds,\n                    color=\"orange\",\n                    alpha=0.3,\n                    label=\"Window Gap\" if \"Window Gap\" not in self.ax.get_legend_handles_labels()[1] else None,\n                )\n\n                # * show detected minima inside the window as vertical lines\n                if win.first_min:\n                    self.add_annotation_arrow(win.first_min.seconds, win.first_min.rms)\n                    self.mark_aligned_frame(win.first_min.frame_aligned_at_seconds, win.first_min.rms)\n                    # rms is for _min.seconds, not min.frame_aligned_at_seconds, but, use it for both\n                if win.last_min:\n                    self.add_annotation_arrow(win.last_min.seconds, win.last_min.rms)\n                    self.mark_aligned_frame(win.last_min.frame_aligned_at_seconds, win.last_min.rms)\n\n        self.ax.set_xlabel(\"Time (s)\")\n        self.ax.set_ylabel(\"RMS dB\")\n        self.ax.set_title(f\"RMS Segments {self.analysis.title_addon()}\")\n\n    def _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_fixed_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            rich.inspect(event)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n            # save mp4 clip\n            clip_path = clip_full_window(\n                explain,\n                self.analysis,\n                window,\n            )\n            if clip_path:\n                print(f\"Saved clip to {clip_path}\")\n\n        else:\n            # * play a single segment (under cursor)\n            for seg in self.segments:\n                if seg.start_seconds <= clicked_at_seconds <= seg.end_seconds:\n                    self._play_segment(seg.start_seconds, seg.end_seconds)\n\n    def show(self) -> None:\n        self.fig.tight_layout(pad=0.5)  # thin margins around the axes (plot)... less wasted whitespace margins!\n        plt.ion()  # else won't show new plots after initial call to plt.show()\n        plt.show()\n\n    def add_segments(self, new_segments: list[DetectedSegment]) -> None:\n        self.segments.extend(new_segments)\n        for seg in new_segments:\n            times = np.linspace(seg.start_seconds, seg.end_seconds, len(seg.rms_values))\n            self.ax.plot(\n                times,\n                seg.rms_values,\n                color=seg.plot_color(),\n                linewidth=0.5,\n            )\n        # self.fig.canvas.draw()\n        # self.fig.canvas.flush_events()\n\n    def mark_aligned_frame(self, time_point: float, arrow_y: float) -> None:\n\n        # * vertical line (hopefully cross through the RMS plot... but not guarnateed right now)\n        line_height = 6\n        lines = self.ax.plot(\n            [time_point, time_point],\n            [arrow_y, arrow_y + line_height],\n            color=\"blue\",\n            linewidth=1,\n        )\n\n        frames = time_point * self.analysis.fps\n        frames_text = f\"{int(frames)}f\"\n\n        # * time label\n        label = f\"{time_point:.2f}s\\n{frames_text}\"\n        text = self.ax.text(\n            time_point,\n            arrow_y + line_height + 2,\n            label,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"blue\",\n        )\n\n        self.aligned_markers.append(AlignedMarker(lines, text=text))\n\n        self.fig.canvas.draw_idle()\n\n    def add_annotation_arrow(self, time_point: float, arrow_y: float) -> None:\n\n        self.ax = plt.gca()\n\n        annotation = self.ax.annotate(\n            \"\",\n            xy=(time_point, arrow_y),\n            xytext=(time_point, arrow_y - 6),\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n            arrowprops=dict(\n                arrowstyle=\"->\",\n                color=\"red\",\n                linewidth=1.5,\n            ),\n        )\n        self.arrows.append(annotation)\n\n        self.fig.canvas.draw_idle()\n\n    def toggle_zoom_level_elements(self):\n        # PRN call this when window is resized (i.e. full screen => split screen)\n\n        # compute density of time\n        xlim = self.ax.get_xlim()\n        visible_seconds = xlim[1] - xlim[0]\n        pixels_per_second = self.ax.bbox.width / visible_seconds\n\n        for marker in self.aligned_markers:\n            for line in marker.lines:\n                line.set_visible(pixels_per_second > 150)\n            marker.text.set_visible(pixels_per_second > 250)\n\n        for annotation in self.arrows:\n            if pixels_per_second > 250:\n                label = f\"{annotation.xy[0]:.2f}s\"\n                annotation.set_text(label)\n            else:\n                annotation.set_text(\"\")\n\n        # rich.inspect(ax.xaxis.get_tick_params())\n        self.ax.xaxis.set_tick_params(\n            which='minor',\n            labelbottom=pixels_per_second > 500,  # not really useful b/4 this point (in my testing)\n            bottom=pixels_per_second > 150,\n        )\n\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:64-76\ndef zoom_to_window(self, window: GapWindow) -> None:\n        \"\"\"Zoom the plot to the given GapWindow.\n\n        Adjusts the x‑axis limits to the start and end seconds of ``window``\n        and redraws the figure. If the window does not provide valid bounds,\n        the function does nothing.\n        \"\"\"\n        start_seconds = window.start_seconds()\n        end_seconds = window.end_seconds()\n        if start_seconds is None or end_seconds is None:\n            return\n        self.ax.set_xlim(start_seconds, end_seconds)\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:284-311\ndef toggle_zoom_level_elements(self):\n        # PRN call this when window is resized (i.e. full screen => split screen)\n\n        # compute density of time\n        xlim = self.ax.get_xlim()\n        visible_seconds = xlim[1] - xlim[0]\n        pixels_per_second = self.ax.bbox.width / visible_seconds\n\n        for marker in self.aligned_markers:\n            for line in marker.lines:\n                line.set_visible(pixels_per_second > 150)\n            marker.text.set_visible(pixels_per_second > 250)\n\n        for annotation in self.arrows:\n            if pixels_per_second > 250:\n                label = f\"{annotation.xy[0]:.2f}s\"\n                annotation.set_text(label)\n            else:\n                annotation.set_text(\"\")\n\n        # rich.inspect(ax.xaxis.get_tick_params())\n        self.ax.xaxis.set_tick_params(\n            which='minor',\n            labelbottom=pixels_per_second > 500,  # not really useful b/4 this point (in my testing)\n            bottom=pixels_per_second > 150,\n        )\n\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:282-301\n\n\n    def toggle_zoom_level_elements(self):\n        # PRN call this when window is resized (i.e. full screen => split screen)\n\n        # compute density of time\n        xlim = self.ax.get_xlim()\n        visible_seconds = xlim[1] - xlim[0]\n        pixels_per_second = self.ax.bbox.width / visible_seconds\n\n        for marker in self.aligned_markers:\n            for line in marker.lines:\n                line.set_visible(pixels_per_second > 150)\n            marker.text.set_visible(pixels_per_second > 250)\n\n        for annotation in self.arrows:\n            if pixels_per_second > 250:\n                label = f\"{annotation.xy[0]:.2f}s\"\n                annotation.set_text(label)\n            else:\n\n<|end|><|start|>user<|message|>Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n        cur_xlim = plotter.ax.get_xlim()\n        width = (cur_xlim[1] - cur_xlim[0]) / 2\n        start, end = clamp_xlim(cur_xlim[0] + width, cur_xlim[1] + width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def on_scroll(event: MouseEvent):\n        if event.inaxes != plotter.ax:\n            return\n        base_scale = 0.9\n        cur_xlim = plotter.ax.get_xlim()\n        xdata = event.xdata\n        if event.button == 'up':\n            scale_factor = base_scale\n        elif event.button == 'down':\n            scale_factor = 1 / base_scale\n        else:\n            scale_factor = 1\n        new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor\n        relx = (xdata - cur_xlim[0]) / (cur_xlim[1] - cur_xlim[0])\n        plotter.ax.set_xlim(xdata - new_width * relx, xdata + new_width * (1 - relx))\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()\n\n    def decrease_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length // 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def increase_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length * 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def redo_analysis_with(params: AnalysisParams):\n        old_analysis = plotter.analysis\n        new_analysis = create_analysis(old_analysis.audio, params)\n        new_analysis.path = old_analysis.path\n\n        # * setup data for new plot (as if call SegmentPlotter() again)\n        # PRN look at ctor for overlap to refactor?\n        plotter.analysis = new_analysis\n        plotter.segments = new_analysis.merged_segments\n        plotter.windows = new_analysis.windows\n        plotter.aligned_markers = []\n        plotter.arrows = []\n\n        # * capture current plot state\n        old_xlim = plotter.ax.get_xlim()\n        old_ylim = plotter.ax.get_ylim()\n\n        # * clear actual plot elements\n        plotter.ax.cla()\n        # * draw new elements\n        plotter._setup_plot()\n\n        # * restore zoom/pan\n        plotter.ax.set_xlim(old_xlim)\n        plotter.ax.set_ylim(old_ylim)\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()\n\n    def key_up_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] + shift, cur_ylim[1] + shift)\n        plotter.fig.canvas.draw_idle()\n\n    def key_down_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] - shift, cur_ylim[1] - shift)\n        plotter.fig.canvas.draw_idle()\n\n    def cycle_fixed_zoom(event: KeyEvent):\n        FIXED_ZOOM_LEVELS_SECONDS = [2, 10, 60]\n        <|fim_middle|>\n        \n\n    def zoom_x_only(event: KeyEvent):\n        # FYI shift variant of keys is for faster zoom (hence 0.5)\n        match event.key:\n            case \"=\":\n                zoom_factor = 0.8\n            case \"+\":\n                zoom_factor = 0.5\n            case \"-\":\n                zoom_factor = 1 / 0.8\n            case \"_\":\n                zoom_factor = 1 / 0.5\n            case _:\n                return\n\n        cur_xlim = plotter.ax.get_xlim()\n        x_center = sum(cur_xlim) / 2\n        x_range = (cur_xlim[1] - cur_xlim[0]) * zoom_factor\n        plotter.ax.set_xlim(x_center - x_range / 2, x_center + x_range / 2)\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()\n\n    def on_hover(event: MouseEvent):\n        toolbar = event.canvas.manager.toolbar\n        if not hasattr(toolbar, \"set_message\"):\n            # cannot set message, so why bother!\n            return\n\n        messages = []\n        if event.inaxes is None:\n\n            # outside of figure\n            # default to coordinates so I can see time / values\n            x = event.x\n            y = event.y\n            messages = [f\"{x=},{y=}\"]\n\n        else:\n\n            for artist in event.inaxes.get_children():\n                # PathCollection = ax.scatter()\n                # Line2D = ax.plot()\n                if isinstance(artist, (Line2D, PathCollection)):\n                    if not hasattr(artist, \"_orig_style\"):\n                        if isinstance(artist, Line2D):\n                            artist._orig_style = (artist.get_color(), artist.get_linewidth())\n                        else:\n                            artist._orig_style = (artist.get_facecolor(), artist.get_linewidth())\n                    is_under_mouse, _ = artist.contains(event)\n                    if is_under_mouse:\n                        artist.set_linewidth(2)\n                        artist.set_color(\"red\")\n                        messages.append(artist.get_label())\n                    else:\n                        orig_color, orig_linewidth = artist._orig_style\n                        if isinstance(artist, Line2D):\n                            artist.set_linewidth(orig_linewidth)\n                            artist.set_color(orig_color)\n                        else:\n                            artist.set_linewidth(orig_linewidth)\n                            artist.set_facecolor(orig_color)\n\n            if event.xdata is not None and event.ydata is not None:\n                # show mouse coords too (so I can see where I am w/in a segment... and if no segment under mouse then show the position in time/dB)\n                seconds = seconds_to_timecode(event.xdata, plotter.analysis.fps)\n                db_value = event.ydata\n                messages += [f\"cursor@{seconds},{db_value=:.2f}\"]\n\n        toolbar.set_message(\", \".join(messages))\n\n        event.canvas.draw_idle()\n\n    plotter.fig.canvas.mpl_connect('scroll_event', on_scroll)\n    plotter.fig.canvas.mpl_connect(\"motion_notify_event\", on_hover)\n    plotter.fig.canvas.mpl_connect(\"key_press_event\", on_key)\n    plotter.fig.canvas.mpl_connect(\"button_press_event\", plotter._on_click)\n    plotter.fig.canvas.mpl_connect(\"close_event\", on_close)\n\n    # initial setup of dynamic aspects:<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 5524,
    "timings": {
      "cache_n": 0,
      "prompt_n": 5170,
      "prompt_ms": 685.003,
      "prompt_per_token_ms": 0.13249574468085107,
      "prompt_per_second": 7547.412201114446,
      "predicted_n": 355,
      "predicted_ms": 2079.234,
      "predicted_per_token_ms": 5.856997183098591,
      "predicted_per_second": 170.73595372141858
    }
  }
}
