{
  "max_tokens": 4096,
  "model": "",
  "messages": [
    {
      "role": "system",
      "content": "You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "
    },
    {
      "role": "user",
      "content": "## Recent yanks across all files in the project:\n.. yanked from auto_edit/tests/aligned-tests.py:\ntest_detect_split_breathing_into_two_silences\n\n.. yanked from auto_edit/ranges.py:\n        return f\"Silence[{self.start_frame}->{self.end_frame})\"\n\n.. yanked from auto_edit/tests/range-tests.py:\n    assert str(SilenceRange(0, 10)) == \"Silence[0->10)\"\n\n.. yanked from auto_edit/tests/range-tests.py:\nContent[5->15)\"\n\n.. yanked from auto_edit/tests/range-tests.py:\nFrames[0->10)\"\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n"
    },
    {
      "role": "user",
      "content": "# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
    },
    {
      "role": "user",
      "content": "# Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"
    },
    {
      "role": "user",
      "content": "# Semantic Grep matches: 5\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:153-157\nclass TestRawSilencePeriodDuration(unittest.TestCase):\n\n        def test_duration(self):\n            silence = RawSilencePeriod(100, 200)\n            self.assertEqual(silence.duration(), 100)\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:155-157\ndef test_duration(self):\n            silence = RawSilencePeriod(100, 200)\n            self.assertEqual(silence.duration(), 100)\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:35-81\nclass RawSilencePeriod:\n\n    def __init__(self, start_seconds: float, end_seconds: float):\n        self.start_seconds = start_seconds\n        self.end_seconds = end_seconds\n\n    def __repr__(self):\n        return f\"Raw({self.start_seconds}, {self.end_seconds})\"\n\n    def __str__(self) -> str:\n        return f\"Raw {self.start_seconds} -> {self.end_seconds}\"\n\n    def duration(self) -> float:\n        # TODO testing\n        return self.end_seconds - self.start_seconds\n\n    def subtract(self, remove: 'RawSilencePeriod') -> List['RawSilencePeriod']:\n        original = self\n        if original.end_seconds <= remove.start_seconds:\n            return [original]\n        if remove.end_seconds <= original.start_seconds:\n            return [original]\n        if original.start_seconds <= remove.start_seconds and remove.end_seconds <= original.end_seconds:\n            # remove is within original => results in 2 silence periods (possibly, if non zero duration)\n            before = RawSilencePeriod(original.start_seconds, remove.start_seconds)\n            result = []\n            if before.start_seconds != before.end_seconds:\n                result.append(before)\n            after = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if after.start_seconds != after.end_seconds:\n                result.append(after)\n            return result\n        if remove.start_seconds <= original.start_seconds:\n            # starts before original => ends in middle => 1 silence periods\n            new_range = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if new_range.start_seconds < new_range.end_seconds:\n                return [new_range]\n            return []\n        # starts in middle of original => ends after original => 1 silence periods\n        return [RawSilencePeriod(original.start_seconds, remove.start_seconds)]\n\n    def __eq__(self, other):\n        # IIUC __ne__ => not __eq__ # unless implemented otherwise\n        # !!! TODO is this gonna cause any issues??? => look for times when I compare periods for object equality only...\n        if isinstance(other, RawSilencePeriod):\n            return self.start_seconds == other.start_seconds and self.end_seconds == other.end_seconds\n        return False\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/auto_edit/silences/detect_raw.py:3-50\nclass RawSilencePeriod:\n\n    def __init__(self, start_seconds: float, end_seconds: float):\n        self.start_seconds = start_seconds\n        self.end_seconds = end_seconds\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self) -> str:\n        # TODO! confirm end is not inclusive\n        return f\"Raw[{self.start_seconds}->{self.end_seconds})\"\n\n    def duration(self) -> float:\n        # TODO testing\n        return self.end_seconds - self.start_seconds\n\n    def subtract(self, remove: 'RawSilencePeriod') -> list['RawSilencePeriod']:\n        original = self\n        if original.end_seconds <= remove.start_seconds:\n            return [original]\n        if remove.end_seconds <= original.start_seconds:\n            return [original]\n        if original.start_seconds <= remove.start_seconds and remove.end_seconds <= original.end_seconds:\n            # remove is within original => results in 2 silence periods (possibly, if non zero duration)\n            before = RawSilencePeriod(original.start_seconds, remove.start_seconds)\n            result = []\n            if before.start_seconds != before.end_seconds:\n                result.append(before)\n            after = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if after.start_seconds != after.end_seconds:\n                result.append(after)\n            return result\n        if remove.start_seconds <= original.start_seconds:\n            # starts before original => ends in middle => 1 silence periods\n            new_range = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if new_range.start_seconds < new_range.end_seconds:\n                return [new_range]\n            return []\n        # starts in middle of original => ends after original => 1 silence periods\n        return [RawSilencePeriod(original.start_seconds, remove.start_seconds)]\n\n    def __eq__(self, other):\n        # IIUC __ne__ => not __eq__ # unless implemented otherwise\n        # !!! TODO is this gonna cause any issues??? => look for times when I compare periods for object equality only...\n        if isinstance(other, RawSilencePeriod):\n            return self.start_seconds == other.start_seconds and self.end_seconds == other.end_seconds\n        return False\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:179-183\ndef test__eq__(self):\n            original = RawSilencePeriod(100, 200)\n            other = RawSilencePeriod(100, 200)\n            self.assertTrue(original == other)\n            self.assertFalse(original != other)\n"
    },
    {
      "role": "user",
      "content": "add a new test method of RawSilencePeriod's __str__\nHere is code I selected (with carefully preserved indentation) from auto_edit/tests/raw_silence_period-tests.py:\nclass TestRawSilencePeriodGeneral:\n\n    def test_duration(self):\n        silence = RawSilencePeriod(100, 200)\n        assert silence.duration() == 100\n"
    }
  ],
  "stream": true,
  "temperature": 1,
  "top_p": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  }
}
