{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1765091627,
  "id": "chatcmpl-xATbsGpsMDmBTIA9AP3BQATVwlkEtBtH",
  "model": "",
  "system_fingerprint": "b7089-38e2c1b41",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 0,
    "prompt_n": 1772,
    "prompt_ms": 261.425,
    "prompt_per_token_ms": 0.14753103837471784,
    "prompt_per_second": 6778.234675337095,
    "predicted_n": 105,
    "predicted_ms": 463.122,
    "predicted_per_token_ms": 4.410685714285714,
    "predicted_per_second": 226.72211641856788
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 2,
    "stop": true,
    "model": "",
    "tokens_predicted": 105,
    "tokens_evaluated": 1772,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-07\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. \n\n<|end|><|start|>user<|message|>## Recent yanks across all files in the project:\n.. yanked from auto_edit/tests/aligned-tests.py:\ntest_detect_split_breathing_into_two_silences\n\n.. yanked from auto_edit/ranges.py:\n        return f\"Silence[{self.start_frame}->{self.end_frame})\"\n\n.. yanked from auto_edit/tests/range-tests.py:\n    assert str(SilenceRange(0, 10)) == \"Silence[0->10)\"\n\n.. yanked from auto_edit/tests/range-tests.py:\nContent[5->15)\"\n\n.. yanked from auto_edit/tests/range-tests.py:\nFrames[0->10)\"\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n.. yanked from auto_edit/ranges.py:\n        return self.__str__()\n\n<|end|><|start|>user<|message|># General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n<|end|><|start|>user<|message|># Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n<|end|><|start|>user<|message|># Semantic Grep matches: 5\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:153-157\nclass TestRawSilencePeriodDuration(unittest.TestCase):\n\n        def test_duration(self):\n            silence = RawSilencePeriod(100, 200)\n            self.assertEqual(silence.duration(), 100)\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:155-157\ndef test_duration(self):\n            silence = RawSilencePeriod(100, 200)\n            self.assertEqual(silence.duration(), 100)\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:35-81\nclass RawSilencePeriod:\n\n    def __init__(self, start_seconds: float, end_seconds: float):\n        self.start_seconds = start_seconds\n        self.end_seconds = end_seconds\n\n    def __repr__(self):\n        return f\"Raw({self.start_seconds}, {self.end_seconds})\"\n\n    def __str__(self) -> str:\n        return f\"Raw {self.start_seconds} -> {self.end_seconds}\"\n\n    def duration(self) -> float:\n        # TODO testing\n        return self.end_seconds - self.start_seconds\n\n    def subtract(self, remove: 'RawSilencePeriod') -> List['RawSilencePeriod']:\n        original = self\n        if original.end_seconds <= remove.start_seconds:\n            return [original]\n        if remove.end_seconds <= original.start_seconds:\n            return [original]\n        if original.start_seconds <= remove.start_seconds and remove.end_seconds <= original.end_seconds:\n            # remove is within original => results in 2 silence periods (possibly, if non zero duration)\n            before = RawSilencePeriod(original.start_seconds, remove.start_seconds)\n            result = []\n            if before.start_seconds != before.end_seconds:\n                result.append(before)\n            after = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if after.start_seconds != after.end_seconds:\n                result.append(after)\n            return result\n        if remove.start_seconds <= original.start_seconds:\n            # starts before original => ends in middle => 1 silence periods\n            new_range = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if new_range.start_seconds < new_range.end_seconds:\n                return [new_range]\n            return []\n        # starts in middle of original => ends after original => 1 silence periods\n        return [RawSilencePeriod(original.start_seconds, remove.start_seconds)]\n\n    def __eq__(self, other):\n        # IIUC __ne__ => not __eq__ # unless implemented otherwise\n        # !!! TODO is this gonna cause any issues??? => look for times when I compare periods for object equality only...\n        if isinstance(other, RawSilencePeriod):\n            return self.start_seconds == other.start_seconds and self.end_seconds == other.end_seconds\n        return False\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/auto_edit/silences/detect_raw.py:3-50\nclass RawSilencePeriod:\n\n    def __init__(self, start_seconds: float, end_seconds: float):\n        self.start_seconds = start_seconds\n        self.end_seconds = end_seconds\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self) -> str:\n        # TODO! confirm end is not inclusive\n        return f\"Raw[{self.start_seconds}->{self.end_seconds})\"\n\n    def duration(self) -> float:\n        # TODO testing\n        return self.end_seconds - self.start_seconds\n\n    def subtract(self, remove: 'RawSilencePeriod') -> list['RawSilencePeriod']:\n        original = self\n        if original.end_seconds <= remove.start_seconds:\n            return [original]\n        if remove.end_seconds <= original.start_seconds:\n            return [original]\n        if original.start_seconds <= remove.start_seconds and remove.end_seconds <= original.end_seconds:\n            # remove is within original => results in 2 silence periods (possibly, if non zero duration)\n            before = RawSilencePeriod(original.start_seconds, remove.start_seconds)\n            result = []\n            if before.start_seconds != before.end_seconds:\n                result.append(before)\n            after = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if after.start_seconds != after.end_seconds:\n                result.append(after)\n            return result\n        if remove.start_seconds <= original.start_seconds:\n            # starts before original => ends in middle => 1 silence periods\n            new_range = RawSilencePeriod(remove.end_seconds, original.end_seconds)\n            if new_range.start_seconds < new_range.end_seconds:\n                return [new_range]\n            return []\n        # starts in middle of original => ends after original => 1 silence periods\n        return [RawSilencePeriod(original.start_seconds, remove.start_seconds)]\n\n    def __eq__(self, other):\n        # IIUC __ne__ => not __eq__ # unless implemented otherwise\n        # !!! TODO is this gonna cause any issues??? => look for times when I compare periods for object equality only...\n        if isinstance(other, RawSilencePeriod):\n            return self.start_seconds == other.start_seconds and self.end_seconds == other.end_seconds\n        return False\n\n## /Users/wesdemos/repos/github/g0t4/private-auto-edit-suggests/research/FCPX/silence.py:179-183\ndef test__eq__(self):\n            original = RawSilencePeriod(100, 200)\n            other = RawSilencePeriod(100, 200)\n            self.assertTrue(original == other)\n            self.assertFalse(original != other)\n<|end|><|start|>user<|message|>add a new test method of RawSilencePeriod's __str__\nHere is code I selected (with carefully preserved indentation) from auto_edit/tests/raw_silence_period-tests.py:\nclass TestRawSilencePeriodGeneral:\n\n    def test_duration(self):\n        silence = RawSilencePeriod(100, 200)\n        assert silence.duration() == 100\n<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 1876,
    "timings": {
      "cache_n": 0,
      "prompt_n": 1772,
      "prompt_ms": 261.425,
      "prompt_per_token_ms": 0.14753103837471784,
      "prompt_per_second": 6778.234675337095,
      "predicted_n": 105,
      "predicted_ms": 463.122,
      "predicted_per_token_ms": 4.410685714285714,
      "predicted_per_second": 226.72211641856788
    }
  }
}
