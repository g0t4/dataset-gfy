{
  "model": "gpt-oss:120b",
  "temperature": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "options": [],
  "stream": true,
  "raw": false,
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/misc-specific.fish:23-30\nfunction toggle_show_verbose_prompt\n    if not set --query show_verbose_prompt\n        set --universal show_verbose_prompt yes\n    else\n        set --universal --erase show_verbose_prompt\n    end\n    # commandline --function repaint\nend\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/ask-openai.fish:135-154\n        # FYI other causes rc=2 print as context (i.e. wrong path to python script, NBD as error shows anyways)\n    else if test $exit_code -ne 0\n        commandline --replace \"[FAIL]: $response\"\n    else\n        commandline --replace $response\n    end\n    # FYI ctrl+z can undo replacment\n\n    # `fish_commandline_append` doesn't use repaint, so I assume I don't need to\nend\n\n# how does fish handle multiple registrations? does last one win? is it an issue that \\cb is preset bound to backward-char?\nbind_both_modes_default_and_insert ctrl-b ask_openai\n\n\n\nfunction ask_openai_explain\n    # *** UNDO to get command back? OR, explain in comment? that way can keep command visible and still undo cmd+z\n    set -l user_input (commandline -b)\n\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/ask-openai.fish:195-214\n    if test $exit_code -eq 2\n        commandline --replace \"[CONTEXT]: $response\"\n        # FYI other causes rc=2 print as context (i.e. wrong path to python script, NBD as error shows anyways)\n    else if test $exit_code -ne 0\n        commandline --replace \"[FAIL]: $response\"\n    else\n        commandline --replace $response\n    end\n    # FYI ctrl+z can undo replacment\n\n    # `fish_commandline_append` doesn't use repaint, so I assume I don't need to\nend\n\n\nbind_both_modes_default_and_insert f3 ask_openai_link\n# urls? shotgun style! open up to 5 tabs!?\n\n## NOTES\n#\n# PRN use background job/process like in zsh so # thinking... shows up in prompt\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/diff-specific.fish:90-109\nend\n\nfunction _current_command_or_previous\n\n    set user_input (commandline -b)\n    if test -z $user_input\n        set user_input (history | head -n 1)\n        # PRN use $history (does it have items not added to history file, IIAC?)\n    end\n    echo $user_input\n\nend\n\n# *** bindings to replace current command with a diff_ helper command ***\n\nfunction _convert_current_command_to_diff_command_args\n    # use to compare same command w/ and w/o a set of args\n    set user_input (_current_command_or_previous)\n    commandline --replace \"diff_command_args '$user_input' \"\nend\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/diff-specific.fish:105-109\nfunction _convert_current_command_to_diff_command_args\n    # use to compare same command w/ and w/o a set of args\n    set user_input (_current_command_or_previous)\n    commandline --replace \"diff_command_args '$user_input' \"\nend\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nabbr nvim_client_open_files_in_new_tabs \"nvim --server localhost:6666 --remote-tab\" # open file(s) in new tab(s)\n# fyi :detach when done, or :quit will kill server\n# server is useful for test automation\n# TODO consider porting some/all \"open with\" functionality to using a server?\n# not yet in NVIM: --remote*-wait variants, and servername/list (from vim)\n\n# FYI I changed session restore to use passed files/paths to open after session restored, so now I want that to only be if I explicitly ask for a file to be opened and not show dir every time I open, show last file open in most cases... I might need to alter this later\nabbr n nvim # n<space> is perfect now\nabbr nr --function nr_expand\nfunction nr_expand\n    if not string match --quiet (_repo_root) (pwd)\n        echo -n \"cd (_repo_root); \"\n    end\n    echo nvim\nend\n\nabbr nd --function nd_expand\nfunction nd_expand\n    if not string match --quiet $WES_DOTFILES (pwd)\n        echo -n \"cd $WES_DOTFILES; \"\n    end\n    echo nvim\nend\n\nabbr nh --function nh_expand\nfunction nh_expand\n    if not string match --quiet $WES_DOTFILES/.config/hammerspoon (pwd)\n        echo -n \"cd $WES_DOTFILES/.config/hammerspoon; \"\n    end\n    echo nvim\nend\n\nabbr nn --function nn_expand\nfunction nn_expand\n    if not string match --quiet $WES_DOTFILES/.config/nvim (pwd)\n        echo -n \"cd $WES_DOTFILES/.config/nvim; \"\n    end\n    echo nvim\nend\n\nif command -q nvim\n    abbr vim nvim\n    abbr vi nvim\nend\n\nfunction nvselect\n    #    use with :CopyFileSystemLink cmd\n    # nvselect ~/repos/github/g0t4/dotfiles/.config/nvim/lua/non-plugins/github-links.lua:83\n\n    set link $argv[1] # path/too/foo.txt:10-20\n    set file (string split ':' $link)[1]\n    set range (string split ':' $link)[2]\n    set start_line (string split '-' $range)[1]\n    set end_line (string split '-' $range)[2]\n\n    if test -z \"$end_line\"\n        set end_line $start_line\n    end\n\n    set line_count (math \"$end_line - $start_line\")\n    nvim +$start_line +\"normal! V{$line_count}jzz\" \"$file\"\nend\n\n# *** free\nif command -q free\n    abbr free 'free -wh'\n    abbr frees 'free -whs 1' # still, prefer using watch\nend\n\n# *** fzf \"widgets\" for selecting a file to pass to a command\nfunction _fzf_nested_dir_widget -d \"Paste selected directory into command line\"\n    set -l dir (fd --type d . | fzf --height 50% --border)\n    if test -n \"$dir\"\n        commandline -i -- (string escape -- \"$dir\")\n    end\n    commandline -f repaint\nend\n\nfunction _fzf_nested_file_widget -d \"Paste selected file into command line\"\n    set -l file (fd --type f . | fzf --height 50% --border)\n    if test -n \"$file\"\n        commandline -i -- (string escape -- \"$file\")\n    end\n    commandline -f repaint\nend\n\n<|fim_middle|>\n\nfunction _fzf_nested_both_file_and_dirs_widget -d \"Paste selected file or directory into command line\"\n    # btw `diff_two_commands 'fd --type f --type d' 'fd'` differ in symlinks (at least)\n    set -l file (fd . | fzf --height 50% --border)\n    if test -n \"$file\"\n        commandline -i -- (string escape -- \"$file\")\n    end\n    commandline -f repaint\nend\n\nfunction _fzf_nested_git_commit_widget -d \"Pick a git commit_hash\"\n    # TODO look at commandline! and decide based on the git subcommand?!\n    #  git diff => pick a commit_hash\n    #   heck I could do this and add defaults for all sorts of commands (and fallback could ask AI to pick a picker!)\n\n    set log_format \"%C(white)%h%Creset %Cblue%cr%Creset%C(auto)%d%Creset %s\"\n    set -l commit_hash $(\n        git log --reverse --format=\"$log_format\" \\\n        | fzf --height 50% --border --ansi --accept-nth=1\n    )\n    if test -n \"$commit_hash\"\n        commandline -i -- (string escape -- \"$commit_hash\")\n    end\n    commandline -f repaint\nend\n\nbind_both_modes_default_and_insert alt-shift-d _fzf_nested_dir_widget\nbind_both_modes_default_and_insert alt-shift-f _fzf_nested_file_widget\nbind_both_modes_default_and_insert alt-shift-u _fzf_nested_file_unrestricted_widget\nbind_both_modes_default_and_insert alt-shift-b _fzf_nested_both_file_and_dirs_widget\n# TODO what all pickers for git history might I want?\nbind_both_modes_default_and_insert alt-shift-g _fzf_nested_git_commit_widget\n\n# *** chmod,chgrp,chown,chsh\nabbr chmx \"chmod +x\"\nabbr chmR \"chmod -R\"\n\nfunction prepend_to_file\n\n    # uses ed command to prepend a line\n    # 0a specifies to add at beginning of buffer\n    # ok to be multiple lines... . is effectively marks when to stop appending content and then wq commands save and quit (just like vim which is based on ed)\n\n    read _stdin\n    printf \"0a\\\\n$_stdin\\n.\\nwq\\n\" | ed -- \"$argv[1]\"\n\nend\n\nfunction shebangify\n    # chmod +x + shebang\n\n    set script_file $argv[1]\n    set extension (string lower $(path extension $script_file))\n\n    touch $script_file\n    chmod +x $script_file\n\n    if not string match --regex --quiet '.(sh|zsh|fish|bash)$' $extension\n        echo \"not known script type\"\n        return 1\n    end\n\n    if string match --quiet --regex '^#!.*' (head --lines=1 -- $script_file)\n        echo \"shebang already present\"\n        return 0\n    end\n\n    # strip leading .\n    set dotless_extension (string replace \".\" \"\" $extension)\n\n    echo \"#!/usr/bin/env $dotless_extension\\n\" | prepend_to_file $script_file\n\nend",
      "role": "user"
    }
  ],
  "max_tokens": 4096,
  "top_p": 1
}
