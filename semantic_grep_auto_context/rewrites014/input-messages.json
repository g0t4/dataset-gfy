{
  "max_tokens": 4096,
  "stream": true,
  "top_p": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "temperature": 1,
  "model": "",
  "messages": [
    {
      "role": "system",
      "content": "You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "
    },
    {
      "role": "user",
      "content": "## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
    },
    {
      "role": "user",
      "content": "## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"
    },
    {
      "role": "user",
      "content": "# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:0-11\nimport numpy as np\nfrom dataclasses import dataclass\nfrom matplotlib.lines import Line2D\nfrom scipy.ndimage import uniform_filter1d\nfrom .breathing_state import plot, text_label\n\n@dataclass\nclass TimeSeriesDTO:\n    values: np.ndarray\n    times: np.ndarray\n\n    \n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:6-55\n@dataclass\nclass TimeSeriesDTO:\n    values: np.ndarray\n    times: np.ndarray\n\n    def copy_values(self):\n        return TimeSeriesDTO(values=self.values.copy(), times=self.times)\n\n    def plot(self, shift: float | int | None = None, label_end: str | None = None, **kwargs) -> list[Line2D]:\n        return plot(self.times, self.values, shift=shift, label_end=label_end, **kwargs)\n\n    def plot_sign_and_smooth_sign(self, shift, color, label_end):\n        self.sign().plot(color=color, linewidth=1, shift=shift, label_end=label_end)\n        self.smooth().sign().plot(color=\"black\", linewidth=1, shift=shift)\n\n    def smooth(self, size: int = 25) -> \"TimeSeriesDTO\":\n        return TimeSeriesDTO(values=uniform_filter1d(self.values, size=size), times=self.times)\n\n    def sign(self) -> \"TimeSeriesDTO\":\n        return TimeSeriesDTO(values=np.sign(self.values), times=self.times)\n\n    def stepped(self, step_size=2) -> \"TimeSeriesDTO\":\n        return TimeSeriesDTO(\n            values=self.values[::step_size],\n            times=self.times[::step_size],\n        )\n\n    def diff(self, align: str = \"right\") -> \"TimeSeriesDTO\":\n        \"\"\"Return the first‑order difference.\n\n        ``align`` determines how timestamps are generated:\n        * ``\"right\"`` (default) – timestamps correspond to the right sample of the\n          pair, matching the historic behaviour.\n        * ``\"mid\"`` – timestamps are placed at the midpoint between the two\n          samples used to compute each difference.\n        \"\"\"\n        values = np.diff(self.values)\n        if align == \"mid\":\n            times = 0.5 * (self.times[1:] + self.times[:-1])\n        else:  # right‑aligned fallback\n            times = self.times[1:]\n        return TimeSeriesDTO(values=values, times=times)\n\n    def mark_rejected(self, why: str):\n        text_label(\n            x_pos=self.times[len(self.times) // 2],\n            y_pos=self.values.max() + 3,\n            text=why,\n        )\n        self.plot(color=\"pink\", linewidth=1)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:27-31\ndef stepped(self, step_size=2) -> \"TimeSeriesDTO\":\n        return TimeSeriesDTO(\n            values=self.values[::step_size],\n            times=self.times[::step_size],\n        )\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:11-12\ndef copy_values(self):\n        return TimeSeriesDTO(values=self.values.copy(), times=self.times)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detect_tests.py:26-36\ndef silence_seg(start, end):\n    global id_counter\n    seg = DetectedSegment(\n        id=id_counter,\n        start_seconds=start,\n        end_seconds=end,\n        label=SegmentLabel.SILENCE,\n        rms_values=np.array([id_counter]),\n    )\n    id_counter += 1\n    return seg\n"
    },
    {
      "role": "user",
      "content": "use abs import\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/detects/segments.py:\nfrom .time_series import TimeSeriesDTO"
    }
  ]
}
