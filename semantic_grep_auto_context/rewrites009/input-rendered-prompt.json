{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1767073197,
  "id": "chatcmpl-cYhYC8J7fprVOkrtQAcl4mhULNfQx20h",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 0,
    "prompt_n": 1787,
    "prompt_ms": 279.579,
    "prompt_per_token_ms": 0.1564515948517068,
    "prompt_per_second": 6391.753314805475,
    "predicted_n": 238,
    "predicted_ms": 1148.439,
    "predicted_per_token_ms": 4.8253739495798325,
    "predicted_per_second": 207.2378245601203
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 0,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 238,
    "tokens_evaluated": 1787,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-29\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. \n\n<|end|><|start|>user<|message|>## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        if event.key == \"left\":\n            key_left(event)\n        elif event.key == \"right\":\n            key_right(event)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nkey_ctrl_left\n\n.. yanked from auto_edit/new_silence/detects/segments.py:\n    def end_seconds(self) -> float:\n        return self.segments[-1].end_seconds\n\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        xlim = plotter.ax.get_xlim()\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n    def center_on_gap_of(win: GapWindow):\n\n.. yanked from auto_edit/new_silence/player/segment_plotter.py:\n        cur_xlim = self.ax.get_xlim()\n\n<|end|><|start|>user<|message|>## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n<|end|><|start|>user<|message|>## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n<|end|><|start|>user<|message|># Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:160-206\ndef _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            rich.inspect(event)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n            # save mp4 clip\n            clip_path = clip_full_window(\n                explain,\n                self.analysis,\n                window,\n            )\n            if clip_path:\n                print(f\"Saved clip to {clip_path}\")\n\n        else:\n            # * play a single segment (under cursor)\n            for seg in self.segments:\n                if seg.start_seconds <= clicked_at_seconds <= seg.end_seconds:\n                    self._play_segment(seg.start_seconds, seg.end_seconds)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:281-289\ndef zoom_to_gap(self, window: GapWindow) -> None:\n        if window is None:\n            return\n        # fixed zoom level with gap centered (not full window, just the gap of silence)...\n        middle = (window.gap.start_seconds() + window.gap.end_seconds()) / 2\n        width_seconds = 2  # fixed width in seconds\n        self.ax.set_xlim(middle - width_seconds / 2, middle + width_seconds / 2)\n        self.toggle_zoom_level_elements()\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:158-177\n\n\n    def _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:295-299\ndef zoom_and_center_to(self, width_seconds: float) -> None:\n        \"\"\"Zoom the plot to a fixed width centered on the current view.\"\"\"\n        cur_xlim = self.ax.get_xlim()\n        middle = (cur_xlim[0] + cur_xlim[1]) / 2\n        half = width_seconds / 2\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:0-16\nimport math\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport rich\nimport sounddevice as sd\nimport time\nfrom dataclasses import dataclass\nfrom matplotlib.text import Annotation, Text\nfrom matplotlib.lines import Line2D\nfrom auto_edit.new_silence.player.clipper import clip_full_window\nfrom auto_edit.new_silence.player.crosshairs import ToggleableCursor\nfrom auto_edit.new_silence.player.plot_helpers import is_alt, is_ctrl, is_shift, setup_events\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, GapWindow, DetectedSegment, SegmentLabel\nfrom auto_edit.new_silence.player.prompter import applescript_prompt\n\n\n<|end|><|start|>user<|message|>extract a func for the common first part\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/plot_helpers.py:\n    def key_ctrl_left(event):\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        current_index = None\n        for i, win in enumerate(plotter.windows):\n            if win.gap.start_seconds() <= center <= win.gap.end_seconds():\n                current_index = i\n                break\n        if current_index is None or current_index == 0:\n            return\n        prev_win = plotter.windows[current_index - 1]\n        plotter.center_on_gap_of(prev_win)\n\n    def key_ctrl_right(event):\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        current_index = None\n        for i, win in enumerate(plotter.windows):\n            if win.gap.start_seconds() <= center <= win.gap.end_seconds():\n                current_index = i\n                break\n        if current_index is None or current_index >= len(plotter.windows) - 1:\n            return\n        next_win = plotter.windows[current_index + 1]\n        plotter.center_on_gap_of(next_win)\n<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 2024,
    "timings": {
      "cache_n": 0,
      "prompt_n": 1787,
      "prompt_ms": 279.579,
      "prompt_per_token_ms": 0.1564515948517068,
      "prompt_per_second": 6391.753314805475,
      "predicted_n": 238,
      "predicted_ms": 1148.439,
      "predicted_per_token_ms": 4.8253739495798325,
      "predicted_per_second": 207.2378245601203
    }
  }
}
