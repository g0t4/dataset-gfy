{
  "model": "",
  "max_tokens": 4096,
  "stream": true,
  "temperature": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "messages": [
    {
      "content": "You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. ",
      "role": "system"
    },
    {
      "content": "## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        if event.key == \"left\":\n            key_left(event)\n        elif event.key == \"right\":\n            key_right(event)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nkey_ctrl_left\n\n.. yanked from auto_edit/new_silence/detects/segments.py:\n    def end_seconds(self) -> float:\n        return self.segments[-1].end_seconds\n\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        xlim = plotter.ax.get_xlim()\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n    def center_on_gap_of(win: GapWindow):\n\n.. yanked from auto_edit/new_silence/player/segment_plotter.py:\n        cur_xlim = self.ax.get_xlim()\n\n",
      "role": "user"
    },
    {
      "content": "## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n",
      "role": "user"
    },
    {
      "content": "## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n",
      "role": "user"
    },
    {
      "content": "# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:160-206\ndef _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            rich.inspect(event)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n            # save mp4 clip\n            clip_path = clip_full_window(\n                explain,\n                self.analysis,\n                window,\n            )\n            if clip_path:\n                print(f\"Saved clip to {clip_path}\")\n\n        else:\n            # * play a single segment (under cursor)\n            for seg in self.segments:\n                if seg.start_seconds <= clicked_at_seconds <= seg.end_seconds:\n                    self._play_segment(seg.start_seconds, seg.end_seconds)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:281-289\ndef zoom_to_gap(self, window: GapWindow) -> None:\n        if window is None:\n            return\n        # fixed zoom level with gap centered (not full window, just the gap of silence)...\n        middle = (window.gap.start_seconds() + window.gap.end_seconds()) / 2\n        width_seconds = 2  # fixed width in seconds\n        self.ax.set_xlim(middle - width_seconds / 2, middle + width_seconds / 2)\n        self.toggle_zoom_level_elements()\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:158-177\n\n\n    def _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:295-299\ndef zoom_and_center_to(self, width_seconds: float) -> None:\n        \"\"\"Zoom the plot to a fixed width centered on the current view.\"\"\"\n        cur_xlim = self.ax.get_xlim()\n        middle = (cur_xlim[0] + cur_xlim[1]) / 2\n        half = width_seconds / 2\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:0-16\nimport math\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport rich\nimport sounddevice as sd\nimport time\nfrom dataclasses import dataclass\nfrom matplotlib.text import Annotation, Text\nfrom matplotlib.lines import Line2D\nfrom auto_edit.new_silence.player.clipper import clip_full_window\nfrom auto_edit.new_silence.player.crosshairs import ToggleableCursor\nfrom auto_edit.new_silence.player.plot_helpers import is_alt, is_ctrl, is_shift, setup_events\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, GapWindow, DetectedSegment, SegmentLabel\nfrom auto_edit.new_silence.player.prompter import applescript_prompt\n\n\n",
      "role": "user"
    },
    {
      "content": "extract a func for the common first part\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/plot_helpers.py:\n    def key_ctrl_left(event):\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        current_index = None\n        for i, win in enumerate(plotter.windows):\n            if win.gap.start_seconds() <= center <= win.gap.end_seconds():\n                current_index = i\n                break\n        if current_index is None or current_index == 0:\n            return\n        prev_win = plotter.windows[current_index - 1]\n        plotter.center_on_gap_of(prev_win)\n\n    def key_ctrl_right(event):\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        current_index = None\n        for i, win in enumerate(plotter.windows):\n            if win.gap.start_seconds() <= center <= win.gap.end_seconds():\n                current_index = i\n                break\n        if current_index is None or current_index >= len(plotter.windows) - 1:\n            return\n        next_win = plotter.windows[current_index + 1]\n        plotter.center_on_gap_of(next_win)\n",
      "role": "user"
    }
  ],
  "top_p": 1
}
