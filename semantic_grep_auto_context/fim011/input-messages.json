{
  "stream": true,
  "options": [],
  "messages": [
    {
      "role": "developer",
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
    },
    {
      "role": "user",
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:111-119\n@dataclass\nclass MinMeasures:\n    seconds: float\n    rms: float\n    frame_aligned_at_seconds: float\n    # FYI these are ONLY intended for testing (to help verify intermediate calculations before frame_aligned is computed)\n    # also they've been very helpful with troubleshooting bugs\n    _testing_frame_before: int\n    _testing_frame_after: int\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/gaps.py:109-121\n            _testing_frame_after=frame_num_after,\n            frame_aligned_at_seconds=frame_aligned_at_seconds,\n        )\n\n    # * find left_speech's end of taper\n    first_min_is_at_hops = find_first_min(rms_values_in_gap)  # btw _hops == _idx == offset in # hops (samples of rms_db values where hop_len dictates sampling frequency)\n    window.first_min = find_best_frame_to_cut_at(first_min_is_at_hops)\n\n    # * ramp up for right_speech's start (first_min, in reverse)\n    last_min_is_at_hops_from_end = find_first_min(np.flip(rms_values_in_gap))\n    last_min_is_at_hops = len(rms_values_in_gap) - 1 - last_min_is_at_hops_from_end\n    window.last_min = find_best_frame_to_cut_at(last_min_is_at_hops)\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/gaps.py:49-68\n\n\n    HOPS_PER_SECOND = analysis.hops_per_second()\n    gap_starts_at_seconds = window.gap.segments[0].start_seconds\n    FPS = analysis.fps\n\n    def find_best_frame_to_cut_at(min_is_at_hops_relative):\n\n        min_is_at_seconds_globally = gap_starts_at_seconds + min_is_at_hops_relative / HOPS_PER_SECOND\n        # global as in across entire video (not gap relative like min_is_at_hops_relative)\n        _gap_starts_at_hops = round(gap_starts_at_seconds * HOPS_PER_SECOND)\n        min_is_at_hops_globally = _gap_starts_at_hops + min_is_at_hops_relative\n\n        # * compute frame number before and after, EXACT frame (not partial)\n        min_is_at_frame = min_is_at_seconds_globally * FPS\n        frame_num_before = math.floor(min_is_at_seconds_globally * FPS)\n        frame_num_after = math.ceil(min_is_at_seconds_globally * FPS)\n\n        # * if on a frame, then STOP and return!\n        if frame_num_before == frame_num_after:\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detector_notebook.py:45-64\n#\n\n# * noteworthy stellar breathing test cases (fit my pattern of double dip w/ bounce):\n#   from minute1 video too\n#\n# 59: speech ending at 29:17.82 => ~300ms w/ breathing for 220+ms of it (first_idx/last_idx surround perfectly)\n#      29dB peak of breathing, 39.9dB double dip points (both sides hit about the same)\n#      similar gaps times: ~24s \n#\n\n# * noteworthy for testing last_min\n# 21: speech starting at 05:15.99 => right before this has a blip with a min for like one frame and it qualifies as the lowest point on the way back up to the start of speaking! (right speech)\n# 127: speech starting at 49:25.48  => * POSSIBLE ISSUE => has a drop and new local min on the way up... odd!\n#    after some typing.. so no I do not need the typing right before... but still interesting!\n#    *UNIQUE for sure... has typing RIGHT before speech resumes... could be a good test case of finding last_min to make sure it truly is last! \n#    BUT I should say this still fits the pattern of the last_min is the safe place for cut right before speaking resumes!\n#    TYPING wise lots of good examples nearby:\n#      next gaps: around 54seconds, 56 seconds (this one is medium length if I need any tests of that)\n# 147: ***! 58:28.16 => PROBLEMO!\n#    there is breathing in between first_min and what could be considered last_min \n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:45-67\ndef test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1.5),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2.1),\n        )\n        wins = [win]\n        ranges = get_ranges(wins, TEST_VIDEO_FPS)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n"
    },
    {
      "role": "user",
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n               .up(10).down(2) # breathing bounce\n              .up(10), # speech rampup\n           right_speech=ONE_SECOND_MINUS20(),\n           up_db=2,\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.rms == -45\n        assert window.first_min.seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min\n        assert window.last_min.rms == -37\n        assert window.last_min.seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n        #\n        # OR not use 2dB? and instead this will match first_min?\n        # assert window.last_min.rms == window.first_min.rms\n        # assert window.last_min.seconds == window.first_min.seconds\n\n    def test_breathing_bounce_with_2dB_on_first_min(self):\n        # FYI edge case of (jump == up_db) # TODO analysis.up_db\n\n        analysis = compute_speech_boundaries( \\\n           left_speech=ONE_SECOND_MINUS20(),\n           gap = start(-20)\n               .down(25) # speech taper\n               .up(2).down(10) # breathing bounce\n               .up(10), # speech rampup\n           up_db=2,\n           right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.rms == -45\n        assert window.first_min.seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min\n        assert window.last_min.rms == -53\n        assert window.last_min.seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n\n    def test_mark_all_nearest_frames(self):\n        # BTW\n        # 25 samples/hop (hop_len)\n        # 22050 samples/sec (audio sample_rate)\n        # (22050 samples/sec) / (25 samples/hop)\n        #    => 882 hops/sec\n        # 30 frames/sec (video sample_rate)\n        # (882 hops/sec) / (30 frames/sec)\n        #   => 882/30\n        #   => 29.4 hops/frame\n\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .flat(40)\n                .down(1) # frame_min => 41 hops / 29.4 hops per frame =  1.39455782 frames (past start of segment which is @1sec/30frames)\n                .up(5).down(10) # breathing bounce\n                # at this point => 56 hops (41 to first_min + 5+10 == 56) => 56 / 29.4 = 1.9047619047619048\n                .flat(100) # go along ways to cross into many frames later\n                .down(1) # last_min (after this dip) => 157 hops (56+100+1) => 157 / 29.4 = 5.340136054421768\n                .up(10),\n                # .plot()\n           right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        # FYI these assertions are on intermediate steps\n        #  could remove these but they're also nice as a sanity check\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 41 / 882)\n        assert window.first_min._testing_frame_before == 31\n        assert window.first_min._testing_frame_after == 32\n        #\n        assert window.last_min\n        assert window.last_min.seconds == pytest.approx(1.0 + 157 / 882)\n        assert window.last_min._testing_frame_before == 35\n        assert window.last_min._testing_frame_after == 36\n\n    def test__first_min_is_on_a_frame__returns_that_frame(self):\n        <|fim_middle|>\n\n        \n\n    def test__spike_before__first_min__flat_after__picks_frame_after(self):\n        analysis = compute_speech_boundaries( \\\n            left_speech = ONE_SECOND_MINUS20(),\n            gap = start(-20)\n                .add(np.array([-20])) # TODO helper?\n                .down(1) # 2 hops  (30/31 frames around\n                .up(1) # 2 hops  (30/31 frames around\n                .flat(40),\n                # .plot(),\n            right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 2 / 882)\n        assert window.first_min._testing_frame_before == 30\n        assert window.first_min._testing_frame_after == 31\n\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(31 / 30)\n\n    def test__spike_after__first_min__flat_before__picks_frame_before(self):\n\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .flat(20)\n                .down(1) # 21 hops \n                .add(np.array([20])),\n           right_speech = ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 21 / 882)\n        assert window.first_min._testing_frame_before == 30\n        assert window.first_min._testing_frame_after == 31\n\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(30 / 30)\n\n    def test__spike_before__last_min__flat_after__picks_frame_after(self):\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .add(np.array([-10]))\n                # first_min\n                .up(10)\n                .flat(100)\n                .down(10) # last_min \n                .flat(5) # visually gives a bit of separation\n                .up(1)\n                .flat(30),\n                # .plot(),\n           right_speech = ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        # -22,-21 before_max\n        # -29 after_max\n        assert window.last_min\n        assert window.last_min.seconds == pytest.approx(1.0 + 126 / 882)\n        assert window.last_min._testing_frame_before == 34\n        assert window.last_min._testing_frame_after == 35\n\n        assert window.last_min.frame_aligned_at_seconds == pytest.approx(35 / 30)\n\n    def test__flat_before__last_min__spike_after__picks_frame_before(self):\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .add(np.array([-10]))\n                # first_min\n                .up(10)\n                .flat(100)\n                .down(10)\n                .flat(50)\n                .down(1) # last_min (172 hops) => 5.85 frames (so, 0.85 frames before, 0.15 frames after... ~= 0.85*29.4=25hops before, 0.15*29.4=4.41hops after)\n                .add(np.array([10]))"
    }
  ],
  "max_tokens": 4096,
  "temperature": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "model": "gpt-oss:120b",
  "top_p": 1,
  "raw": false
}
