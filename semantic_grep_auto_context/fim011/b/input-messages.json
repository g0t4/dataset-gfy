{
  "top_p": 1,
  "temperature": 1,
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/gaps.py:\nmin_is_at_seconds_globally\n\n.. yanked from auto_edit/new_silence/gaps.py:\nmin_is_at_hops_globally\n\n\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:111-119\n@dataclass\nclass MinMeasures:\n    seconds: float\n    rms: float\n    frame_aligned_at_seconds: float\n    # FYI these are ONLY intended for testing (to help verify intermediate calculations before frame_aligned is computed)\n    # also they've been very helpful with troubleshooting bugs\n    _testing_frame_before: int\n    _testing_frame_after: int\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/gaps.py:64-83\n        frame_num_before = math.floor(min_is_at_seconds_globally * FPS)\n        frame_num_after = math.ceil(min_is_at_seconds_globally * FPS)\n\n        # * if on a frame, then STOP and return!\n        if frame_num_before == frame_num_after:\n            # FYI this only happens if min_is_at_frame is exactly at .00000000\n            # TODO test case 2/3 when min_is_at_frame ends with 0.0000001 or 0.99999994 (smth like this)\n            #      these cases result in frame_num_before/after not the same, BUT below when .max() is called\n            #      w/o the +1 on the upper end of the range it would explode b/c if min_is_at_frame is basically on a frame\n            #      then there are no hop points to max() over\n            #      thus workaround for now is always make sure that min_is_at_hops_globally is included as a data point so max never fails\n            min_rms_value = analysis.rms_db[min_is_at_hops_globally]  # lookup just to put into result\n            return MinMeasures(\n                seconds=min_is_at_seconds_globally,\n                rms=min_rms_value,\n                _testing_frame_before=frame_num_before,\n                _testing_frame_after=frame_num_after,\n                frame_aligned_at_seconds=min_is_at_seconds_globally,\n            )\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player.py:118-137\n                end_seconds = win.get_window_end_seconds()\n                if start_seconds is None or end_seconds is None:\n                    continue\n                self.ax.axvspan(\n                    start_seconds,\n                    end_seconds,\n                    color=\"orange\",\n                    alpha=0.3,\n                    label=\"Window Gap\" if \"Window Gap\" not in self.ax.get_legend_handles_labels()[1] else None,\n                )\n\n                # * show detected minima inside the window as vertical lines\n                if win.first_min:\n                    self.add_annotation_arrow(win.first_min.seconds, win.first_min.rms)\n                    self.mark_aligned_frame(win.first_min.frame_aligned_at_seconds, win.first_min.rms)\n                    # rms is for _min.seconds, not min.frame_aligned_at_seconds, but, use it for both\n                if win.last_min:\n                    self.add_annotation_arrow(win.last_min.seconds, win.last_min.rms)\n                    self.mark_aligned_frame(win.last_min.frame_aligned_at_seconds, win.last_min.rms)\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:156-173\ndef test_window_without_right_speech(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1),\n            gap=NonSpeechGap(segments=[silence_seg(1, 2)]),\n            right_speech=None,\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2),\n        )\n        wins = [win]\n        ranges = get_ranges(wins, TEST_VIDEO_FPS)\n        # speech at the start\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 30\n        assert type(ranges[0]) == ContentRange\n        # following silence segment\n        assert ranges[1].start_frame == 30\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == SilenceRange\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:45-67\ndef test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1.5),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2.1),\n        )\n        wins = [win]\n        ranges = get_ranges(wins, TEST_VIDEO_FPS)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n        #\n        # OR not use 2dB? and instead this will match first_min?\n        # assert window.last_min.rms == window.first_min.rms\n        # assert window.last_min.seconds == window.first_min.seconds\n\n    def test_breathing_bounce_with_2dB_on_first_min(self):\n        # FYI edge case of (jump == up_db) # TODO analysis.up_db\n\n        analysis = compute_speech_boundaries( \\\n           left_speech=ONE_SECOND_MINUS20(),\n           gap = start(-20)\n               .down(25) # speech taper\n               .up(2).down(10) # breathing bounce\n               .up(10), # speech rampup\n           up_db=2,\n           right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.rms == -45\n        assert window.first_min.seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min\n        assert window.last_min.rms == -53\n        assert window.last_min.seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n\n    def test_mark_all_nearest_frames(self):\n        # BTW\n        # 25 samples/hop (hop_len)\n        # 22050 samples/sec (audio sample_rate)\n        # (22050 samples/sec) / (25 samples/hop)\n        #    => 882 hops/sec\n        # 30 frames/sec (video sample_rate)\n        # (882 hops/sec) / (30 frames/sec)\n        #   => 882/30\n        #   => 29.4 hops/frame\n\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .flat(40)\n                .down(1) # frame_min => 41 hops / 29.4 hops per frame =  1.39455782 frames (past start of segment which is @1sec/30frames)\n                .up(5).down(10) # breathing bounce\n                # at this point => 56 hops (41 to first_min + 5+10 == 56) => 56 / 29.4 = 1.9047619047619048\n                .flat(100) # go along ways to cross into many frames later\n                .down(1) # last_min (after this dip) => 157 hops (56+100+1) => 157 / 29.4 = 5.340136054421768\n                .up(10),\n                # .plot()\n           right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        # FYI these assertions are on intermediate steps\n        #  could remove these but they're also nice as a sanity check\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 41 / 882)\n        assert window.first_min._testing_frame_before == 31\n        assert window.first_min._testing_frame_after == 32\n        #\n        assert window.last_min\n        assert window.last_min.seconds == pytest.approx(1.0 + 157 / 882)\n        assert window.last_min._testing_frame_before == 35\n        assert window.last_min._testing_frame_after == 36\n\n    def test__first_min_is_on_a_frame__returns_that_frame(self):\n        analysis = compute_speech_boundaries( \\\n            left_speech=ONE_SECOND_MINUS20(),\n            gap=start(-20)\n                .down(147),  # first_min exactly on a frame (frame 5 into gap)\n            right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n        assert window.first_min\n        assert window.first_min._testing_frame_before == 35\n        assert window.first_min._testing_frame_after == 35\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(35 / 30)\n\n        # let's also assert other values match (this is impl specific but won't hurt)\n        #  b/c I use entirely separatley MinMeasures() ctor call\n        <|fim_middle|>\n\n\n    def test__spike_before__first_min__flat_after__picks_frame_after(self):\n        analysis = compute_speech_boundaries( \\\n            left_speech = ONE_SECOND_MINUS20(),\n            gap = start(-20)\n                .add(np.array([-20])) # TODO helper?\n                .down(1) # 2 hops  (30/31 frames around\n                .up(1) # 2 hops  (30/31 frames around\n                .flat(40),\n                # .plot(),\n            right_speech=ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 2 / 882)\n        assert window.first_min._testing_frame_before == 30\n        assert window.first_min._testing_frame_after == 31\n\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(31 / 30)\n\n    def test__spike_after__first_min__flat_before__picks_frame_before(self):\n\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .flat(20)\n                .down(1) # 21 hops \n                .add(np.array([20])),\n           right_speech = ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 21 / 882)\n        assert window.first_min._testing_frame_before == 30\n        assert window.first_min._testing_frame_after == 31\n\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(30 / 30)\n\n    def test__spike_before__last_min__flat_after__picks_frame_after(self):\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .add(np.array([-10]))\n                # first_min\n                .up(10)\n                .flat(100)\n                .down(10) # last_min \n                .flat(5) # visually gives a bit of separation\n                .up(1)\n                .flat(30),\n                # .plot(),\n           right_speech = ONE_SECOND_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        # -22,-21 before_max\n        # -29 after_max\n        assert window.last_min\n        assert window.last_min.seconds == pytest.approx(1.0 + 126 / 882)\n        assert window.last_min._testing_frame_before == 34\n        assert window.last_min._testing_frame_after == 35\n\n        assert window.last_min.frame_aligned_at_seconds == pytest.approx(35 / 30)\n\n    def test__flat_before__last_min__spike_after__picks_frame_before(self):\n        analysis = compute_speech_boundaries( \\\n           left_speech = ONE_SECOND_MINUS20(),\n           gap = start(-20)\n                .add(np.array([-10]))\n                # first_min\n                .up(10)\n                .flat(100)\n                .down(10)\n                .flat(50)\n                .down(1) # last_min (172 hops) => 5.85 frames (so, 0.85 frames before, 0.15 frames after... ~= 0.85*29.4=25hops before, 0.15*29.4=4.41hops after)\n                .add(np.array([10]))\n                .flat(20), # not necessary but useful to visualize",
      "role": "user"
    }
  ],
  "options": [],
  "stream": true,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "max_tokens": 4096,
  "model": "gpt-oss:120b",
  "raw": false
}
