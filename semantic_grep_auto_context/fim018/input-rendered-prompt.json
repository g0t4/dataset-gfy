{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1766940589,
  "id": "chatcmpl-6I58U7VZfw24cftPsRaDthPKeOWdkanE",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 593,
    "prompt_n": 2462,
    "prompt_ms": 706.51,
    "prompt_per_token_ms": 0.286965881397238,
    "prompt_per_second": 3484.7348232862946,
    "predicted_n": 156,
    "predicted_ms": 785.469,
    "predicted_per_token_ms": 5.035057692307693,
    "predicted_per_second": 198.60745618222998
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 2,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 156,
    "tokens_evaluated": 3055,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-28\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n\n\n<|end|><|start|>user<|message|>Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing_state.py:15-18\ndef text(x_position, y_position, text):\n    txt = plt.gca().text(x_position, y_position, text)\n    plotted_lines.append(txt)\n    return txt\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/transcribe.py:27-28\ndef __str__(self):\n        return f\"Segment({self.start_frame}, {self.end_frame}, '{self.text}', words={len(self.words)})\"\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/transcribe.py:9-13\ndef __init__(self, start_frame, end_frame, text):\n        self.start_frame = start_frame  # todo integer?\n        self.end_frame = end_frame  # todo integer?\n        self.text: str = text\n        self.words: list[WhisperWord] = []\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/transcribe.py:32-36\ndef __init__(self, start_frame, end_frame, text, probability):\n        self.start_frame = start_frame  # todo integer?\n        self.end_frame = end_frame  # todo integer?\n        self.text: str = text\n        self.probability: float = probability\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/transcribe.py:44-45\ndef __str__(self):\n        return f\"Word({self.start_frame}, {self.end_frame}, '{self.text}')\"\n<|end|><|start|>user<|message|>Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nimport librosa\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport rich\nfrom rich.console import Console\nfrom scipy.ndimage import uniform_filter1d\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, MAX_POSSIBLE_VALUE_NORMALIZED_AUDIO\nfrom auto_edit.new_silence.detects.breathing_state import plot, clear\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode_markup\n\nconsole = Console()\n\ndef plot_zero_line(win, shift):\n    start = win.gap.start_seconds()\n    end = win.gap.end_seconds()\n    x_s = [start, end]\n    y_s = [shift, shift]\n    plot(x_s, y_s, color=\"white\", linewidth=1)\n\ndef detect_possible_breathing(analysis: AudioAnalysisResult):\n    clear()\n\n    for win in analysis.windows:\n\n        assert win.first_min and win.last_min\n\n        console.print(f\"gap: {seconds_to_timecode_markup(win.gap.start_seconds(), fps=analysis.fps)} => \"\n                      f\"{seconds_to_timecode_markup(win.gap.end_seconds(), fps=analysis.fps)}\", highlight=False)\n\n        # * ALWAYS plot... first derivative (diff1) + signs + signs smoothed\n        gap_rms, gap_hops = analysis.get_gap_rms_db(win)\n        diff1 = np.diff(gap_rms)\n        shift_diff1 = -15\n        plot(gap_hops[1:], diff1, color=\"green\", linewidth=1, shift=shift_diff1, label_end=\"diff1\")\n\n        # * first derivative w/ rounding to zero for small numbers + signs + signs smoothed\n        diff1_rounded = diff1.copy()\n        diff1_rounded[(-1 < diff1_rounded) & (diff1_rounded < 1)] = 0  # round small values to zero (eliminate noise)\n        shift_diff1_rounded = 0\n        plot(gap_hops[1:], diff1_rounded, color=\"orange\", linewidth=1, shift=shift_diff1_rounded, label_end=\"diff1_rounded\")\n\n        # PRN asymmetric negative threshold? (maybe -0.5? or -0.75? just for negative?)\n        # , works b/c I am mostly interested in slope spikes > 5 for positive side, > 2? for negative side\n        # TODO split on spike (ramp-up)... you need taper signal so that consecutive positive spikes are not split apart but kept together  (think jump => level => jump)\n        #   then have list of breathing regions per window\n        #   use this to selectively mute gaps!\n        #\n\n        def plot_smooth_signs(what, shift, color, label_end):\n            # signs first\n            plot(gap_hops[1:], np.sign(what), color=color, linewidth=1, shift=shift, label_end=label_end)\n\n            # smoothed signs overlay\n            smooth = uniform_filter1d(what, size=25)  # ~13 ms (25/48_000 => 1/1920*25 ~= 13ms)\n            sign = np.sign(smooth)\n            plot(gap_hops[1:], sign, color=\"black\", linewidth=1, shift=shift)\n\n        # plot_smooth_signs(diff1, shift_diff1 - 5, \"green\", \"signs(diff1)\")\n        plot_smooth_signs(diff1_rounded, shift_diff1_rounded - 5, \"orange\", \"signs(diff1_rounded)\")\n\n        only_one_dip = win.first_min.seconds == win.last_min.seconds\n        if only_one_dip:\n            print(\"  REJECTED, only [red]one dip[/]\")\n            plot(gap_hops, gap_rms, color=\"white\", linewidth=1)\n            continue\n\n        # * plot diff to visualize slope factors\n        #   this made it immediately obvious that spikes in slope are key!\n        m2m_start = analysis.to_hops(win.first_min.seconds)\n        m2m_end = analysis.to_hops(win.last_min.seconds)\n        # hops = np.arange(hop_start, hop_end) / analysis.hops_per_second()\n        min2min_hops = analysis.time_stamps[m2m_start:m2m_end]\n        min2min_rms = analysis.rms_db[m2m_start:m2m_end]\n        min2min_diff = np.diff(min2min_rms)  # ?? rename to be more specific (or isolate this code, i.e. in a function)\n        # rich.print(f\"  min2min max_slope={np.abs(min2min_diff).max():.2f}, min_slope={np.min(min2min_diff):.2f}\")\n        plot(min2min_hops[1:], min2min_diff, color=\"lightgreen\", linewidth=1, shift=shift_diff1)\n        plot_zero_line(win, shift=shift_diff1)\n\n        # * plot second derivative\n        # #  FYI not really seeing anything here that adds to what I have with diff1\n        # diff2 = np.diff(diff1)\n        # shift_diff2 = -25\n        # plot(gap_hops[2:], diff2, color=\"indigo\", linewidth=1, shift=shift_diff2, label_end=\"diff2\")\n        # m2m_diff2 = np.diff(min2min_diff)\n        # plot(min2min_hops[2:], m2m_diff2, color=\"mediumpurple\", linewidth=1, shift=shift_diff2)\n        # plot_zero_line(win, shift_diff2)\n\n        def inner_slope_has_spike() -> bool:\n            # ends of breathing can have small spikes, so exclude those\n            # - FYI probably could avoid this if I cut on spikes in slope\n            pad = int(0.02 * len(min2min_rms))\n            slope = np.diff(min2min_rms[pad:-pad])\n            max_slope = np.abs(slope).max()\n            min_slope = np.min(slope)\n            if max_slope > 3:\n                rich.print(f\"  [dark_orange]SLOPE SPIKE[/] in inner_diff: [dark_orange]{max_slope=:.2f}[/], {min_slope=:.2f}\")\n                if not try_new_split_on_spike_in_slope(analysis, win):\n                    plot(min2min_hops, min2min_rms, color=\"pink\", linewidth=1)\n                return True\n\n            # rich.print(f\"  inner {max_slope=:.2f}, {min_slope=:.2f}\") # FYI helpful to find thresholds for zeroing in diff1_rounded\n            return False\n\n        if inner_slope_has_spike():\n            continue\n\n        min_duration_seconds = win.last_min.seconds - win.first_min.seconds\n        if not (0.120 < min_duration_seconds):\n            # FYI no upper limit needed! I had a bug of 400s and never noticed problems so I just chopped that constraint\n            # IIAC too short == nothing much to learn about it from try_new_split_on_spike_in_slope approach, though I could use it nonetheless\n            print(\"  REJECTED [red]too short[/]\")\n            plot(min2min_hops, min2min_rms, color=\"brown\", linewidth=1)\n            continue\n\n        # FYI I suspect slope spike detection obviates the need for this:\n        dips_below_both_sides = min2min_rms.min() < min(win.last_min.rms, win.first_min.rms)\n        if dips_below_both_sides:\n            # ideal breathing does not dip below first/last mins\n            print(\"  RMS has [dark_orange]min below first/last_min[/]\")\n            text(<|fim_middle|>\n            try_new_split_on_spike_in_slope(analysis, win)\n            continue\n\n        # ** mark detected breathing in thick, blue\n        plot(min2min_hops, min2min_rms, color=\"blue\", linewidth=3)\n        rich.print(\"  [green]breathing suspected[/]\")\n\ndef try_new_split_on_spike_in_slope(analysis, win) -> bool:\n    rich.print(f\"    Attempting split on spike in slope for gap {win.gap.start_seconds():.2f}->{win.gap.end_seconds():.2f}\")\n    return False\n\n# NOTES\n# weighted scoring + threshold:\n#   duration score\n#     300-400ms (ideal) => highest score for duration\n#     250-300ms medium score\n#     <200ms => REJECT or score very low\n#     <100ms => 100% reject, never happens (usually typing)\n#\n#  EASIEST WAY:\n#  * 1) 300-400ms w/ first/last_min only and nothing below them => speech\n#    this alone will likely do it\n#   2) Validate the hump between them\n#       For each (min₁, min₂) pair:\n#         Let hump_max = max(envelope[min₁ : min₂])\n#       Require:\n#         hump_prominence = hump_max - max(min₁, min₂) > X dB # * > X dB (keep in mind frame_len eats away at extremes so would need to adjust X if adjust frame_len)\n#         hump_width > ~150–250 ms\n#         hump_flatness: low variance of slope near the top (breathing humps are rounded, not spiky)\n#\n#   crest score\n#     minimum:\n#       min(envelope[first_min, last_min]) > first_min&last_min # nothing lower that first/last mins\n#       slop (rate of change) starts higher => drops to zero => stays nearly zero for a big (not always) => goes negative and increases negative\n#         can RMS(rms_db_value[next]-rms_db_value[current]) to get smoothed out view\n#\n#       for ideal breath => no other local minimums ... IOTW bounce does not have other material dips, especially NOT that dip below first_min/last_min\n#     how flat is it (vs pointy)\n#     deriviative?<|end|><|start|>assistant",
    "has_new_line": false,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 3210,
    "timings": {
      "cache_n": 593,
      "prompt_n": 2462,
      "prompt_ms": 706.51,
      "prompt_per_token_ms": 0.286965881397238,
      "prompt_per_second": 3484.7348232862946,
      "predicted_n": 156,
      "predicted_ms": 785.469,
      "predicted_per_token_ms": 5.035057692307693,
      "predicted_per_second": 198.60745618222998
    }
  }
}
