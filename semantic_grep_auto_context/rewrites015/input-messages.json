{
  "max_tokens": 4096,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "top_p": 1,
  "stream": true,
  "messages": [
    {
      "role": "system",
      "content": "You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "
    },
    {
      "role": "user",
      "content": "## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
    },
    {
      "role": "user",
      "content": "## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"
    },
    {
      "role": "user",
      "content": "# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:0-16\nimport math\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport rich\nimport sounddevice as sd\nimport time\nfrom dataclasses import dataclass\nfrom matplotlib.text import Annotation, Text\nfrom matplotlib.lines import Line2D\nfrom auto_edit.new_silence.player.clipper import clip_full_window\nfrom auto_edit.new_silence.player.crosshairs import ToggleableCursor\nfrom auto_edit.new_silence.player.plot_helpers import is_alt, is_ctrl, is_shift, setup_events\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, GapWindow, DetectedSegment, SegmentLabel\nfrom auto_edit.new_silence.player.prompter import applescript_prompt\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:6-63\n@dataclass\nclass TimeSeries:\n    \"\"\"Key purpose is to store a sequence of sampled values aligned with timestamps.\n\n    Also, to support common calculations such as diff, smooth, sign, and stepped with transparent and consistent values and times.\n    And, some common plot operations to quickly visualize sequences.\n\n    This helps avoid an explosion of two variables _values/_times for every intermediate series!\n    And, you can pass both values/times as a single unit.\n    \"\"\"\n    values: np.ndarray\n    times: np.ndarray\n\n    def copy_values(self):\n        return TimeSeries(values=self.values.copy(), times=self.times)\n\n    def plot(self, shift: float | int | None = None, label_end: str | None = None, **kwargs) -> list[Line2D]:\n        return plot(self.times, self.values, shift=shift, label_end=label_end, **kwargs)\n\n    def plot_sign_and_smooth_sign(self, shift, color, label_end):\n        self.sign().plot(color=color, linewidth=1, shift=shift, label_end=label_end)\n        self.smooth().sign().plot(color=\"black\", linewidth=1, shift=shift)\n\n    def smooth(self, size: int = 25) -> \"TimeSeries\":\n        return TimeSeries(values=uniform_filter1d(self.values, size=size), times=self.times)\n\n    def sign(self) -> \"TimeSeries\":\n        return TimeSeries(values=np.sign(self.values), times=self.times)\n\n    def stepped(self, step_size=2) -> \"TimeSeries\":\n        return TimeSeries(\n            values=self.values[::step_size],\n            times=self.times[::step_size],\n        )\n\n    def diff(self, align: str = \"right\") -> \"TimeSeries\":\n        \"\"\"Return the first‑order difference.\n\n        ``align`` determines how timestamps are generated:\n        * ``\"right\"`` (default) – timestamps correspond to the right sample of the\n          pair, matching the historic behaviour.\n        * ``\"mid\"`` – timestamps are placed at the midpoint between the two\n          samples used to compute each difference.\n        \"\"\"\n        values = np.diff(self.values)\n        if align == \"mid\":\n            times = 0.5 * (self.times[1:] + self.times[:-1])\n        else:  # right‑aligned fallback\n            times = self.times[1:]\n        return TimeSeries(values=values, times=times)\n\n    def mark_rejected(self, why: str):\n        text_label(\n            x_pos=self.times[len(self.times) // 2],\n            y_pos=self.values.max() + 3,\n            text=why,\n        )\n        self.plot(color=\"pink\", linewidth=1)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:0-19\nimport numpy as np\nfrom dataclasses import dataclass\nfrom matplotlib.lines import Line2D\nfrom scipy.ndimage import uniform_filter1d\nfrom auto_edit.new_silence.detects.breathing_state import plot, text_label\n\n@dataclass\nclass TimeSeries:\n    \"\"\"Key purpose is to store a sequence of sampled values aligned with timestamps.\n\n    Also, to support common calculations such as diff, smooth, sign, and stepped with transparent and consistent values and times.\n    And, some common plot operations to quickly visualize sequences.\n\n    This helps avoid an explosion of two variables _values/_times for every intermediate series!\n    And, you can pass both values/times as a single unit.\n    \"\"\"\n    values: np.ndarray\n    times: np.ndarray\n\n    \n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:25-27\ndef plot_sign_and_smooth_sign(self, shift, color, label_end):\n        self.sign().plot(color=color, linewidth=1, shift=shift, label_end=label_end)\n        self.smooth().sign().plot(color=\"black\", linewidth=1, shift=shift)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:0-17\nfrom pathlib import Path\nimport subprocess\nimport rich\nimport sounddevice as sd\nfrom matplotlib.axes import Axes\nfrom matplotlib.backend_bases import CloseEvent, KeyEvent, MouseEvent\nfrom matplotlib.collections import PathCollection\nfrom matplotlib.figure import Figure\nfrom matplotlib.lines import Line2D\n\nfrom auto_edit.new_silence.detect import AnalysisParams, create_analysis\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode\nfrom auto_edit.new_silence.detects.segments import GapWindow\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from .segment_plotter import SegmentPlotter\n\n\n"
    },
    {
      "role": "user",
      "content": "first loop over changed records and create Changed DTO objects... store in a changed_dtos list... then have a second loop that builds the table and if plotting, also plots the lines... so I want TWO loops\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/detects/breathing.py:\n            @dataclass(frozen=True)\n            class Changed:\n                index: int\n                time_seconds: float\n                before_value: float\n                after_value: float\n                delta_value: float\n\n            table = Table(show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"Index\", justify=\"right\")\n            table.add_column(\"Time\", justify=\"right\")\n            table.add_column(\"Before\", justify=\"right\")\n            table.add_column(\"After\", justify=\"right\")\n            table.add_column(\"Delta\", justify=\"right\")\n            for idx, time_val, before_val, after_val, delta_val in changed:\n                # PRN DTO \n                table.add_row(str(int(idx)), f\"{time_val:.3f}s\", f\"{before_val:.1f}\", f\"{after_val:.1f}\", f\"{delta_val:.1f}\")\n                if plotting and delta_val >= 2:\n                    # even my smoothed signs plot can be noisy (especially in long silences with flat periods that can flicker back and forth)...\n                    #   great example is minute7 in middle ish has typing period... lots of no sound areas that flicker back and forth... would also not detect any new minima anyways\n                    #   maybe add small rounding? as long as it still gets me close to my minima that's fine\n                    plt.gca().axvline(time_val)\n            rich.print(table)"
    }
  ],
  "model": "",
  "temperature": 1
}
