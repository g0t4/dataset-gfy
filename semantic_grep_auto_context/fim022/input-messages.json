{
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:2-22\ndef zero_crossing_indices(signal):\n    signs = np.sign(signal)  # -1, 0, +1\n\n    crossing_indices = []\n    previous_nonzero_sign = 0\n\n    for index, current_sign in enumerate(signs):\n        if current_sign == 0:\n            # skip 0s\n            continue\n\n        if previous_nonzero_sign == 0:\n            # set first nonzero value\n            previous_nonzero_sign = current_sign\n            continue\n\n        if current_sign != previous_nonzero_sign:\n            crossing_indices.append(index)  # crossing confirmed here\n            previous_nonzero_sign = current_sign\n\n    return np.asarray(crossing_indices)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:0-19\nimport numpy as np\n\ndef zero_crossing_indices(signal):\n    signs = np.sign(signal)  # -1, 0, +1\n\n    crossing_indices = []\n    previous_nonzero_sign = 0\n\n    for index, current_sign in enumerate(signs):\n        if current_sign == 0:\n            # skip 0s\n            continue\n\n        if previous_nonzero_sign == 0:\n            # set first nonzero value\n            previous_nonzero_sign = current_sign\n            continue\n\n        if current_sign != previous_nonzero_sign:\n            crossing_indices.append(index)  # crossing confirmed here\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:15-22\n            previous_nonzero_sign = current_sign\n            continue\n\n        if current_sign != previous_nonzero_sign:\n            crossing_indices.append(index)  # crossing confirmed here\n            previous_nonzero_sign = current_sign\n\n    return np.asarray(crossing_indices)\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:34-36\ndef test_back_to_back():\n    indices = zero_crossing_indices([0.01, -0.01, 0.02, -0.02, 0.03, -0.03, 0.04])\n    np.testing.assert_array_equal(indices, [1, 2, 3, 4, 5, 6])\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:4-12\nclass TestDirectCrossings:\n\n    def test_postive_to_negative(self):\n        indices = zero_crossing_indices([1, 0.5, -0.5, -1])\n        np.testing.assert_array_equal(indices, [2])\n\n    def test_negative_to_positive(self):\n        indices = zero_crossing_indices([-1, -0.5, 0.5, 1])\n        np.testing.assert_array_equal(indices, [2])\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport rich\nfrom dataclasses import dataclass\nfrom rich.console import Console\nfrom rich.table import Table\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult\nfrom auto_edit.new_silence.detects.breathing_state import plot, clear\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode_markup\n\nconsole = Console()\n\ndef plot_zero_line(win, shift):\n    start = win.gap.start_seconds()\n    end = win.gap.end_seconds()\n    x_s = [start, end]\n    y_s = [shift, shift]\n    plot(x_s, y_s, color=\"white\", linewidth=1)\n\ndef mark_breathing(analysis: AudioAnalysisResult, plotting: bool = True):\n    if plotting:\n        clear()\n\n    for win in analysis.windows:\n        win.breathing = None  # reset just in case was set elsewhere?\n\n        assert win.first_min and win.last_min\n\n        console.print(f\"gap: {seconds_to_timecode_markup(win.gap.start_seconds(), fps=analysis.fps)} => \"\n                      f\"{seconds_to_timecode_markup(win.gap.end_seconds(), fps=analysis.fps)}\", highlight=False)\n\n        gap_rms = analysis.rms_slice_for_gap(win)\n        rms_diff = gap_rms.diff()\n\n        lower_gate = -0.5\n        upper_gate = 0.5\n        rms_diff_gated = rms_diff.gate(lower=lower_gate, upper=upper_gate)\n\n        only_one_dip = win.first_min.seconds == win.last_min.seconds\n        if only_one_dip:\n            print(\"  REJECTED, only [red]one dip[/]\")\n            if plotting:\n                gap_rms.mark_rejected(\"reject, only one dip\")\n            continue\n\n        m2m_start = analysis.to_hops(win.first_min.seconds)\n        m2m_end = analysis.to_hops(win.last_min.seconds)\n        min2min_rms = analysis.rms_slice(m2m_start, m2m_end)\n\n        def analyze_rms_stride2():\n            # FYI step_by=3/4 was too high, precision slipped in timing\n            #    step_by=2 is PERFECT in my first example\n            rms_stride2 = gap_rms.stride(2)\n            diff_stride2 = rms_stride2.diff()\n            diff_stride2_gated = diff_stride2.gate(lower=lower_gate, upper=upper_gate)\n            crossing_indices = <|fim_middle|> \n\n            if plotting:\n                shift = shift__diff_STRIDE2  # hacky workaround to run without passing plot-time only arg\n                diff_stride2.plot(linewidth=1, color=\"darkorange\", shift=shift, label_end=f\"stride2 diff\")\n                plot_zero_line(win, shift=shift)\n                diff_stride2.plot_sign_and_smooth_sign(shift - 5, \"green\", f\"signs(stride2 diff)\")\n                diff_stride2_gated.plot(linewidth=1, color=\"orange\", shift=shift - 10, label_end=f\"stride2 diff_gated\")\n                diff_stride2_gated.plot_sign_and_smooth_sign(shift - 15, \"orange\", f\"signs(stride2 diff_gated)\")\n\n            # TODO - WIP:\n            # - diff_stride2_gated crosses zero => minima nearby\n            #   - negative to positive = increase (often ramp-up)\n            #   - positive to negative = decrease\n            #   gated should avoid noise (rapid flips when near zero slope)\n            # - THEN, LOOK AT THE SLOPE VALUE!\n            #   use diff_stride2_gated\n            #   - if it is nearly zero, ignore that point! (i.e. top of breathing hump)\n            #   - IF MATERIAL SLOPE... find minima!\n            #\n            diff_signs = diff_stride2.smooth().sign()\n            diff_sign_changes = diff_signs.diff()\n            changed_indices = np.nonzero(diff_sign_changes.values)[0]\n            changed_times = diff_sign_changes.times[changed_indices]\n            before = diff_signs.values[changed_indices]\n            after = diff_signs.values[changed_indices + 1]  # get next item's value\n            delta = diff_sign_changes.values[changed_indices]  # == after - before\n            changed = np.stack([changed_indices, changed_times, before, after, delta], axis=1)\n\n            @dataclass(frozen=True)\n            class Changed:\n                index: int\n                time_seconds: float\n                before_value: float\n                after_value: float\n                delta_value: float\n\n            changes: list[Changed] = []\n            for index, time, before, after, delta in changed:\n                changes.append(Changed(\n                    index=index,\n                    time_seconds=time,\n                    before_value=before,\n                    after_value=after,\n                    delta_value=delta,\n                ))\n\n            table = Table(show_header=True, header_style=\"bold magenta\")\n            table.add_column(\"Index\", justify=\"right\")\n            table.add_column(\"Time\", justify=\"right\")\n            table.add_column(\"Before\", justify=\"right\")\n            table.add_column(\"After\", justify=\"right\")\n            table.add_column(\"Delta\", justify=\"right\")\n            for dto in changes:\n                table.add_row(\n                    str(int(dto.index)),\n                    f\"{dto.time_seconds:.3f}s\",\n                    f\"{dto.before_value:.1f}\",\n                    f\"{dto.after_value:.1f}\",\n                    f\"{dto.delta_value:.1f}\",\n                )\n                if plotting and dto.delta_value >= 2:\n                    plt.gca().axvline(dto.time_seconds)\n            rich.print(table)\n\n        if plotting:\n            shift__diff1_gated = 35\n            shift__diff1_gated_signs = shift__diff1_gated - 5\n            shift__diff1 = shift__diff1_gated_signs - 10\n            shift__diff1_signs = shift__diff1 - 5\n            shift__diff_STRIDE2 = shift__diff1_signs - 8\n            #\n            rms_diff.plot(color=\"green\", linewidth=1, shift=shift__diff1, label_end=\"diff1\")\n            rms_diff_gated.plot(color=\"orange\", linewidth=1, shift=shift__diff1_gated, label_end=\"diff1_gated\")\n\n            rms_diff.plot_sign_and_smooth_sign(shift__diff1_signs, \"green\", \"signs(diff1)\")\n            rms_diff_gated.plot_sign_and_smooth_sign(shift__diff1_gated_signs, \"orange\", \"signs(diff1_gated)=orange - smoothed=black (on top of this)\")\n            plot_zero_line(win, shift=shift__diff1)\n\n        analyze_rms_stride2()\n\n        def inner_slope_has_spike() -> bool:\n            # ends of breathing can have small spikes, so exclude those\n            # - FYI probably could avoid this if I cut on spikes in slope\n            pad = int(0.02 * len(min2min_rms.values))\n            slope = np.diff(min2min_rms.values[pad:-pad])\n            max_slope = np.abs(slope).max()\n            min_slope = np.min(slope)\n            if max_slope > 3:\n                rich.print(f\"  [dark_orange]SLOPE SPIKE[/] in inner_diff: [dark_orange]{max_slope=:.2f}[/], {min_slope=:.2f}\")\n                if not try_new_split_on_spike_in_slope(analysis, win):\n                    if plotting:\n                        min2min_rms.mark_rejected(\"reject, slope spike\")\n                return True\n\n            return False\n\n        if inner_slope_has_spike():\n            continue\n\n        min_duration_seconds = win.last_min.seconds - win.first_min.seconds\n        if not (0.120 < min_duration_seconds):\n            # FYI no upper limit needed! I had a bug of 400s and never noticed problems so I just chopped that constraint\n            # IIAC too short == nothing much to learn about it from try_new_split_on_spike_in_slope approach, though I could use it nonetheless\n            print(\"  REJECTED [red]too short[/]\")\n            if plotting:",
      "role": "user"
    }
  ],
  "options": [],
  "max_tokens": 4096,
  "raw": false,
  "top_p": 1,
  "model": "gpt-oss:120b",
  "temperature": 1,
  "stream": true,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  }
}
