{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1766902532,
  "id": "chatcmpl-XwD1v6ywcHPHwm2glT1zJp5BkFbxWBVf",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 989,
    "prompt_n": 1171,
    "prompt_ms": 448.609,
    "prompt_per_token_ms": 0.3830990606319385,
    "prompt_per_second": 2610.2909214928814,
    "predicted_n": 187,
    "predicted_ms": 940.567,
    "predicted_per_token_ms": 5.029770053475936,
    "predicted_per_second": 198.8162459452649
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 0,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 187,
    "tokens_evaluated": 2160,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-28\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n\n\n<|end|><|start|>user<|message|>Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/detects/breathing.py:\n        plot(gap_hops[1:], signs - shift, color=\"orange\")\n\n.. yanked from auto_edit/new_silence/detects/breathing.py:\n        shift = 10\n\n.. yanked from auto_edit/new_silence/detects/breathing.py:\n        plot(gap_hops[1:], d - shift, color=\"orange\")\n\n.. yanked from auto_edit/new_silence/detects/breathing_state.py:\nkwargs[\"shift\"]\n\n\n.. yanked from auto_edit/new_silence/detects/breathing_state.py:\n    rich.inspect(kwargs)\n\n.. yanked from auto_edit/new_silence/detects/breathing_state.py:\n\ndef plot(\n    *args: float | ArrayLike | str,\n    scalex: bool = True,\n    scaley: bool = True,\n    data=None,\n    **kwargs,\n) -> list[Line2D]:\n    shift = None\n    rich.inspect(kwargs)\n    if hasattr(kwargs, \"shift\"):\n        shift = kwargs[\"shift\"]\n        kwargs[\"shift\"] = None\n        # del kwargs[\"shift\"]\n    rich.inspect(kwargs)\n    lines = plt.gca().plot(\n        *args,\n        scalex=scalex,\n        scaley=scaley,\n        **({\n            \"data\": data\n        } if data is not None else {}),\n        **kwargs,\n    )\n    # if shift:\n    #     for line in lines:\n    #         line.wes_shift = shift\n    # FYI alternative (mark lines w/ gid and then clean can lookup on gid)\n    #   [line.set_gid(\"foo\") for line in lines]\n    plotted_lines.extend(lines)\n    return lines\n\n.. yanked from auto_edit/new_silence/detects/breathing_state.py:\n    rich.inspect(kwargs)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nwes_shift\n\n.. yanked from auto_edit/new_silence/detects/breathing.py:\n, shift=shift)\n\n.. yanked from auto_edit/new_silence/detects/breathing.py:\n, shift=shift\n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:8-13\ndef plot_zero_line(win, shift):\n    start = win.gap.start_seconds()\n    end = win.gap.end_seconds()\n    x_s = [start, end]\n    y_s = [-shift, -shift]\n    plot(x_s, y_s, color=\"white\", linewidth=1)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/learn.py:4-18\ndef rms_window(y, index, frame_len):\n    half_frame_len = frame_len // 2  # subtract 1 for the center value\n    before_count = half_frame_len\n    len_y = len(y)\n    start_at_inclusive = index - before_count\n    thru_exclusive = start_at_inclusive + frame_len\n    print(f'{start_at_inclusive=} {index=} {thru_exclusive=}')\n    min_index = max(0, start_at_inclusive)\n    max_index = min(len_y, thru_exclusive)\n    # print(f'{index=} {min_index=} {max_index=}')\n    window = y[min_index:max_index]\n    mean_of_squares = np.array((window**2).sum()) / float(frame_len)\n    # zero padded == divide by frame_len even when not frame_len items (at ends)\n    result = np.sqrt(mean_of_squares)\n    return result\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:243-248\ndef key_down_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] - shift, cur_ylim[1] - shift)\n        plotter.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:236-241\ndef key_up_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] + shift, cur_ylim[1] + shift)\n        plotter.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/gaps_tests.py:363-381\ndef test__spike_before__first_min__flat_after__picks_frame_after(self):\n        analysis = compute_speech_boundaries( \\\n            left_speech = ONE_SECOND_at_MINUS20(),\n            gap = start(-20)\n                .add(np.array([-20])) # TODO helper?\n                .down(1) # 2 hops  (30/31 frames around\n                .up(1) # 2 hops  (30/31 frames around\n                .flat(40),\n                # .plot(),\n            right_speech=ONE_SECOND_at_MINUS20(),\n        )\n        window = analysis.windows[0]\n\n        assert window.first_min\n        assert window.first_min.seconds == pytest.approx(1.0 + 2 / 882)\n        assert window.first_min._testing_frame_before == 30\n        assert window.first_min._testing_frame_after == 31\n\n        assert window.first_min.frame_aligned_at_seconds == pytest.approx(31 / 30)\n<|end|><|start|>user<|message|>Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nfrom ctypes import ArgumentError\nfrom matplotlib.lines import Line2D\nimport matplotlib.pyplot as plt\nfrom numpy.typing import ArrayLike\nimport rich\n\n# separate module so autoreload doesn't wipe my list of lines that I want to later wipe\n# it is WAY faster to just re-run breathing analysis in breathing.py and have changes applied than re-run full analysis and plots\nplotted_lines = []\n\ndef clear():\n    for line in plotted_lines:\n        line.remove()\n    plotted_lines.clear()\n\ndef plot(\n    *args: float | ArrayLike | str,\n    scalex: bool = True,\n    scaley: bool = True,\n    data=None,\n    **kwargs,\n) -> list[Line2D]:\n    shift = kwargs.pop(\"shift\", None)\n\n    if len(args) != 2:\n        raise ArgumentError(f\"expected two positional args for x_s and y_s respectively, but only got {len(args)} args\")\n\n    x_s, y_s = args\n    # if len(x_s) != len(y_s):\n    #     raise ArgumentError(\"x and y sequences must have the same length\")\n    y_s = <|fim_middle|>\n\n    lines = plt.gca().plot(\n        x_s,\n        y_s,\n        scalex=scalex,\n        scaley=scaley,\n        **({\n            \"data\": data\n        } if data is not None else {}),\n        **kwargs,\n    )\n    if shift:\n        for line in lines:\n            line.wes_shift = shift\n    # FYI alternative (mark lines w/ gid and then clean can lookup on gid)\n    #   [line.set_gid(\"foo\") for line in lines]\n    plotted_lines.extend(lines)\n    return lines<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 2346,
    "timings": {
      "cache_n": 989,
      "prompt_n": 1171,
      "prompt_ms": 448.609,
      "prompt_per_token_ms": 0.3830990606319385,
      "prompt_per_second": 2610.2909214928814,
      "predicted_n": 187,
      "predicted_ms": 940.567,
      "predicted_per_token_ms": 5.029770053475936,
      "predicted_per_second": 198.8162459452649
    }
  }
}
