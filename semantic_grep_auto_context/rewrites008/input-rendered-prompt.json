{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1767051726,
  "id": "chatcmpl-RiPebgNRYWysOV090Emcry8DlNr9MUwa",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 0,
    "prompt_n": 6073,
    "prompt_ms": 795.059,
    "prompt_per_token_ms": 0.13091700971513254,
    "prompt_per_second": 7638.426833731837,
    "predicted_n": 205,
    "predicted_ms": 1010.044,
    "predicted_per_token_ms": 4.927043902439024,
    "predicted_per_second": 202.96145514452834
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 3,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 205,
    "tokens_evaluated": 6073,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-29\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. \n\n<|end|><|start|>user<|message|>## Recent yanks across all files in the project:\n.. yanked from .venv/lib/python3.12/site-packages/matplotlib/widgets.py:\nclass Cursor(AxesWidget):\n    \"\"\"\n    A crosshair cursor that spans the Axes and moves with mouse cursor.\n\n    For the cursor to remain responsive you must keep a reference to it.\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The `~.axes.Axes` to attach the cursor to.\n    horizOn : bool, default: True\n        Whether to draw the horizontal line.\n    vertOn : bool, default: True\n        Whether to draw the vertical line.\n    useblit : bool, default: False\n        Use blitting for faster drawing if supported by the backend.\n        See the tutorial :ref:`blitting` for details.\n\n    Other Parameters\n    ----------------\n    **lineprops\n        `.Line2D` properties that control the appearance of the lines.\n        See also `~.Axes.axhline`.\n\n    Examples\n    --------\n    See :doc:`/gallery/widgets/cursor`.\n    \"\"\"\n    def __init__(self, ax, *, horizOn=True, vertOn=True, useblit=False,\n                 **lineprops):\n        super().__init__(ax)\n\n        self.connect_event('motion_notify_event', self.onmove)\n        self.connect_event('draw_event', self.clear)\n\n        self.visible = True\n        self.horizOn = horizOn\n        self.vertOn = vertOn\n        self.useblit = useblit and self.canvas.supports_blit\n\n        if self.useblit:\n            lineprops['animated'] = True\n        self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)\n        self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)\n\n        self.background = None\n        self.needclear = False\n\n    def clear(self, event):\n        \"\"\"Internal event handler to clear the cursor.\"\"\"\n        if self.ignore(event) or self.canvas.is_saving():\n            return\n        if self.useblit:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n\n    def onmove(self, event):\n        \"\"\"Internal event handler to draw the cursor when the mouse moves.\"\"\"\n        if self.ignore(event):\n            return\n        if not self.canvas.widgetlock.available(self):\n            return\n        if not self.ax.contains(event)[0]:\n            self.linev.set_visible(False)\n            self.lineh.set_visible(False)\n            if self.needclear:\n                self.canvas.draw()\n                self.needclear = False\n            return\n        self.needclear = True\n        xdata, ydata = self._get_data_coords(event)\n        self.linev.set_xdata((xdata, xdata))\n        self.linev.set_visible(self.visible and self.vertOn)\n        self.lineh.set_ydata((ydata, ydata))\n        self.lineh.set_visible(self.visible and self.horizOn)\n        if not (self.visible and (self.vertOn or self.horizOn)):\n            return\n        # Redraw.\n        if self.useblit:\n            if self.background is not None:\n                self.canvas.restore_region(self.background)\n            self.ax.draw_artist(self.linev)\n            self.ax.draw_artist(self.lineh)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            self.canvas.draw_idle()\n\n.. yanked from .venv/lib/python3.12/site-packages/matplotlib/widgets.py:\nCursor\n\n.. yanked from .venv/lib/python3.12/site-packages/matplotlib/widgets.py:\nclass Cursor(AxesWidget):\n    \"\"\"\n    A crosshair cursor that spans the Axes and moves with mouse cursor.\n\n    For the cursor to remain responsive you must keep a reference to it.\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        The `~.axes.Axes` to attach the cursor to.\n    horizOn : bool, default: True\n        Whether to draw the horizontal line.\n    vertOn : bool, default: True\n        Whether to draw the vertical line.\n    useblit : bool, default: False\n        Use blitting for faster drawing if supported by the backend.\n        See the tutorial :ref:`blitting` for details.\n\n    Other Parameters\n    ----------------\n    **lineprops\n        `.Line2D` properties that control the appearance of the lines.\n        See also `~.Axes.axhline`.\n\n    Examples\n    --------\n    See :doc:`/gallery/widgets/cursor`.\n    \"\"\"\n    def __init__(self, ax, *, horizOn=True, vertOn=True, useblit=False,\n                 **lineprops):\n        super().__init__(ax)\n\n        self.connect_event('motion_notify_event', self.onmove)\n        self.connect_event('draw_event', self.clear)\n\n        self.visible = True\n        self.horizOn = horizOn\n        self.vertOn = vertOn\n        self.useblit = useblit and self.canvas.supports_blit\n\n        if self.useblit:\n            lineprops['animated'] = True\n        self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)\n        self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)\n\n        self.background = None\n        self.needclear = False\n\n    def clear(self, event):\n        \"\"\"Internal event handler to clear the cursor.\"\"\"\n        if self.ignore(event) or self.canvas.is_saving():\n            return\n        if self.useblit:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n\n    def onmove(self, event):\n        \"\"\"Internal event handler to draw the cursor when the mouse moves.\"\"\"\n        if self.ignore(event):\n            return\n        if not self.canvas.widgetlock.available(self):\n            return\n        if not self.ax.contains(event)[0]:\n            self.linev.set_visible(False)\n            self.lineh.set_visible(False)\n            if self.needclear:\n                self.canvas.draw()\n                self.needclear = False\n            return\n        self.needclear = True\n        xdata, ydata = self._get_data_coords(event)\n        self.linev.set_xdata((xdata, xdata))\n        self.linev.set_visible(self.visible and self.vertOn)\n        self.lineh.set_ydata((ydata, ydata))\n        self.lineh.set_visible(self.visible and self.horizOn)\n        if not (self.visible and (self.vertOn or self.horizOn)):\n            return\n        # Redraw.\n        if self.useblit:\n            if self.background is not None:\n                self.canvas.restore_region(self.background)\n            self.ax.draw_artist(self.linev)\n            self.ax.draw_artist(self.lineh)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            self.canvas.draw_idle()\n\n\n.. yanked from auto_edit/new_silence/player/crosshairs.py:\n\n\n\n<|end|><|start|>user<|message|>## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n<|end|><|start|>user<|message|>## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n<|end|><|start|>user<|message|># Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:182-192\ndef toggle_crosshair(self) -> None:\n        if hasattr(self, \"_cursor\"):\n            # PRN is this ok for removing?\n            self._cursor.disconnect_events()\n            self._cursor.linev.set_visible(False)\n            self._cursor.lineh.set_visible(False)\n            self.fig.canvas.draw_idle()\n        else:\n            # first toggle on == create\n            # do not use blit (faster yes, but doesn't play well with other redraws and I don't care to figure a way to make it work better)\n            self._cursor = Cursor(self.ax, useblit=False, color=\"black\", linewidth=1)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:0-16\nimport math\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport rich\nimport sounddevice as sd\nimport time\nfrom dataclasses import dataclass\nfrom matplotlib.text import Annotation, Text\nfrom matplotlib.lines import Line2D\nfrom matplotlib.widgets import Cursor\nfrom auto_edit.new_silence.player.clipper import clip_full_window\nfrom auto_edit.new_silence.player.plot_helpers import is_alt, is_ctrl, is_shift, setup_events\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, GapWindow, DetectedSegment, SegmentLabel\nfrom auto_edit.new_silence.player.prompter import applescript_prompt\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:0-12\nfrom pathlib import Path\nimport subprocess\nimport rich\nimport sounddevice as sd\nfrom matplotlib.axes import Axes\nfrom matplotlib.backend_bases import CloseEvent, KeyEvent, MouseEvent\nfrom matplotlib.collections import PathCollection\nfrom matplotlib.figure import Figure\nfrom matplotlib.lines import Line2D\n\nfrom auto_edit.new_silence.detect import AnalysisParams, create_analysis\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:24-393\ndef setup_events(plotter: \"SegmentPlotter\"):\n\n    def on_close(event: CloseEvent):\n        subprocess.run([\n            \"osascript\",\n            \"-e\",\n            'tell application \"iTerm\" to activate',\n        ])\n\n    def on_key(event: KeyEvent):\n        # rich.inspect(event) # cool way to see all the event details!\n        # existing navigation\n        if event.key == \"left\":\n            key_left(event)\n        elif event.key == \"right\":\n            key_right(event)\n        elif event.key == \"home\":\n            go_to_start(event)\n        elif event.key == \"end\":\n            go_to_end(event)\n        if event.key == \"escape\":\n            sd.stop()\n        elif event.key == \"shift+up\":\n            increase_frame_len(event)\n        elif event.key == \"shift+down\":\n            decrease_frame_len(event)\n        elif event.key == \"cmd+=\":\n            # match FCPX zoom keymap (albeit that one is not fixed)\n            cycle_fixed_zoom(event, up=True)\n        elif event.key == \"cmd+-\":\n            # match FCPX zoom keymap (albeit that one is not fixed)\n            cycle_fixed_zoom(event, up=False)\n        elif event.key == \"t\":\n            # DO NOT USE a key that is already mapped.. it will trigger it still!\n            #   NOT: f, g, l\n            toggle_gridlines(event)\n        elif event.key == \"y\":\n            # copy start/end of the gap under the cursor to clipboard\n            copy_gap_timing_for_notes(event)\n        elif event.key == \"h\":\n            print(\"FUCKFUCK FUCK\")\n            plotter.toggle_crosshair()\n            print(\"SHIT\")\n        elif event.key in (\"+\", \"=\", \"-\", \"_\"):\n            zoom_x_only(event)\n        # paging left/right (full page width)\n        elif event.key in (\"ctrl+u\", \"ctrl+d\", \"ctrl+b\", \"ctrl+f\", \"pageup\", \"pagedown\"):\n            # vim style: ctrl+b/f = left/right full page, ctrl+u/d = half page, pageup/pagedown = full page left/right\n            if event.key in (\"ctrl+b\", \"pageup\"):\n                page_left(event)\n            elif event.key in (\"ctrl+f\", \"pagedown\"):\n                page_right(event)\n            elif event.key == \"ctrl+u\":\n                half_page_left(event)\n            elif event.key == \"ctrl+d\":\n                half_page_right(event)\n\n    def go_to_start(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start_time = plotter.segments[0].start_seconds\n        plotter.ax.set_xlim(start_time, width)\n        plotter.fig.canvas.draw_idle()\n\n    def go_to_end(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        end_time = plotter.segments[-1].end_seconds\n        plotter.ax.set_xlim(end_time - width, end_time)\n        plotter.fig.canvas.draw_idle()\n\n    def toggle_gridlines(event: KeyEvent):\n        # FYI gridlines are initially OFF...\n        # toggle them ON when I need to see nearest frame (minor ticks)\n        # btw gridlines are associated with ticks, thus need to check tick params\n        #   every other API above axis.get/set_tick_params is just a wrapper around this lower level set_tick_params function\n\n        # * check if on/off... PITA with separate values per major/minor, so I will assume it is off and turnit on first time using visible_grid\n        # x_minor_grid_on = ax.xaxis.get_tick_params(which=\"minor\")[\"gridOn\"]\n        # x_major_grid_on = ax.xaxis.get_tick_params(which=\"major\")[\"gridOn\"]\n        # print(f'{x_major_grid_on=} {x_minor_grid_on=}')\n\n        # * set style first\n        plotter.ax.xaxis.grid(which='minor', linewidth=1)\n        plotter.ax.xaxis.grid(which='major', linewidth=1, color='black')\n        # arguably, I could set this once w/ ax.tick_params (or otherwise)\n        #   but, I want to keep all of this self-contained in this function\n        # kwargs: linewidth, linestyle, color, alpha (see ax.tick_params docs)\n        #   FYI grid(linewidth=X) == set_tick_params(grid_linewidth=X)\n        #   the same kwarg is named different based on function ðŸ¤¦â€â™‚ï¸\n        #\n        # * set on/off\n        global visible_grid\n        visible_grid = not visible_grid\n        plotter.ax.xaxis.grid(visible=visible_grid, which='both')  # then, set visibility\n        # FTR which='both' == both 'major' and 'minor'\n        # !!! DO NOT PASS both visible and kwargs\n        # !!! ... unless you like SURPRISE, RAWDOG, BUTT SECKS in your penis hole\n        #   so, NOT THIS:\n        #     ax.xaxis.grid(visible_grid, which='both', linewidth=2)\n        # passing any `kwargs` => sets `visible=True` (always)\n        #   just F12 into .grid() and you'll see!\n        #   kwargs are where you pass characteristics like linewidth\n        # btw... `which` is a positional arg so you can pass it (and should)\n\n        plotter.fig.canvas.draw_idle()\n\n    def key_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        shift = (cur_xlim[1] - cur_xlim[0]) * 0.1\n        plotter.ax.set_xlim(cur_xlim[0] - shift, cur_xlim[1] - shift)\n        plotter.fig.canvas.draw_idle()\n\n    def key_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        shift = (cur_xlim[1] - cur_xlim[0]) * 0.1\n        plotter.ax.set_xlim(cur_xlim[0] + shift, cur_xlim[1] + shift)\n        plotter.fig.canvas.draw_idle()\n\n    def clamp_xlim(new_start: float, new_end: float) -> tuple[float, float]:\n        \"\"\"Clamp the new x limits to the data bounds.\n        Returns a tuple (start, end) respecting the overall segment range.\n        \"\"\"\n        data_start = plotter.segments[0].start_seconds\n        data_end = plotter.segments[-1].end_seconds\n        # ensure we don't exceed bounds\n        if new_start < data_start:\n            new_start = data_start\n            new_end = data_start + (new_end - new_start)\n        if new_end > data_end:\n            new_end = data_end\n            new_start = data_end - (new_end - new_start)\n        return new_start, new_end\n\n    def page_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start, end = clamp_xlim(cur_xlim[0] - width, cur_xlim[1] - width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def page_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start, end = clamp_xlim(cur_xlim[0] + width, cur_xlim[1] + width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def half_page_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = (cur_xlim[1] - cur_xlim[0]) / 2\n        start, end = clamp_xlim(cur_xlim[0] - width, cur_xlim[1] - width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def half_page_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = (cur_xlim[1] - cur_xlim[0]) / 2\n        start, end = clamp_xlim(cur_xlim[0] + width, cur_xlim[1] + width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def on_scroll(event: MouseEvent):\n        if event.inaxes != plotter.ax:\n            return\n        base_scale = 0.9\n        cur_xlim = plotter.ax.get_xlim()\n        xdata = event.xdata\n        if event.button == 'up':\n            scale_factor = base_scale\n        elif event.button == 'down':\n            scale_factor = 1 / base_scale\n        else:\n            scale_factor = 1\n        new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor\n        relx = (xdata - cur_xlim[0]) / (cur_xlim[1] - cur_xlim[0])\n        plotter.ax.set_xlim(xdata - new_width * relx, xdata + new_width * (1 - relx))\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()\n\n    def decrease_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length // 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def increase_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length * 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def redo_analysis_with(params: AnalysisParams):\n        old_analysis = plotter.analysis\n        new_analysis = create_analysis(old_analysis.audio, params)\n        new_analysis.path = old_analysis.path\n\n        # * setup data for new plot (as if call SegmentPlotter() again)\n        # PRN look at ctor for overlap to refactor?\n        plotter.analysis = new_analysis\n        plotter.segments = new_analysis.merged_segments\n        plotter.windows = new_analysis.windows\n        plotter.aligned_markers = []\n        plotter.arrows = []\n\n        # * capture current plot state\n        old_xlim = plotter.ax.get_xlim()\n        old_ylim = plotter.ax.get_ylim()\n\n        # * clear actual plot elements\n        plotter.ax.cla()\n        # * draw new elements\n        plotter._setup_plot()\n\n        # * restore zoom/pan\n        plotter.ax.set_xlim(old_xlim)\n        plotter.ax.set_ylim(old_ylim)\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()\n\n    def key_up_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] + shift, cur_ylim[1] + shift)\n        plotter.fig.canvas.draw_idle()\n\n    def key_down_shift_y(event: KeyEvent):\n        # old logic, might want to bring this back and move the frame_len shift to smth else\n        cur_ylim = plotter.ax.get_ylim()\n        shift = (cur_ylim[1] - cur_ylim[0]) * 0.1\n        plotter.ax.set_ylim(cur_ylim[0] - shift, cur_ylim[1] - shift)\n        plotter.fig.canvas.draw_idle()\n\n    def cycle_fixed_zoom(event: KeyEvent, up: bool = True):\n        FIXED_ZOOM_LEVELS_SECONDS = [2, 10, 60]\n        cur_xlim = plotter.ax.get_xlim()\n        cur_width = cur_xlim[1] - cur_xlim[0]\n        try:\n            current_index = next( \\\n                i\n                for i, lvl in enumerate(FIXED_ZOOM_LEVELS_SECONDS)\n                if abs(lvl - cur_width) < 0.1 * lvl\n            )\n        except StopIteration:\n            current_index = -1\n        step = 1 if up else -1\n        next_index = (current_index + step) % len(FIXED_ZOOM_LEVELS_SECONDS)\n        new_width = FIXED_ZOOM_LEVELS_SECONDS[next_index]\n        plotter.centered_zoom_to(new_width)\n\n    def zoom_x_only(event: KeyEvent):\n        # FYI shift variant of keys is for faster zoom (hence 0.5)\n        match event.key:\n            case \"=\":\n                zoom_factor = 0.8\n            case \"+\":\n                zoom_factor = 0.5\n            case \"-\":\n                zoom_factor = 1 / 0.8\n            case \"_\":\n                zoom_factor = 1 / 0.5\n            case _:\n                return\n\n        cur_xlim = plotter.ax.get_xlim()\n        new_width_seconds = (cur_xlim[1] - cur_xlim[0]) * zoom_factor\n        plotter.centered_zoom_to(new_width_seconds)\n\n    def on_motion_notify_event(event: MouseEvent):\n        toolbar = event.canvas.manager.toolbar\n        if not hasattr(toolbar, \"set_message\"):\n            # cannot set message, so why bother!\n            return\n\n        messages = []\n        if event.inaxes is None:\n\n            # outside of figure\n            # default to coordinates so I can see time / values\n            x = event.x\n            y = event.y\n            messages = [f\"{x=},{y=}\"]\n\n        else:\n\n            for artist in event.inaxes.get_children():\n                # PathCollection = ax.scatter()\n                # Line2D = ax.plot()\n                if isinstance(artist, (Line2D, PathCollection)):\n                    if not hasattr(artist, \"_orig_style\"):\n                        if isinstance(artist, Line2D):\n                            artist._orig_style = (artist.get_color(), artist.get_linewidth())\n                        else:\n                            artist._orig_style = (artist.get_facecolor(), artist.get_linewidth())\n                    is_under_mouse, _ = artist.contains(event)\n                    if is_under_mouse:\n                        if plotter._cursor.lineh == artist or plotter._cursor.linev == artist:\n                            continue\n                        artist.set_linewidth(2)\n                        artist.set_color(\"red\")\n                        label: str = artist.get_label()\n                        if label.startswith(\"_child\"):\n                            # FYI this is not mission critical, can nuke if causing problems\n                            #  only to show closest x/y of a line w/ shift factored in\n                            x_data, y_data = artist.get_data()\n                            mouse_x = event.xdata\n                            if x_data is not None and y_data is not None and mouse_x is not None:\n                                closest_index = int(abs(x_data - mouse_x).argmin())\n                                closest_x = float(x_data[closest_index])\n                                closest_y = float(y_data[closest_index])\n                                if hasattr(artist, \"wes_shift\"):\n                                    wes_shift = getattr(artist, \"wes_shift\")\n                                    closest_y = closest_y - wes_shift\n                                    messages.append(f\"({closest_x=:.4f},{closest_y=:.4f},shift={wes_shift})\")\n                                else:\n                                    messages.append(f\"({closest_x=:.4f},{closest_y=:.4f})\")\n                        messages.append(label)\n                    else:\n                        orig_color, orig_linewidth = artist._orig_style\n                        artist.set_linewidth(orig_linewidth)\n                        if isinstance(artist, Line2D):\n                            artist.set_color(orig_color)\n                        else:\n                            artist.set_facecolor(orig_color)\n\n            if event.xdata is not None and event.ydata is not None:\n                # show mouse coords too (so I can see where I am w/in a segment... and if no segment under mouse then show the position in time/dB)\n                seconds = seconds_to_timecode(event.xdata, plotter.analysis.fps)\n                db_value = event.ydata\n                messages += [f\"cursor@{seconds},{db_value=:.2f}\"]\n\n        toolbar.set_message(\", \".join(messages))\n\n        event.canvas.draw_idle()\n\n    plotter.fig.canvas.mpl_connect('scroll_event', on_scroll)\n    plotter.fig.canvas.mpl_connect(\"motion_notify_event\", on_motion_notify_event)\n    plotter.fig.canvas.mpl_connect(\"key_press_event\", on_key)\n    plotter.fig.canvas.mpl_connect(\"button_press_event\", plotter._on_click)\n    plotter.fig.canvas.mpl_connect(\"close_event\", on_close)\n\n    # initial setup of dynamic aspects:\n    plotter.toggle_zoom_level_elements()\n\n    def copy_gap_timing_for_notes(event: KeyEvent):\n        # Bail if mouse is not over the axes\n        if event.inaxes != plotter.ax or event.xdata is None:\n            return\n\n        toolbar = plotter.fig.canvas.manager.toolbar\n        x = event.xdata\n\n        for win in plotter.windows:\n            start = win.gap.start_seconds()\n            end = win.gap.end_seconds()\n            if start <= x <= end:\n                path: Path = plotter.analysis.path\n                filename = path.stem\n\n                txt = f\"{filename}@gap{start:.2f}s-{end:.2f}s\"\n\n                # I have pbcopy aliased on all platforms to a local copy method\n                subprocess.run(['pbcopy'], input=txt.encode())\n\n                # visual feedback\n                toolbar.set_message(f\"Copied: {txt}\")\n                return\n\n        toolbar.set_message(\"mouse is not over a NonSpeechGap, nothing to copy\")\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:20-26\n\n\nvisible_grid = False\n\ndef setup_events(plotter: \"SegmentPlotter\"):\n\n    \n<|end|><|start|>user<|message|>make a new subclass of Cursor from matplotlib... that has a toggle method that toggles it \"on\"/\"off\"\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/crosshairs.py:\n\n<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 6277,
    "timings": {
      "cache_n": 0,
      "prompt_n": 6073,
      "prompt_ms": 795.059,
      "prompt_per_token_ms": 0.13091700971513254,
      "prompt_per_second": 7638.426833731837,
      "predicted_n": 205,
      "predicted_ms": 1010.044,
      "predicted_per_token_ms": 4.927043902439024,
      "predicted_per_second": 202.96145514452834
    }
  }
}
