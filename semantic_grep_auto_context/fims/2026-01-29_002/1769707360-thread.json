{
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"gap_rms, win, analysis, plotter",
    "reasoning_content":"We need to fill arguments: compute_crossovers(gap_rms, win, analysis, plotter?) In this context, we have gap_rms defined earlier, win, analysis, plotter variable maybe. So replace with `gap_rms, win, analysis, plotter` but plotter may be None; it's fine. So code: `gap_rms, win, analysis, plotter`."
  },
  "last_sse":{
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "created":1769707360,
    "timings":{
      "cache_n":0,
      "prompt_n":4444,
      "prompt_ms":567.466,
      "prompt_per_token_ms":0.12769261926193,
      "predicted_ms":640.136,
      "predicted_per_token_ms":6.2758431372549,
      "predicted_per_second":159.34114000775,
      "predicted_n":102,
      "prompt_per_second":7831.3061927939
    },
    "system_fingerprint":"b7785-1c7cf94b2",
    "id":"chatcmpl-NTDM5SM3yxE5UfJMoZ0gMZKjXj0cQznE",
    "choices":[{
        "finish_reason":"stop",
        "index":0,
        "delta":[]
      }]
  },
  "request_body":{
    "raw":false,
    "model":"gpt-oss:120b",
    "top_p":1,
    "temperature":1,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:29-31\n    @property\n    def crosses(self):\n        return self.win.gap.crossovers\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:73-92\n       - padded = taper... so I had no way to decide when to consider taper vs not\n       - I always used 1 frame of taper (IIRC) though at times I tried more or less\n       - *** thus I often cut into breathing hump which sounds terrible (click)\n    - so just having better detection of the edit point (which taper does) gives a massive win even if I do nothing else\n    \"\"\"\n    crosses, note, reject, win, gap = c.crosses, c.note, c.reject, c.win, c.win.gap\n\n    if win.left_speech is None:\n        return reject(\"no left_speech to taper\")\n\n    only_one_cp = len(crosses) == 1\n    if only_one_cp:\n        # effectively, the entire gap is treated as taper\n        win.gap.left_taper_end = crosses[0].critical_point\n        win.gap.right_taper_start = crosses[0].critical_point\n        # TODO I should check for missing critical points (i.e. drop gate hreshold and rerun crossovers just for this gap)...\n        return note(\"one crossover = speech\")\n\n    def step1_mark_taper_to_first_and_last_critical_points():\n        # * Step 1 - sub-segment before/after first/last CPs is always taper\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:386-399\n        #      mirror on way out\n        win43s = analysis7().windows[15]\n        assert win43s.gap.crossovers\n        # assert not win43s.breathing # TODO GET WORKING BY REJECTING 3 MINIMA with this little duration within a given subset (between minima)\n        only_single_breathing_hump(win43s, 43.69, 43.83)\n\n        # * typing fingers waveform\n        win46s = analysis7().windows[16]\n        assert not win46s.breathing\n        # min0:46.3167s -47.2853dB | max1:46.3505s -39.1514dB | min2:46.6266s -94.3020dB | max3:47.1578s -75.2083dB | min4:47.2547s -92.1545dB | max5:47.2995s -64.9374dB\n        # | min6:47.3948s -86.9671dB | max7:47.4391s -70.0614dB | min8:47.4510s -73.0575dB | max9:47.4568s -71.3409dB | min10:47.5854s -92.4671dB | max11:47.6906s -69.5855dB\n        # | min12:47.9583s -94.3020dB | max13:48.0708s -60.1251dB | min14:48.0849s -65.0497dB | max15:48.1755s -43.5629dB | min16:48.5620s -78.9731dB\n\n    \n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:112-114\ndef build_crossovers(diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n    # TOD rename series as stride2 diff so it is clear\n    return [CrossoverData(cross, diff_stride2_gated, analysis) for cross in zero_crossings(diff_stride2_gated.values)]\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/moot.py:32-94\ndef get_material_crossovers(crossovers):\n\n    # FYI this might be a better solution than using gated diff...\n    #\n    #   TODO after you have good test coverage of all gap scenarios, drop gated and see if this removes noise and keeps tests passing\n    #      WHY? b/c gated sometimes results in missing critical points that are big dB moves!\n    #      also, judging moot might not work well if only one of the pair come through!\n    #        could easily miss detecting 1+ moots this way!\n    #        thus leaving an inconsequential min/max, which would then screw up detecting key scenarios\n    #\n    #   `gate()` was only added for cases where `diff` is close to zero\n    #     and `diff` wiggles back and forth over x-axis (y=0)\n    #     most of the time the wiggle was not violent, thus gated diff nuked it\n    #   stop using gated crossovers\n    #   instead take all crossovers, then remove moot ones!\n\n    # inherently about removing items - hence start w/ a copy of the list\n    filtered = crossovers.copy()\n\n    # moot_in_a_row = []\n    for current, next in pairwise(crossovers):\n        # FYI only rework for repeated moots if threshold needs raised for db_diff and this triggers in alot of cases!\n        #    IDEA: in a row... odd => remove all cps, even => remove all but min/max\n        if not is_moot(current, next):\n            # nothing to do, leave in filtered\n            # remove items for moot streak\n            # moot_in_a_row = [] # reset\n            continue\n\n        if current in filtered:\n            filtered.remove(current)\n        if next in filtered:\n            filtered.remove(next)\n        # FYI must still visit `next` next b/c it may be moot w.r.t. its next too\n        #   i.e. 3 back-to-back moots\n        #   also why don't have to visit the last item! it has no \"next\" to compare\n        #     whereas its previous would remove it already if it prev was moot w.r.t.\n    # remove items for moot streak (if ended w/ moot streak) - very low chances\n\n    def print_crossovers(crossovers: list[CrossoverData], filtered: list[CrossoverData]) -> None:\n        if len(filtered) == len(crossovers):\n            return\n\n        rich.print(\"[bold yellow]  Reduced crossovers[/]\")\n        previous: CrossoverData = None\n        for cross in crossovers:\n            label = cross.min_max_label()\n            time_sec = cross.cp.time.seconds\n            rms = cross.cp.rms\n            diff_info = \"\"\n            if previous is not None:\n                db_diff = rms - previous.cp.rms\n                time_diff_hops = cross.cp.time.hops - previous.cp.time.hops\n                diff_info = f\" {time_diff_hops:.0f}hops {db_diff:.2f}dB\"\n            if cross in filtered:\n                rich.print(f\"    [bold]{label} {time_sec:.3f}s {rms:.2f}dB{diff_info}[/bold]\")\n            else:\n                rich.print(f\"    [bold yellow]{label} {time_sec:.3f}s {rms:.2f}dB{diff_info} moot[/bold yellow]\")\n            previous = cross\n\n    print_crossovers(crossovers, filtered)\n\n    return Crossovers(filtered)\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/detects/breathing.py\n        seconds = win.gap.right_taper_start.time.seconds\n        rms = analysis.rms_db[analysis.to_hops(seconds)]\n        plotter.ax.annotate(\n            \"\",\n            xy=(seconds, rms),\n            xytext=(seconds + x_offset, rms - y_offset),\n            arrowprops=dict(arrowstyle=\"->\", color=\"magenta\", lw=1.5),\n        )\n        plotter.ax.axvspan(\n            xmin=seconds,\n            xmax=win.gap.end_seconds(),\n            alpha=0.2,\n        )\n\ndef plot_crossover_min_and_max(cross: CrossoverData, y_middle: float, plotter: SegmentPlotter, win: GapWindow) -> None:\n    if cross.is_local_min():\n        artist = plotter.ax.scatter(\n            cross.min.time.seconds,\n            cross.min.rms,\n            color=\"yellow\",\n            edgecolor=\"black\",\n            zorder=5,\n            picker=5,\n        )\n        # metadata for pick handler:\n        artist.cross = cross\n        artist.win = win\n    if cross.is_local_max():\n        artist = plotter.ax.scatter(\n            cross.max.time.seconds,\n            cross.max.rms,\n            color=\"cyan\",\n            edgecolor=\"black\",\n            zorder=5,\n            picker=5,\n        )\n        artist.cross = cross\n        artist.win = win\n\ndef compute_crossovers(gap_rms: TimeSeries, win: GapWindow, analysis: AudioAnalysisResult, plotter: SegmentPlotter | None = None) -> Crossovers:\n\n    # why I chose stride2 (diff across two hops)\n    # - stride1 diff (every hop)\n    #   - smaller diff values (waters down spikes by spreading them out due to higher sampling rate)\n    #   - noisier than stride2\n    # - *** stride2 diff has been STELLAR for decision logic!!!\n    #   - even dropping gate threshold to 0.2 works... it flags smaller/gradual humps (that currently I don't need)\n    # - stride3/4+ lower sampling rate leads to timing slippage\n    #    begins to produce inflated diff values, for my purposes, causing issues with gating too (IIRC)\n    rms_stride2 = gap_rms.stride(2)\n    diff_stride2 = rms_stride2.diff()\n    diff_stride2_gated = diff_stride2.gate()\n\n    # * y limits\n    if plotter:\n        stack_offset = StackedPlotOffset(-2)\n        keep_bottom = plotter.get_y_limits().bottom\n        plotter.ax.set_ylim(bottom=keep_bottom, top=stack_offset.initial_offset)\n        #\n        line_args = {\"color\": \"darkorange\", \"alpha\": 0.7}\n        #\n        diff_stride2.plot(linewidth=1, **line_args, shift=stack_offset.reserve(-7), label_end=f\"stride2 diff\")\n        plot_zero_line(win, shift=stack_offset.same())\n        #\n        # * show gated data b/c I use that for crossovers...\n        #   need to clearly see what is below/above threshold\n        #   signs cuts magnitude... b/c I only need to see 1/0/-1 for crossover logic\n        #   btw no need to first plot gate()... impact of that is obvious from signs(gated)\n        diff_stride2.gate().sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"signs(gate(stride2 diff))\")\n        plot_zero_line(win, shift=stack_offset.same())\n        offset_gated = stack_offset.same()\n        #\n        # * try lower gate thresholds (finds a few more points where subtle direction shifts in overall trend... i.e. bowl/dip on way up hump... I don't need that granularity\n        # FYI OK TO NUKE THIS LINE, was just a brief experiment:\n        diff_stride2.gate(lower=-0.2, upper=0.2).sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"EXPERIMENT: 0.2 gate comparison\")\n        plot_zero_line(win, shift=stack_offset.same())\n        offset_gated_experimental__0_2 = stack_offset.same()\n        #\n        # FYI signs(smooth(diff)) leads to skewing b/c magnitude of ramp-up is extreme and pulls up the apparent crossover point long before that actually happens!\n        #  that's why this is not a good metric for crossover!\n        #  *** instead, gating seems to be better b/c that is a diff way to eliminate noise near zero!\n        #    SO I SHOULD PROBABLY GET RID OF SMOOTHING FOR THE PURPOSES OF FINDING MINIMA ENTIRELY\n        diff_stride2.plot_smooth_signed(stack_offset.reserve(-5), **line_args, label_end=f\"signs(stride2 diff)\")\n        plot_zero_line(win, shift=stack_offset.same())\n\n    def plot_cross_box(cross: CrossoverData, y_middle: float) -> None:\n        \"\"\"Add a rectangle patch for a single crossover.\"\"\"\n        color = \"mediumaquamarine\" if cross.is_upward() else \"lightcoral\"\n        box_width = cross.after.seconds - cross.before.seconds\n        box_height = 2\n        lower_left_y = y_middle - 1\n        rect = plt.Rectangle(\n            (cross.before.seconds, lower_left_y),\n            box_width,\n            box_height,\n            edgecolor=color,\n            facecolor=color,\n            linewidth=1,\n            alpha=0.3,\n        )\n        plotter.ax.add_patch(rect)\n\n    crossovers = build_crossovers(diff_stride2_gated, analysis)\n    for cross in crossovers:\n        # at before/after idx => diff == diff_gated... b/c must be non-zero after gating (IOTW not gated to zero)\n        if plotter:\n            plot_cross_box(cross, offset_gated)\n            plot_crossover_min_and_max(cross, offset_gated, plotter, win)\n\n        if cross.is_upward():\n            if plotter:\n                minima_line = {\"linewidth\": 1, \"alpha\": 0.4, \"zorder\": 0}\n                plotter.ax.axvline(cross.before.seconds, color=\"teal\", **minima_line).pps = PPS.HOPS_USEFUL\n                plotter.ax.axvline(cross.middle.seconds, color=\"crimson\", **minima_line)\n                plotter.ax.axvline(cross.after.seconds, color=\"orangered\", **minima_line).pps = PPS.HOPS_USEFUL\n\n    if plotter:\n        crossovers__0_2 = build_crossovers(diff_stride2.gate(lower=-0.2, upper=0.2).sign(), analysis)\n        for cross in crossovers__0_2:\n            plot_cross_box(cross, offset_gated_experimental__0_2)\n\n    return get_material_crossovers(crossovers)\n\ndef mark_breathing(analysis: AudioAnalysisResult, plotter: SegmentPlotter | None = None):\n    if plotter:\n        clear()\n        breathing_state.set_plotter(plotter)\n\n    for win in analysis.windows:\n        win.breathing = None  # reset just in case was set elsewhere\n\n        console.print(f\"gap: {seconds_to_timecode_markup(win.gap.start_seconds(), fps=analysis.fps)} => \"\n                      f\"{seconds_to_timecode_markup(win.gap.end_seconds(), fps=analysis.fps)}\", highlight=False)\n\n        gap_rms = analysis.rms_slice_for_gap(win)\n\n        win.gap.crossovers = compute_crossovers(<|fim_middle|>)\n        c = GapContext(win, gap_rms, analysis, plotter)\n        taper_locate(c)\n        if plotter:\n            apply_manual_notes(plotter, c)\n            highlight_taper_with_spans(win, analysis, plotter)\n\n        # If there is exactly one crossover, treat as speech (not breathing)\n        if len(win.gap.crossovers) == 1:\n            continue\n\n        # If more than three crossovers, consider it a non‑breathing spike\n        if len(win.gap.crossovers) > 3:\n            # TODO is this even needed? this sounds like a double hump right?\n            #  if so, I shouldn't need this, in fact, do I handle this before this point and that's why this doesn't matter?\n            #  I would think this might cause me trouble to say > 3 CPs => not breathing... when half might be breathing!\n            continue\n\n        win.breathing = True\n        if plotter:\n            gap_rms.plot(color=\"dodgerblue\", linewidth=3)\n\n    if plotter:\n        plotter.toggle_zoom_level_elements()\n```\n\n## Reminders about the cursor line:\nText before cursor: `        win.gap.crossovers = compute_crossovers(`\nText after cursor: `)`"
      }],
    "options":[],
    "max_tokens":4096,
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  }
}