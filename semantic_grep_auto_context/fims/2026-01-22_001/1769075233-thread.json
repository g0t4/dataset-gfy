{
  "last_sse":{
    "created":1769075233,
    "timings":{
      "predicted_ms":586.417,
      "predicted_per_token_ms":4.8066967213115,
      "predicted_per_second":208.04308197068,
      "predicted_n":122,
      "prompt_per_second":6570.6441444405,
      "prompt_n":6591,
      "cache_n":1044,
      "prompt_ms":1003.098,
      "prompt_per_token_ms":0.15219208010924
    },
    "id":"chatcmpl-cUG4J5NcwXqQkztazS5yQHTU8fflZB4s",
    "choices":[{
        "delta":[],
        "index":0,
        "finish_reason":"stop"
      }],
    "system_fingerprint":"b7785-1c7cf94b2",
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "content":"SimpleNamespace(frames=63)",
    "reasoning_content":"We need to fill SimpleNamespace(time=...). Likely frame count? In test above they expect frames: left_taper_end frames=45, right_taper_start likely frames=63? In first test they assert ranges[1] end_frame 63 and start 45. So right_taper_start.time.frames should be 63? They use SimpleNamespace(time=SimpleNamespace(frames=45)) for left. So right should be SimpleNamespace(frames=63). So code: SimpleNamespace(frames=63).",
    "role":"assistant",
    "finish_reason":"stop"
  },
  "request_body":{
    "options":[],
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "top_p":1,
    "stream":true,
    "temperature":1,
    "max_tokens":4096,
    "model":"gpt-oss:120b",
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/detects/crossings.py:\n        self.max = RmsPoint(\n            AVTime(rms_segment.times[max_idx], analysis),\n            rms_segment.values[max_idx],\n        )\n\n.. yanked from auto_edit/new_silence/ranges_tests.py:\nSimpleNamespace\n\n.. yanked from auto_edit/new_silence/ranges_tests.py:\n        # left_taper_end=SimpleNamespace(seconds=1.5) rms=0.0)\n\n.. yanked from auto_edit/new_silence/ranges_tests.py:\n        left_taper_end=SimpleNamespace(time=SimpleNamespace(frames=45))\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:15-19\ndef only_has_taper(window, left, right):\n    assert window.gap.left_taper_end\n    assert window.gap.right_taper_start\n    assert window.gap.left_taper_end.time.seconds == pytest.approx(left, 0.001)\n    assert window.gap.right_taper_start.time.seconds == pytest.approx(right, 0.001)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:197-206\ndef is_single_dip_all_taper(analysis, same_min):\n            window = analysis.window_at_seconds(same_min)\n            assert len(window.gap.crossovers) == 1\n            same_min = pytest.approx(same_min, 0.001)\n            assert window.gap.left_taper_end\n            assert window.gap.right_taper_start\n            assert window.gap.left_taper_end.time.seconds == same_min\n            assert window.gap.right_taper_start.time.seconds == same_min\n            # PRN do I need this?\n            # assert not win.breathing  # speech is implicit in taper currently, dont worry about marking breathing?\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:198-237\ndef check_for_further_right_taper_hump():\n\n            if len(crosses) < 5:\n                # FYI 5 minimum so we have two humps\n                return None\n            crossM3 = crosses[-3]  # 3rd from last\n            crossM2 = crosses[-2]  # 2nd from last\n            crossM1 = crosses[-1]  # last\n\n            if is_double_hump():\n                note(\"skip further taper search on double humps\")\n                # PRN alternatives: use hump width OR hump height to skip\n                # - minute4@7sec - gap has middle min slightly lower than right_taper_start - but its breathing\n                #   159ms+266ms=425ms total right hump (set max at 100ms or 150ms?)\n                #   40dB height (hump mins to hump max)\n                #   OR can I use the min/max relationship to find out if its up or down?\n                #     i.e. do consecutive max values need to also be descending?\n                # NOTE this skip DOESN'T apply to left taper search b/c left hump is speech:\n                #   min7:2.5s,57s - speech + breathing each (need to keep left hump, gate/mute right)\n                #     min7@29.5s - also speech+breathing but min is too shallow - not recognized on left side\n                #   if needed I can use duration/dB change on left hump decision to apply this\n                return None\n\n            # * must end in min/max/min\n            if not (crossM3.is_local_min() \\\n               and crossM2.is_local_max() \\\n               and crossM1.is_local_min()):\n                return None\n\n            # * verify rising RMS\n            # TODO would be nice to have hump.drop_db or hump.rise_db (b/w mins)\n            rise_in_rms = crossM1.min.rms - crossM3.min.rms\n            rich.print(f'  right rampup (reverse taper) {rise_in_rms=}')\n\n            if rise_in_rms <= 0:\n                # ?? non-zero threshold? first find examples (i.e. one where rise is almost level but dips by say 0.5dB) and I still want it to be flagged as part of ramp up\n                return None\n\n            # * extend taper through hump's left min\n            gap.right_taper_start = crossM3.min\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:161-192\ndef test_detect_last_taper_so_I_can_cut_long_pauses__also_tiny_drop_in_rms_at_start_is_not_still_part_of_taper(self):\n\n        # * min 4\n        # I need to cut long pauses, and that can result in middle of the rampup cuts\n        # so I need taper detection, fortunately it is eays peasy!\n        #\n        # unused mins:\n        # | max3:30.1516s -49.6630dB | min4:30.2271s -75.0830dB | max5:30.3062s -46.1619dB | min6:30.3276s -61.3436dB | max7:30.3672s -43.6780dB\n        #\n        win = analysis4().window_at_seconds(30.7)\n        #\n        # * left_taper_end (first hump) - TINY DROP in RMS does not qualify as taper continuing\n        # min0:30.0224s -77.6650dB | max1:30.0646s -50.7167dB | min2:30.1068s -77.8038dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(30.0224, 0.001)\n        #   min2 is a smidge lower, 0.14528656 lower\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms  # FYI would be nice to have a cleaner way to work with this, i.e. humps[0].db_drop\n        assert hump1_db_drop == pytest.approx(0.1388, 0.01)  # (santiy check only)\n        #\n        # * right_taper_start (last hump)\n        #  I interpret the taper as including that keystroke right at end of gap...\n        #  it meets my definition of descending mins (or ascending for right_taper_start)\n        # | min8:30.6161s -92.9456dB | max9:30.6776s -32.2081dB | min10:30.7276s -48.0868dB\n        humplast_db_rise = win.gap.crossovers[-1].min.rms - win.gap.crossovers[-3].min.rms\n        rich.print(f'{win.gap.crossovers[-1].min.rms=}')\n        rich.print(f'{win.gap.crossovers[-3].min.rms=}')\n        assert humplast_db_rise == pytest.approx(44.8568, 0.001)  # -48.0868--92.9456 (santiy check only)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(30.6161, 0.001)\n        # TODO pullback at least 2 frames is goal, which is doable if you do right reverse taper (rampup)\n        #  - cut long pause resulted in 2 frames into the typing noise or w/e at start of rampup on right side\n        #  - it sounds fine b/c it is not speaking noise\n        # keep going down until min(next, inner direction) has > rms_db\n        # in this case it drops to -90smth after 1 hump (back)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:114-321\nclass TestTaperSearch:\n\n    def test_double_hump_NOT_detected_as_taper_nor_breathing(self):\n        # ~43.7 seconds\n        #  use duration and/OR middle min is higher than first min (left) ... use that! too?\n        #  min0:43.6906s -49.73dB | max1:43.7328s -34.39dB | min2:43.7630s -41.11dB | max3:43.7896s -36.46dB | min4:43.8312s -47.59dB\n        #    btw each CP is numberd 0+ ... I am not numbering min/max separately\n        win = analysis7().window_at_seconds(43.7)\n        assert len(win.gap.crossovers) == 5\n        min0 = pytest.approx(43.6906, 0.001)\n        assert win.gap.left_taper_end  # thru min0 (not min1)\n        assert win.gap.left_taper_end.time.seconds == min0\n        # assert not win.breathing\n\n    def test_taper_then_typing__in_wide_gap__DOES_DETECT_TAPER_at_start(self):\n        # observations:\n        #     - this bottoms out (literally) at -94dB (basically zero, is zero on my mixpre6 w/ noisegate)\n        #     - so far the taper always continues while subsequent mins are lower than before (no increase in mins so far)\n        #        - stop when mins bottom/level out then?\n        #        - here you can see 5th min is -92.2 so that is higher/same\n        #           rest of critical points:\n        #               | max3:47.1578s -75.21dB | min4:47.2547s -92.15dB\n        #               | max5:47.2995s -64.94dB | min6:47.3948s -86.97dB\n        #               | max7:47.4391s -70.06dB | min8:47.4510s -73.06dB\n        #               | max9:47.4568s -71.34dB | min10:47.5854s -92.47dB\n        #               | max11:47.6906s -69.59dB | min12:47.9583s -94.30dB\n        #               | max13:48.0708s -60.13dB | min14:48.0849s -65.05dB\n        #               | max15:48.1755s -43.56dB | min16:48.5620s -78.97dB\n        # #     - Ideally I'd like to see cut off at cp3 (min) at -94dB\n        #       * in this case doesn't matter how I round the frame!\n        #     - ? will taper's always stop at a 3rd minimum?\n        #     -   do I have any examples of tapers that go beyond that?\n        #     -   PRN add logging to detect if it happens and flag it?\n        #          basically I could be adding _minimal_ logging of assumptions (or potential assumptions)\n        #\n        #     rest of critical points are from typing, not that important:\n        win = analysis7().window_at_seconds(46.32)\n        # min0:46.3167s -47.29dB | max1:46.3505s -39.15dB | min2:46.6266s -94.30dB\n        min0 = pytest.approx(46.3167, 0.001)\n        max1 = pytest.approx(46.3505, 0.001)\n        min2 = pytest.approx(46.6266, 0.001)  # * s/b the left_taper_end\n        assert win.gap.left_taper_end  # thru min0 (not min1)\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms\n        assert hump1_db_drop == pytest.approx(47.01, 0.001)  # (sanity check only)\n        # assert win.gap.left_taper_end.time.seconds == min0 # first ensure reaches legit taper of left_speech (before humps)\n        assert win.gap.left_taper_end.time.seconds == min2\n\n    def test_detect_last_taper_so_I_can_cut_long_pauses__also_tiny_drop_in_rms_at_start_is_not_still_part_of_taper(self):\n\n        # * min 4\n        # I need to cut long pauses, and that can result in middle of the rampup cuts\n        # so I need taper detection, fortunately it is eays peasy!\n        #\n        # unused mins:\n        # | max3:30.1516s -49.6630dB | min4:30.2271s -75.0830dB | max5:30.3062s -46.1619dB | min6:30.3276s -61.3436dB | max7:30.3672s -43.6780dB\n        #\n        win = analysis4().window_at_seconds(30.7)\n        #\n        # * left_taper_end (first hump) - TINY DROP in RMS does not qualify as taper continuing\n        # min0:30.0224s -77.6650dB | max1:30.0646s -50.7167dB | min2:30.1068s -77.8038dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(30.0224, 0.001)\n        #   min2 is a smidge lower, 0.14528656 lower\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms  # FYI would be nice to have a cleaner way to work with this, i.e. humps[0].db_drop\n        assert hump1_db_drop == pytest.approx(0.1388, 0.01)  # (santiy check only)\n        #\n        # * right_taper_start (last hump)\n        #  I interpret the taper as including that keystroke right at end of gap...\n        #  it meets my definition of descending mins (or ascending for right_taper_start)\n        # | min8:30.6161s -92.9456dB | max9:30.6776s -32.2081dB | min10:30.7276s -48.0868dB\n        humplast_db_rise = win.gap.crossovers[-1].min.rms - win.gap.crossovers[-3].min.rms\n        rich.print(f'{win.gap.crossovers[-1].min.rms=}')\n        rich.print(f'{win.gap.crossovers[-3].min.rms=}')\n        assert humplast_db_rise == pytest.approx(44.8568, 0.001)  # -48.0868--92.9456 (santiy check only)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(30.6161, 0.001)\n        # TODO pullback at least 2 frames is goal, which is doable if you do right reverse taper (rampup)\n        #  - cut long pause resulted in 2 frames into the typing noise or w/e at start of rampup on right side\n        #  - it sounds fine b/c it is not speaking noise\n        # keep going down until min(next, inner direction) has > rms_db\n        # in this case it drops to -90smth after 1 hump (back)\n\n    def test_one_dip_marks_as_speech(self):\n        # mark as taper by setting taper points\n\n        def is_single_dip_all_taper(analysis, same_min):\n            window = analysis.window_at_seconds(same_min)\n            assert len(window.gap.crossovers) == 1\n            same_min = pytest.approx(same_min, 0.001)\n            assert window.gap.left_taper_end\n            assert window.gap.right_taper_start\n            assert window.gap.left_taper_end.time.seconds == same_min\n            assert window.gap.right_taper_start.time.seconds == same_min\n            # PRN do I need this?\n            # assert not win.breathing  # speech is implicit in taper currently, dont worry about marking breathing?\n\n        # * minute 3\n        # min0:2.1594s -88.7477dB\n        is_single_dip_all_taper(analysis3(), 2.1594)\n\n        # * minute4 @ 8sec\n        # min0:8.0453s -75.2313dB\n        is_single_dip_all_taper(analysis4(), 8.0453)\n\n        # * minute4 @ 35.88sec\n        # min0:35.8875s -83.3112dB\n        is_single_dip_all_taper(analysis4(), 35.8875)\n\n        # * minute 5\n        # min0:12.9932s -77.7741dB\n        is_single_dip_all_taper(analysis5(), 12.9932)\n        # min0:42.9948s -92.7182dB\n        is_single_dip_all_taper(analysis5(), 42.9948)\n\n        # * minute7 @ 12.9sec\n        # assert len(win11_2s.gap.subsegs) == 2\n        is_single_dip_all_taper(analysis7(), 11.96)\n\n    def test_split_first_gap_into_taper_and_breath(self):\n        assert len(analysis7().windows) == 20\n\n        # TODO make sure these tests continue on as I move to critical points for all detection\n\n        # * breathing\n        win6s = analysis7().windows[1]\n        assert win6s.breathing\n        only_has_taper(win6s, 6.91, 7.16)\n\n        # * breathing\n        win11s = analysis7().windows[2]\n        assert win11s.breathing\n        only_has_taper(win11s, 11.03, 11.33)\n\n        # * breathing\n        win13s = analysis7().windows[4]\n        assert win13s.breathing\n        only_has_taper(win13s, 13.61, 13.93)\n\n        # * breathing\n        win15s = analysis7().windows[5]\n        assert win15s.breathing\n        only_has_taper(win15s, 15.18, 15.40)\n\n        win18s = analysis7().windows[6]\n        assert win18s.breathing\n        only_has_taper(win18s, 18.49, 18.63)\n\n        win21s = analysis7().windows[7]\n        assert win21s.breathing\n        only_has_taper(win21s, 21.09, 21.33)\n\n        win23s = analysis7().windows[8]\n        assert win23s.breathing\n        only_has_taper(win23s, 23.70, 23.86)\n\n        win27s = analysis7().windows[9]\n        assert win27s.breathing\n        only_has_taper(win27s, 27.05, 27.32)\n\n        win29s = analysis7().windows[10]\n        assert win29s.breathing\n        only_has_taper(win29s, 29.22, 29.51)\n        # FYI this one has blue vertical lines at top of hump, if use those lines, then use this test to eliminate when slope == 0\n\n        win32s = analysis7().windows[11]\n        assert win32s.breathing\n        only_has_taper(win32s, 32.58, 32.83)\n\n        win34s = analysis7().windows[12]\n        assert win34s.breathing\n        only_has_taper(win34s, 34.43, 34.65)\n\n        # BREATHING (non-standard?)\n        win37s = analysis7().windows[13]\n        assert win37s.breathing\n        only_has_taper(win37s, 37.98, 38.35)\n\n        # BREATHING\n        win41s = analysis7().windows[14]\n        assert win41s.breathing\n        only_has_taper(win41s, 41.91, 42.24)\n\n        # * not breathing => word is \"at\"\n        # * PATTERN: lazy_middle_m (middle leg is barely drawn, barely dips)\n        #    think breathing but w/ a hump that dips in the middle\n        #    140ms side to side of full m\n        #    ~40ms to max of first hump => 30ms to middle leg's lazy dip\n        #      mirror on way out\n        win43s = analysis7().windows[15]\n        assert win43s.gap.crossovers\n        # assert not win43s.breathing # TODO GET WORKING BY REJECTING 3 MINIMA with this little duration within a given subset (between minima)\n        only_has_taper(win43s, 43.69, 43.83)\n\n        # * typing fingers waveform\n        win46s = analysis7().windows[16]\n        assert not win46s.breathing\n        # min0:46.3167s -47.2853dB | max1:46.3505s -39.1514dB | min2:46.6266s -94.3020dB | max3:47.1578s -75.2083dB | min4:47.2547s -92.1545dB | max5:47.2995s -64.9374dB\n        # | min6:47.3948s -86.9671dB | max7:47.4391s -70.0614dB | min8:47.4510s -73.0575dB | max9:47.4568s -71.3409dB | min10:47.5854s -92.4671dB | max11:47.6906s -69.5855dB\n        # | min12:47.9583s -94.3020dB | max13:48.0708s -60.1251dB | min14:48.0849s -65.0497dB | max15:48.1755s -43.5629dB | min16:48.5620s -78.9731dB\n        only_has_taper(win46s, 46.6266, 48.5620)\n\n        # * breathing again\n        win52s = analysis7().windows[17]\n        assert win52s.breathing\n        only_has_taper(win52s, 52.99, 53.33)\n\n        # * breathing again\n        win55s = analysis7().windows[18]\n        assert win55s.breathing\n        only_has_taper(win55s, 55.20, 55.44)\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/ranges_tests.py\nfrom types import SimpleNamespace\nimport numpy as np\nimport pytest\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, DetectThresholds, DetectedSegment, GapWindow, LoadedAudio, NonSpeechGap, RmsPoint, SegmentLabel\nfrom auto_edit.new_silence.ranges import get_ranges\nfrom auto_edit.ranges import ContentRange, SilenceRange\n\nid_counter = 0\nTEST_VIDEO_FPS = 30\n\n@pytest.fixture(autouse=True)\ndef reset_id_counter():\n    # ensure the module variable is reset\n    import importlib\n    import auto_edit.new_silence.detect_tests as ft\n    importlib.reload(ft)\n\ndef silence_seg(start, end):\n    global id_counter\n    seg = DetectedSegment(\n        id=id_counter,\n        start_seconds=start,\n        end_seconds=end,\n        label=SegmentLabel.SILENCE,\n        rms_values=np.array([id_counter]),\n    )\n    id_counter += 1\n    return seg\n\ndef speech_seg(start, end):\n    global id_counter\n    seg = DetectedSegment(\n        id=id_counter,\n        start_seconds=start,\n        end_seconds=end,\n        label=SegmentLabel.SPEECH,\n        rms_values=np.array([id_counter]),  # make the samples identifiable is all I need for now\n    )\n    id_counter += 1\n    return seg\n\ndef fake_analysis_for(wins: list[GapWindow]) -> AudioAnalysisResult:\n    irrelevant_thresholds = DetectThresholds(breath=np.float32(-22.0), silence=np.float32(-40.0))\n    empty_timestamps = np.array([], dtype=np.float32)\n    empty_audio = np.array([], dtype=np.float32)\n\n    audio_sample_rate = 22050\n    hop_len = 25\n\n    hops_per_second = audio_sample_rate / hop_len\n    total_seconds = wins[-1].end_seconds()\n    rms_db = np.ones(int(total_seconds * hops_per_second), dtype=np.float32)\n\n    return AudioAnalysisResult(\n        windows=wins,\n        audio=LoadedAudio(\n            samples=empty_audio,\n            samples_per_second=audio_sample_rate,\n        ),\n        rms_db=rms_db,\n        time_stamps=empty_timestamps,\n        thresholds=irrelevant_thresholds,\n        hop_length=hop_len,\n        fps=TEST_VIDEO_FPS,\n    )\n\nclass TestNewSilenceToRanges:\n\n    # TODO what if only partial gap_window? (i.e. leading silence at start of video, or end, plus then at start you have speech after, or at end speech is only before)\n\n    def test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n        )\n            # AVTime(rms_segment.times[max_idx], analysis),\n            # rms_segment.values[max_idx],\n\n        left_taper_end=SimpleNamespace(time=SimpleNamespace(frames=45))\n        right_taper_start=SimpleNamespace(time=<|fim_middle|>\n        # right_taper_start=SimpleNamespace(frame_aligned_at_seconds=2.1),\n\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n\n    def test_two_back_to_back_windows_with_frame_alignment_shifts(self):\n        # TODO do another test like this but with fraction of frames for all start/end times that way I can test out rounding\n        #   might need different cases to round up/down\n        #   and especially need more cases if I go the route of looking at RMS values to decide how to round\n        #       but only do this when real videos you're editing show the need for it\n        win1 = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1.5333333),  # FYI aligns UP a frame\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2.1333333),  # FYI aligns UP a frame\n        )\n        win2 = GapWindow(\n            # remember gaps overlap => sliding by two at a time basically\n            left_speech=win1.right_speech,  # same as prior right_speech\n            gap=NonSpeechGap(segments=[silence_seg(3, 5.1)]),\n            right_speech=speech_seg(5.1, 6),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=3.0333333),  # FYI aligns UP a frame\n            last_min=SimpleNamespace(frame_aligned_at_seconds=5.0666666),  # FYI aligns DOWN a frame\n        )\n        analysis = fake_analysis_for([win1, win2])\n\n        ranges = get_ranges(analysis)\n\n        # first window\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 46\n        assert type(ranges[0]) == ContentRange\n        assert ranges[1].start_frame == 46\n        assert ranges[1].end_frame == 64\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 64\n        assert ranges[2].end_frame == 91\n        assert type(ranges[2]) == ContentRange\n        assert ranges[3].start_frame == 91\n        assert ranges[3].end_frame == 152\n        assert type(ranges[3]) == SilenceRange\n\n        # this is the edge case at the end (if no silence after, then need to take this from last window)\n        assert ranges[4].start_frame == 152\n        assert ranges[4].end_frame == 180\n        assert type(ranges[4]) == ContentRange\n\n    def test_taper_out_and_in(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(\n                frame_aligned_at_seconds=1.6,\n                rms=0.5,  # PRN tests of different levels (if it plays a part with say range type)\n            ),\n            last_min=SimpleNamespace(\n                frame_aligned_at_seconds=2.0,\n                rms=0.5,\n            ),\n        )\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n```\n\n## Reminders about the cursor line:\nText before cursor: `        right_taper_start=SimpleNamespace(time=`"
      }],
    "raw":false
  }
}