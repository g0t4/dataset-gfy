{
  "request_body":{
    "stream":true,
    "top_p":1,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: mcp-server-commands\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## TypeScript Code Preferences\n\n- Use camelCase\n- Use PascalCase for classes and interfaces\n- Terminate with a semicolon.\n\n\n## Recent yanks across all files in the project:\n.. yanked from src/decide/spawn-sync.ts:\n    if (result.stderr and result.stderr.length > 0) {\n\n.. yanked from src/decide/spawn-sync.ts:\n    if (result.stderr && result.stderr.length > 0) {\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/mcp-server-commands/src/messages.ts:6-56\n       function messagesFor(result: ExecResult): TextContent[] {\n    const messages: TextContent[] = [];\n\n    if (result.code !== undefined) {\n        messages.push({\n            type: \"text\",\n            text: `${result.code}`,\n            name: \"EXIT_CODE\",\n        });\n    }\n\n    // PRN any situation where I want to pass .message and/or .cmd?\n    // maybe on errors I should? that way there's a chance to make sure the command was as intended\n    // and maybe include message when it doesn't contain stderr?\n    // FYI if I put these back, start with tests first\n\n    // PRN use a test to add these, sleep 10s maybe and then kill that process?\n    //  definitely could be useful to know if a command was killed\n    //  make sure signal is not null, which is what's used when no signal killed the process\n    // if (result.signal) {\n    //     messages.push({\n    //         type: \"text\",\n    //         text: `Signal: ${result.signal}`,\n    //         name: \"SIGNAL\",\n    //     });\n    // } \n    // if (!!result.killed) {\n    //     // killed == true is the only time to include this\n    //     messages.push({\n    //         type: \"text\",\n    //         text: \"Process was killed\",\n    //         name: \"KILLED\",\n    //     });\n    // }\n\n    if (result.stdout) {\n        messages.push({\n            type: \"text\",\n            text: result.stdout,\n            name: \"STDOUT\",\n        });\n    }\n    if (result.stderr) {\n        messages.push({\n            type: \"text\",\n            text: result.stderr,\n            name: \"STDERR\",\n        });\n    }\n    return messages;\n}\n\n## ~/repos/github/g0t4/mcp-server-commands/src/messages.ts:30-49\n    //     });\n    // } \n    // if (!!result.killed) {\n    //     // killed == true is the only time to include this\n    //     messages.push({\n    //         type: \"text\",\n    //         text: \"Process was killed\",\n    //         name: \"KILLED\",\n    //     });\n    // }\n\n    if (result.stdout) {\n        messages.push({\n            type: \"text\",\n            text: result.stdout,\n            name: \"STDOUT\",\n        });\n    }\n    if (result.stderr) {\n        messages.push({\n\n\n## ~/repos/github/g0t4/mcp-server-commands/tests/integration/run-command.test.ts:135-154\n        // expect(result.isError).toBeUndefined();\n        const stdout = result.content[0];\n        expect(result.content).toBe([]); // just to compare (log basically)\n        expect(stdout.name).toBe(\"STDOUT\");\n        expect(stdout.text).toBe(\"Hello World\");\n    });\n\n    // TODO! add integration tests of all the common commands you will use\n    //   AND common scenarios of each that materially are affected by how STDIO and process are setup\n    // i.e. grep, sed, fd, ls, pwd, git (status,...?), ...\n\n    // TODO add tests of timeout parameter and implement it\n\n    // TODO other params I want to add with new STDIO approach?\n    // * shell - or at least show default shell (path/PATH) and run it to get its version and name info and add that to tool instructions?\n\n    describe(\"when stdin passed and command succeeds\", () => {\n        const request = runCommand({\n            command: \"cat\",\n            stdin: \"Hello World\",\n\n\n## ~/repos/github/g0t4/mcp-server-commands/src/messages.ts:0-19\nimport { ExecResult } from \"./exec-utils.js\";\nimport { TextContent } from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * Converts an ExecResult into an array of TextContent messages.\n */\nexport function messagesFor(result: ExecResult): TextContent[] {\n    const messages: TextContent[] = [];\n\n    if (result.code !== undefined) {\n        messages.push({\n            type: \"text\",\n            text: `${result.code}`,\n            name: \"EXIT_CODE\",\n        });\n    }\n\n    // PRN any situation where I want to pass .message and/or .cmd?\n    // maybe on errors I should? that way there's a chance to make sure the command was as intended\n    // and maybe include message when it doesn't contain stderr?\n\n\n## ~/repos/github/g0t4/mcp-server-commands/tests/integration/run-command.test.ts:75-94\n        // console.log(result);\n\n        expect(result.isError).toBe(true);\n\n        expect(result.content).toHaveLength(2);\n\n        // FYI keep EXIT_CODE first, feels appropriate\n        //  do not put it after STDOUT/STDERR where it might be missed by me (when I do log reviews)\n        //  also I think its best for the model to see it first/early\n        const exit_code = result.content[0];\n        expect(exit_code.text).toContain(\"127\");\n        expect(exit_code.name).toContain(\"EXIT_CODE\");\n\n        const stderr = result.content[1];\n        // Verify error message contains the command name\n        expect(stderr.text).toMatch(/nonexistentcommand.*not found/i);\n        // gh actions:\n        //   /bin/sh: 1: nonexistentcommand: not found\n\n        expect(stderr.name).toContain(\"STDERR\");\n\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```src/decide/spawn-sync.ts\nimport { isAscii } from 'node:buffer';\nimport { spawnSync, SpawnSyncOptionsWithBufferEncoding, StdioOptions } from 'node:child_process';\nimport { setDefaultResultOrder } from 'node:dns';\n\n// NOTES:\n// - blocks event loop in exchange for convenience\n\nasync function runSyncWithStdio(stdioValue: StdioOptions) {\n\n    console.log(\"\\n\\n\" + \"=\".repeat(20) + \" run \" + \"=\".repeat(20) + \"\\n\");\n\n    const options: SpawnSyncOptionsWithBufferEncoding = {\n        stdio: stdioValue,\n    };\n\n    console.log(\"options\", options);\n\n    const command = \"ls\";\n    const args = [\"-lh\", \"/usr\"];\n    const result = spawnSync(command, args, options);\n\n    const chalk = (await import('chalk')).default\n\n    console.log(chalk.green(\"\\n## spawnSync COMPLETE\\n\"));\n\n    console.log(\"\\n## spawnSync COMPLETE\\n\");\n    console.log(\"result\", result);\n\n    if (result.stdout<|fim_middle|>) {\n        console.log(\"stdout:\", result.stdout.toString());\n    }\n    if (result.stderr && result.stderr.length > 0) {\n        console.log(`stderr (#${result.stderr.length}):`, result.stderr.toString());\n    }\n\n    return result;\n}\n\n// *** KEY setting => DO NOT USE \"inherit\" type behavior w/ MCP server \n//   b/c then it is writing to the STDOUT/ERR and reading from STDIN that are intended for client to server JSON based comms only!\n//\nrunSyncWithStdio(\"inherit\") // ls output is BEFORE result returned (b/c inherit means use parent process STDIN/OUT/ERR... so it writes immediately to STDOUT!\n\n// buffer STDOUT/ERR\nrunSyncWithStdio(\"pipe\") // ls output is obtained after result returned (b/c piped to buffer)\n```\n\n## Reminders about the cursor line:\nText before cursor: `    if (result.stdout`\nText after cursor: `) {`",
        "role":"user"
      }],
    "max_tokens":4096,
    "temperature":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "raw":false,
    "options":[],
    "model":"gpt-oss:120b"
  },
  "last_sse":{
    "id":"chatcmpl-O4SEQvcr4ffm7lN7gpLyj24VKbHnzCEU",
    "timings":{
      "cache_n":824,
      "prompt_per_second":2695.9839788744,
      "prompt_n":1707,
      "predicted_per_second":142.01946870276,
      "predicted_n":118,
      "prompt_ms":633.164,
      "prompt_per_token_ms":0.37092208553017,
      "predicted_ms":830.872,
      "predicted_per_token_ms":7.0412881355932
    },
    "system_fingerprint":"b7785-1c7cf94b2",
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "object":"chat.completion.chunk",
    "created":1769287829,
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "content":" && result.stdout.length > 0",
    "finish_reason":"stop",
    "reasoning_content":"We need to complete condition: result.stdout? likely check length. So replace with ` && result.stdout.length > 0`? The line currently: `if (result.stdout<|fim_middle|>) {`. After cursor we have `) {`. So we need to insert something before `)`. Should be ` && result.stdout.length > 0`. That yields `if (result.stdout && result.stdout.length > 0) {`. So insertion is ` && result.stdout.length > 0`.",
    "role":"assistant"
  }
}