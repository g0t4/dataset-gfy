{
  "response_message":{
    "content":"{\n    'lewis6991/gitsigns.nvim',\n    event = 'BufRead',\n    config = function()\n        require('gitsigns').setup()\n    end,\n},",
    "finish_reason":"stop",
    "reasoning_content":"Need to fill gitsigns plugin entry. Likely a table with plugin spec. Example: {'lewis6991/gitsigns.nvim', config = function() ... end}. Provide minimal. Return inside array. So:\n\n{\n    'lewis6991/gitsigns.nvim',\n    event = 'BufRead',\n    config = function()\n        require('gitsigns').setup()\n    end,\n},\n\nInsert that.",
    "role":"assistant"
  },
  "last_sse":{
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "timings":{
      "predicted_ms":554.657,
      "predicted_per_token_ms":4.201946969697,
      "cache_n":312,
      "prompt_per_second":8349.1160425265,
      "prompt_n":2213,
      "predicted_per_second":237.98491680444,
      "predicted_n":132,
      "prompt_ms":265.058,
      "prompt_per_token_ms":0.11977315860822
    },
    "system_fingerprint":"b7616-18ddaea2a",
    "id":"chatcmpl-S2swLFjyWZ1gfcS9AeWwFEklPkjqsvSQ",
    "choices":[{
        "finish_reason":"stop",
        "delta":[],
        "index":0
      }],
    "created":1768112167
  },
  "request_body":{
    "temperature":1,
    "top_p":1,
    "options":[],
    "model":"gpt-oss:120b",
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Lua Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Prefer EmmyLua/LuaLS style annotations\n- Always annotate when type inference would be ambiguous, or for public APIs.\n\nExamples:\n---@param names string[]\n---@param checker fun(name: string): boolean\n---@return table<string, integer>\nfunction process_names(names, checker) end\n\n---@class WindowController\n---@field window hs.axuielement\n---@field title? string\n---@field size { w: number, h: number }\nlocal WindowController = {}\n\n",
        "role":"user"
      },{
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nreturn {\n    {\n        -- gitsigns plugin \n        <|fim_middle|>\n    },\n    {\n        'puremourning/vimspector',\n        enabled = false, -- comment out to enable it next time you wanna use it, for now disable it\n        config = function()\n            -- articles to read/try:\n            -- - https://puremourning.github.io/vimspector-web/demo-setup.html\n            -- - https://dev.to/iggredible/debugging-in-vim-with-vimspector-4n0m\n            -- reference: https://puremourning.github.io/vimspector/\n            -- schemas: https://puremourning.github.io/vimspector/schema/\n            -- TODO keys\n            --   review: https://puremourning.github.io/vimspector-web/#debugging\n            --   TODO finish reviewing checklist in vimspector-checklist.vim (next to this file)\n            --   let g:vimspector_enable_mappings = 'HUMAN' \" https://github.com/puremourning/vimspector?tab=readme-ov-file#human-mode\n\n            vim.cmd [[\n\n                \"\n                \" * always map:\n                \"  FYI yes I am probably abusing <LocalLeader> to map it all the time... for now I see it as \"SecondaryLeader\" until I incorporate the idea of LocalLeader better into my keymaps\n                nmap <F5> <Cmd>call vimspector#Launch()<CR>\n                \" FYI :VimspectorLaunch cmd does not respect \"default\" config property, it must be passing args to Launch?\n                \" FYI consider <LocalLeader>dt if you start using LocalLeader for other purposes\n                \"   for now, given this is all I use LocalLeader for... I can reserve top level keymaps to simplify the \"keymap namespace\"\n                nmap <silent> <LocalLeader>t <Cmd>call vimspector#Reset()<CR>\n                \" allow reset (close) vimspector anytime (buffer LocalLeader maps below are unmapped on stop, when debugger stops, i.e. run past end of program b/c had no breakpoints)\n                \" FYI consider <LocalLeader>db\n                nmap <silent> <LocalLeader>b  <Cmd>call vimspector#ToggleBreakpoint()<CR>\n                nmap <silent> <LocalLeader>bn <Cmd>call vimspector#JumpToNextBreakpoint()<CR>\n                nmap <silent> <LocalLeader>bp <Cmd>call vimspector#JumpToPreviousBreakpoint()<CR>\n                \" vimspector#ToggleConditionalBreakpoint() ?\n                \" FYI advanced asks for values for conditional expr, hit count, log point expr using cmdline, nice Ux\n                nmap <silent> <LocalLeader>ba <Cmd>call vimspector#ToggleAdvancedBreakpoint()<CR>\n                nmap <silent> <LocalLeader>bl <Cmd>call vimspector#ListBreakpoints()<CR>\n                nmap <silent> <LocalLeader>bclear <Cmd>call vimspector#ClearBreakpoints()<CR>\n                \" TODO how about a keymap to send word under cursor / selection to the console to eval it?\n                \"    console doesn't truncate multi-line strings like inspect is doing\n                \"    call vimspector#Evaluate[Console](\"foo\")\n\n                \" TODO how hard would it be to persist breakpoints across restarts? Would I want this?\n                \"   not sure how often I would want this?\n\n                \" Custom mappings while debugging {{{\n                \" :h vimspector-custom-mappings-while-debugging -- AMEN! they already thought about custom mappings during debugging only!\n                \" User autocmds:\n                \"   VimspectorJumpedToFrame\n                \"   VimspectorDebugEnded\n                \"   example: https://github.com/puremourning/vimspector/blob/master/support/custom_ui_vimrc#L13\n\n                let s:mapped = {}\n\n                function! s:OnJumpToFrame() abort\n                  if has_key( s:mapped, string( bufnr() ) )\n                    return\n                  endif\n\n                  \" FYI these are reviewed:\n                  \" FYI LocalLeader allows overriding leader keys for current buffer (that way global <leader> keymaps aren't affected)\n                  \" sn = next (better ideas?).. do I want over or out to have so?\n                  \"   OR?  su (up/out), so (over), si (in/down)?\n                  nmap <silent> <buffer> <LocalLeader>sn <Plug>VimspectorStepOver\n                  nmap <silent> <buffer> <LocalLeader>si <Plug>VimspectorStepInto\n                  nmap <silent> <buffer> <LocalLeader>so <Plug>VimspectorStepOut\n\n                  \" FYI rtc just first idea, if used alot I may hate it\n                  nmap <silent> <buffer> <LocalLeader>rtc <Plug>VimspectorRunToCursor\n\n                  nmap <silent> <buffer> <LocalLeader>dc <Plug>VimspectorContinue\n                  \" instead of mouse hover, use this to show hover\n                  \" TODO dh instead of di? (h for hover, vs i for inspect)\n                  nmap <silent> <buffer> <LocalLeader>i <Plug>VimspectorBalloonEval\n                  xmap <silent> <buffer> <LocalLeader>i <Plug>VimspectorBalloonEval\n                  nmap <silent> <buffer> <LocalLeader>dre <Plug>VimspectorRestart\n                  nmap <silent> <buffer> <LocalLeader>dstop <Plug>VimspectorStop\n                  \" TODO can I override my F9 keymap for vimspector tab to call reset (which closes all windows, OR close all its windows, not just current window)?\n\n\n\n                  let s:mapped[ string( bufnr() ) ] = { 'modifiable': &modifiable }\n\n                  setlocal nomodifiable\n\n                endfunction\n\n                function! s:OnDebugEnd() abort\n\n                  let original_buf = bufnr()\n                  let hidden = &hidden\n                  augroup VimspectorSwapExists\n                    au!\n                    autocmd SwapExists * let v:swapchoice='o'\n                  augroup END\n\n                  try\n                    set hidden\n                    for bufnr in keys( s:mapped )\n                      try\n                        execute 'buffer' bufnr\n                        \" TODO port to lua and use a keymaps table array to unregister so I don't duplicate keymap lhs here:\n                        silent! nunmap <buffer> <LocalLeader>sn\n                        silent! nunmap <buffer> <LocalLeader>si\n                        silent! nunmap <buffer> <LocalLeader>so\n\n                        silent! nunmap <buffer> <LocalLeader>rtc\n\n                        silent! nunmap <buffer> <LocalLeader>dc\n                        silent! nunmap <buffer> <LocalLeader>i\n                        silent! xunmap <buffer> <LocalLeader>i\n                        silent! xunmap <buffer> <LocalLeader>dre\n                        silent! xunmap <buffer> <LocalLeader>dstop\n\n                        let &l:modifiable = s:mapped[ bufnr ][ 'modifiable' ]\n                      endtry\n                    endfor\n                  finally\n                    execute 'noautocmd buffer' original_buf\n                    let &hidden = hidden\n                  endtry\n\n                  au! VimspectorSwapExists\n\n                  let s:mapped = {}\n                endfunction\n\n                augroup TestCustomMappings\n                  au!\n                  autocmd User VimspectorJumpedToFrame call s:OnJumpToFrame()\n                  autocmd User VimspectorDebugEnded ++nested call s:OnDebugEnd()\n                augroup END\n\n                \" }}}\n\n                \" Custom mappings for special buffers {{{\n\n                let g:vimspector_mappings = {\n                      \\   'stack_trace': {},\n                      \\   'variables': {\n                      \\    'set_value': [ '<Tab>', '<C-CR>', 'C' ],\n                      \\   }\n                      \\ }\n\n                \" }}}\n\n\n            ]]\n\n            -- FYI these are from nvim dap plugin... use as a checklist for reviewing and changing the above conditional vimspector keymaps\n            -- vim.keymap.set('n', '<leader>sb', function() require('dap').step_back() end)\n            --\n            -- vim.keymap.set('n', '<Leader>dl', function() require('dap').set_breakpoint(nil, nil, vim.fn.input('Log point message: ')) end)\n            -- vim.keymap.set('n', '<Leader>dr', function() require('dap').repl.toggle() end) -- toggle instead of open/close\n            -- -- I will likely use legendary for remembering these commands and so its fine for a few to be unrealistic to type out and just for lookup only:\n            -- vim.keymap.set('n', '<Leader>d_run_last', function() require('dap').run_last() end) -- a as in again?\n            -- vim.keymap.set({ 'n', 'v' }, '<Leader>dp', function() require('dap.ui.widgets').preview() end)\n            -- vim.keymap.set('n', '<Leader>df', function()\n            --     local widgets = require('dap.ui.widgets')\n            --     widgets.centered_float(widgets.frames)",
        "role":"user"
      }],
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "raw":false,
    "max_tokens":4096,
    "stream":true
  }
}