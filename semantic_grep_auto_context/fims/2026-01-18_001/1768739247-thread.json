{
  "request_body":{
    "options":[],
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:320-324\n@staticmethod\n    def _window_at(windows: list[GapWindow], seconds: float) -> GapWindow | None:\n        for window in windows:\n            if window.start_seconds() <= seconds <= window.end_seconds():\n                return window\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:326-327\ndef window_at_seconds(self, seconds: float) -> GapWindow | None:\n        return self._window_at(self.windows, seconds)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:496-498\ndef zoom_to_gap_at_seconds(self, seconds: float) -> None:\n        window = self.analysis.window_at_seconds(seconds)\n        self.zoom_to_gap(window)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:245-250\ndef window_index():\n            middle = self.get_x_limits().middle\n            win_wes = AudioAnalysisResult._window_at(self.windows, middle)\n            if win_wes is not None:\n                return f\" win[{self.windows.index(win_wes)}]\"\n            return \"\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:227-276\ndef test_multiple_windows_with_silence_at_start_and_end(self):\n        # this is 99% of all recordings (always a quiet start/end)\n\n        win1 = GapWindow(\n            left_speech=None,\n            gap=NonSpeechGap(segments=[silence_seg(0, 1)]),  # * include\n            right_speech=speech_seg(1, 2),  # * include\n            first_min=SimpleNamespace(frame_aligned_at_seconds=0),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=1),\n        )\n        win2 = GapWindow(\n            left_speech=win1.right_speech,  # * dup\n            gap=NonSpeechGap(segments=[silence_seg(2, 3)]),  # * include\n            right_speech=speech_seg(3, 4),  # * include\n            first_min=SimpleNamespace(frame_aligned_at_seconds=2),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=3),\n        )\n        win3 = GapWindow(\n            # ??? throw if previous right_speech != left_speech here? s/b same segment object (or at least same timing and other characteristics)\n            left_speech=win2.right_speech,  # * dup\n            gap=NonSpeechGap(segments=[silence_seg(4, 5)]),  # * include\n            right_speech=None,\n            first_min=SimpleNamespace(frame_aligned_at_seconds=4),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=5),\n        )\n        analysis = fake_analysis_for([win1, win2, win3])\n\n        ranges = get_ranges(analysis)\n\n        assert len(ranges) == 5\n\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 30\n        assert type(ranges[0]) == SilenceRange\n\n        assert ranges[1].start_frame == 30\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == ContentRange\n\n        assert ranges[2].start_frame == 60\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == SilenceRange\n\n        assert ranges[3].start_frame == 90\n        assert ranges[3].end_frame == 120\n        assert type(ranges[3]) == ContentRange\n\n        assert ranges[4].start_frame == 120\n        assert ranges[4].end_frame == 150\n        assert type(ranges[4]) == SilenceRange\n",
        "role":"user"
      },{
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n        #     -   PRN add logging to detect if it happens and flag it?\n        #          basically I could be adding _minimal_ logging of assumptions (or potential assumptions)\n        #\n        #     rest of critical points are from typing, not that important:\n        win = self.analysis7.window_at_seconds(46.32)\n        # min0:46.3167s -47.29dB | max1:46.3505s -39.15dB | min2:46.6266s -94.30dB\n        min0 = pytest.approx(46.3167, 0.001)\n        max1 = pytest.approx(46.3505, 0.001)\n        min2 = pytest.approx(46.6266, 0.001)  # * s/b the left_taper_end\n        assert win.gap.left_taper_end  # thru min0 (not min1)\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms\n        assert hump1_db_drop == pytest.approx(47.01, 0.001)  # (sanity check only)\n        # assert win.gap.left_taper_end.time.seconds == min0 # first ensure reaches legit taper of left_speech (before humps)\n        assert win.gap.left_taper_end.time.seconds == min2\n\n    def test_detect_last_taper_so_I_can_cut_long_pauses__also_tiny_drop_in_rms_at_start_is_not_still_part_of_taper(self):\n        # * min 4\n        self.analysis4 = get_analysis(\"minute4\")\n\n        # I need to cut long pauses, and that can result in middle of the rampup cuts\n        # so I need taper detection, fortunately it is eays peasy!\n        #\n        # unused mins:\n        # | max3:30.1516s -49.6630dB | min4:30.2271s -75.0830dB | max5:30.3062s -46.1619dB | min6:30.3276s -61.3436dB | max7:30.3672s -43.6780dB\n        #\n        win = self.analysis4.window_at_seconds(30.7)\n        #\n        # * left_taper_end (first hump) - TINY DROP in RMS does not qualify as taper continuing\n        # min0:30.0224s -77.6650dB | max1:30.0646s -50.7167dB | min2:30.1068s -77.8038dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(30.0224, 0.001)\n        #   min2 is a smidge lower, 0.14528656 lower\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms  # FYI would be nice to have a cleaner way to work with this, i.e. humps[0].db_drop\n        assert hump1_db_drop == pytest.approx(0.1388, 0.01)  # (santiy check only)\n        #\n        # * right_taper_start (last hump)\n        #  I interpret the taper as including that keystroke right at end of gap...\n        #  it meets my definition of descending mins (or ascending for right_taper_start)\n        # | min8:30.6161s -92.9456dB | max9:30.6776s -32.2081dB | min10:30.7276s -48.0868dB\n        humplast_db_rise = win.gap.crossovers[-1].min.rms - win.gap.crossovers[-3].min.rms\n        rich.print(f'{win.gap.crossovers[-1].min.rms=}')\n        rich.print(f'{win.gap.crossovers[-3].min.rms=}')\n        assert humplast_db_rise == pytest.approx(44.8568, 0.001)  # -48.0868--92.9456 (santiy check only)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(30.6161, 0.001)\n        # TODO pullback at least 2 frames is goal, which is doable if you do right reverse taper (rampup)\n        #  - cut long pause resulted in 2 frames into the typing noise or w/e at start of rampup on right side\n        #  - it sounds fine b/c it is not speaking noise\n        # keep going down until min(next, inner direction) has > rms_db\n        # in this case it drops to -90smth after 1 hump (back)\n\n    def test_allow_left_taper_further_to_middle__block_right_taper_further_over_breathing_hump(self):\n        # * minute4 @ 7sec\n        analysis4 = get_analysis(\"minute4\")\n        win = analysis4.window_at_seconds(7)\n        assert len(win.gap.crossovers) == 5\n        # min0:6.7313s -39.1357dB | max1:6.7646s -34.6303dB |\n        # breathing: min2:6.8302s -75.8738dB | max3:6.9896s -38.2408dB | min4:7.2562s -73.8155dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(6.8302, 0.001)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(7.2562, 0.001)\n        # TODO assert breathing here too?\n\n        # * minute7 @ 57s - taper speech then breathing\n        win57s = self.analysis7.windows[19]\n        # assert win57s.breathing # TODO taper + breath\n        assert win57s.first_min.seconds == pytest.approx(57.18, 0.1)\n        # rich.print(win57s.gap.crossovers)\n        # TODO assert taper is part of speech at start...\n        #    * PROPOSED RULE => double bounce == ASSUME taper + breathing\n        #    SO, if I find double bounce w/in maybe some limits on duration too, then treat as taper+breathing until otherwise detected\n        #    57.28-57.18 == ~100ms (is this w/in my threshold for taper?\n        #\n        # TODO middle minima + last_min == breathing?\n        #   * APPROX 57.28s (~8.4 frames into 57seconds)\n        #   if my criteria works... keep in mind there will be times when your criteria doesn't work, NBD if rare!\n        #   rare enough as in not a PITA to edit! EASY EDITS is all that matters\n        assert win57s.last_min.seconds == pytest.approx(57.50, 0.1)\n\n    def test_one_dip_marks_as_speech(self):\n        # mark as taper by setting taper points\n\n        # * one dip only:\n        win11_2s = self.analysis7.window_at_seconds(<|fim_middle|>)\n        assert len(win11_2s.gap.crossovers) == 1\n        # assert len(win11_2s.gap.subsegs) == 2\n        assert not win11_2s.breathing  # TODO classify as speech (glue together windows or just mark this as speech)\n        assert win11_2s.first_min.seconds == pytest.approx(11.96, 0.1)\n        assert win11_2s.first_min.seconds == win11_2s.last_min.seconds\n\n    def test_split_first_gap_into_taper_and_breath(self):\n        # assert len(self.analysis.merged_segments) == 5\n        # rich.print(self.analysis.merged_segments)\n        assert len(self.analysis7.windows) == 20\n\n        # * windows[0] is in taper test above\n\n        # * breathing\n        win6s = self.analysis7.windows[1]\n        assert win6s.breathing\n        assert win6s.first_min.seconds == pytest.approx(6.91, 0.1)\n        assert win6s.last_min.seconds == pytest.approx(7.16, 0.1)\n\n        # * breathing\n        win11s = self.analysis7.windows[2]\n        assert win11s.breathing\n        assert win11s.first_min.seconds == pytest.approx(11.03, 0.1)\n        assert win11s.last_min.seconds == pytest.approx(11.33, 0.1)\n\n        # * breathing\n        win13s = self.analysis7.windows[4]\n        assert win13s.breathing\n        assert win13s.first_min.seconds == pytest.approx(13.61, 0.1)\n        assert win13s.last_min.seconds == pytest.approx(13.93, 0.1)\n\n        # * breathing\n        win15s = self.analysis7.windows[5]\n        assert win15s.breathing\n        assert win15s.first_min.seconds == pytest.approx(15.18, 0.1)\n        assert win15s.last_min.seconds == pytest.approx(15.40, 0.1)\n\n        win18s = self.analysis7.windows[6]\n        assert win18s.breathing\n        assert win18s.first_min.seconds == pytest.approx(18.49, 0.1)\n        assert win18s.last_min.seconds == pytest.approx(18.63, 0.1)\n        # TODO! switch to new minima reporting?\n        # TODO categorized subsets of gap identified\n\n        win21s = self.analysis7.windows[7]\n        assert win21s.breathing\n        assert win21s.first_min.seconds == pytest.approx(21.09, 0.1)\n        assert win21s.last_min.seconds == pytest.approx(21.33, 0.1)\n\n        win23s = self.analysis7.windows[8]\n        assert win23s.breathing\n        assert win23s.first_min.seconds == pytest.approx(23.70, 0.1)\n        assert win23s.last_min.seconds == pytest.approx(23.86, 0.1)\n\n        win27s = self.analysis7.windows[9]\n        assert win27s.breathing\n        assert win27s.first_min.seconds == pytest.approx(27.05, 0.1)\n        assert win27s.last_min.seconds == pytest.approx(27.32, 0.1)\n\n        win29s = self.analysis7.windows[10]\n        assert win29s.breathing\n        assert win29s.first_min.seconds == pytest.approx(29.22, 0.1)\n        assert win29s.last_min.seconds == pytest.approx(29.51, 0.1)\n        # FYI this one has blue vertical lines at top of hump, if use those lines, then use this test to eliminate when slope == 0\n\n        win32s = self.analysis7.windows[11]\n        assert win32s.breathing\n        assert win32s.first_min.seconds == pytest.approx(32.58, 0.1)\n        assert win32s.last_min.seconds == pytest.approx(32.83, 0.1)\n\n        win34s = self.analysis7.windows[12]\n        assert win34s.breathing\n        assert win34s.first_min.seconds == pytest.approx(34.43, 0.1)\n        assert win34s.last_min.seconds == pytest.approx(34.65, 0.1)\n\n        # BREATHING (non-standard?)\n        win37s = self.analysis7.windows[13]\n        assert win37s.breathing\n        assert win37s.first_min.seconds == pytest.approx(37.98, 0.1)\n        assert win37s.last_min.seconds == pytest.approx(38.35, 0.1)  # ?? TODO might not match exactly, low area for a while",
        "role":"user"
      }],
    "model":"gpt-oss:120b",
    "top_p":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "temperature":1,
    "raw":false,
    "max_tokens":4096,
    "stream":true
  },
  "last_sse":{
    "timings":{
      "predicted_ms":541.188,
      "predicted_per_token_ms":4.3644193548387,
      "predicted_per_second":229.12555341212,
      "predicted_n":124,
      "prompt_per_second":10305.476449016,
      "prompt_n":4024,
      "cache_n":0,
      "prompt_ms":390.472,
      "prompt_per_token_ms":0.09703578528827
    },
    "object":"chat.completion.chunk",
    "created":1768739247,
    "id":"chatcmpl-RWVXDk8WJgYD7WVLcKmkhcnnYdGRVfz8",
    "system_fingerprint":"b7616-18ddaea2a",
    "choices":[{
        "index":0,
        "delta":[],
        "finish_reason":"stop"
      }],
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "reasoning_content":"Need to fill the argument to window_at_seconds in test_one_dip_marks_as_speech. Likely time around 11.2? Based on earlier windows: win11_2s maybe at 11.2s? In later test win11s is breathing window index2 with first_min ~11.03 last_min ~11.33. For one dip (non-breathing) probably at 11.2? earlier they referenced win11_2s variable name suggests 11.2s. So fill 11.2.",
    "role":"assistant",
    "finish_reason":"stop",
    "content":"11.2"
  }
}