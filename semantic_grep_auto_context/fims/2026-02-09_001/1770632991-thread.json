{
  "last_sse":{
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "system_fingerprint":"b7785-1c7cf94b2",
    "id":"chatcmpl-va7cKTgQqiHamDiO7yqHgXhoOmkbI6TR",
    "created":1770632991,
    "timings":{
      "prompt_n":2017,
      "cache_n":1124,
      "prompt_ms":517.66,
      "prompt_per_token_ms":0.25664848785325,
      "predicted_ms":712.21,
      "predicted_per_token_ms":4.6549673202614,
      "predicted_per_second":214.82427935581,
      "predicted_n":153,
      "prompt_per_second":3896.3798632307
    },
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "reasoning_content":"We need to fill code after lines: if decoded_args.stdin then lines:<|fim_middle|>. Likely want to append stdin content, maybe using append_text_fold_if_long. Search similar. Probably: lines:append_text_fold_if_long(\"STDIN\", decoded_args.stdin). Also maybe remove stdin from args? Already iterating later includes it, but want header. So implement that and maybe set decoded_args.stdin=nil to avoid duplicate. Use similar style as stdout. So code:\n\nlines:append_text_fold_if_long(\"STDIN\", decoded_args.stdin)\ndecoded_args.stdin = nil\n\nReturn? just code.",
    "role":"assistant",
    "finish_reason":"stop",
    "content":"lines:append_text_fold_if_long(\"STDIN\", decoded_args.stdin)\ndecoded_args.stdin = nil"
  },
  "request_body":{
    "top_p":1,
    "temperature":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "model":"gpt-oss:120b",
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: ask-openai.nvim\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Lua Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Prefer EmmyLua/LuaLS style annotations\n- Always annotate when type inference would be ambiguous, or for public APIs.\n\nExamples:\n```lua\n---@param names string[]\n---@param checker fun(name: string): boolean\n---@return table<string, integer>\nfunction process_names(names, checker) end\n\n---@class WindowController\n---@field window hs.axuielement\n---@field title? string\n---@field size { w: number, h: number }\nlocal WindowController = {}\n```\n\n\n\n## Recent yanks (copy to clipboard):\n```lua/ask-openai/questions/lines_builder.lua\nfunction LinesBuilder:append_STDOUT(text, max_lines)\n```\n\n```lua/ask-openai/questions/lines_builder.lua\n---@param text string\n---@param max_lines? integer\nfunction LinesBuilder:append_STDOUT(text, max_lines)\n```\n\n```lua/ask-openai/questions/lines_builder.lua\nappend_text_fold_if_long\n```\n\n```lua/ask-openai/questions/lines_builder.lua\nkey .. \": \"  .. l\n```\n\n```lua/ask-openai/questions/lines_builder.lua\nkey .. \": \"\n```\n\n```lua/ask-openai/questions/chat/formatters/run_command.lua\n                    lines:append_text_fold_if_long(\"STDOUT\", text)\n```\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/questions/lines_builder.lua:107-110\n---@param lines string[]\nfunction LinesBuilder:append_lines(lines)\n    vim.list_extend(self.turn_lines, lines)\nend\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/questions/lines_builder.lua:54-66\n---@param lines string[]\nfunction LinesBuilder:append_styled_lines(lines, hl_group)\n    local start_line_base0 = #self.turn_lines\n    local mark = {\n        start_line_base0 = start_line_base0, -- base0 b/c next line is the marked one (thus not yet in line count)\n        start_col_base0 = 0,\n        end_line_base0 = start_line_base0 + #lines, -- IIAC I want end exclusive\n        end_col_base0 = 0, -- or, #lines[#lines], to stop on last line (have to -1 on end line too)\n        hl_group = hl_group\n    }\n    table.insert(self.marks, mark)\n    vim.list_extend(self.turn_lines, lines)\nend\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix_tests.lua:8-14\n    local function create_lines(num_lines)\n        local lines = {}\n        for i = 1, num_lines do\n            lines[i] = \"line \" .. i\n        end\n        return lines\n    end\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rewrites/frontend.lua:150-154\n                 function()\n        -- FYI the diff tool can handle massive changes to many, many lines... not sure what is slowing things down at times w/ llama-server and some bigger requests?\n        --   almost wonder if it is the verbose logging b/c that actually ends up failing (the logs) midway and I never see final messages, (--verbose and --verbose-prompt)\n        RewriteFrontend.displayer:on_response(RewriteFrontend.selection, lines)\n    end\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix_tests.lua:109-120\n                                                                              function()\n                local bufnr = buffers.new_buffer_with_lines(seven_lines)\n                local line_base1 = 4 -- 'line 4'\n                local col_base0 = 5 -- 5 ==> '4'\n                vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n                local take_lines = 2\n                local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n                assert.equal(\"line 2\\nline 3\\nline \", prefix)\n                assert.equal(\"4\\nline 5\\nline 6\", suffix)\n            end\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```lua/ask-openai/questions/chat/formatters/run_command.lua\nlocal log = require(\"ask-openai.logs.logger\").predictions()\nlocal HLGroups = require(\"ask-openai.hlgroups\")\nlocal safely = require(\"ask-openai.helpers.safely\")\n\nlocal M = {}\n\n---@param args_json string\n---@param message RxAccumulatedMessage\n---@return string: header\n---@return table?: decoded_args\nlocal function get_tool_header_text(args_json, message)\n    if message:is_still_streaming() then\n        return args_json, nil\n    end\n\n    local success, object_or_error = safely.decode_json_always_logged(args_json)\n    if not success then\n        return \"json decode failure (see logs): \" .. vim.inspect(object_or_error), nil\n    end\n\n    if not object_or_error.mode then\n        return \"missing mode: \", object_or_error\n    end\n\n    local mode = object_or_error.mode\n    object_or_error.mode = nil -- only want to pass back remaining args\n\n    if mode == \"shell\" then\n        local command_line = object_or_error.command_line\n        object_or_error.command_line = nil\n        if command_line then\n            return command_line, object_or_error\n        end\n        return \"missing command_line: \", object_or_error\n    end\n\n    if mode == \"executable\" then\n        local argv = object_or_error.argv\n        if argv then\n            local cmd = table.concat(argv, \" \")\n            object_or_error.argv = nil\n            return cmd, object_or_error\n        end\n        return \"missing argv: \", object_or_error\n    end\n\n    log:error(\"invalid mode\", args_json)\n    return \"invalid mode: \" .. args_json, object_or_error\nend\n\n---@type ToolCallFormatter\nlocal function add_tool_header(lines, tool_call, message)\n    local header, decoded_args = get_tool_header_text(tool_call[\"function\"].arguments, message)\n    local hl_group = HLGroups.TOOL_SUCCESS\n    if tool_call.call_output then\n        if tool_call.call_output.result.isError then\n            header = \"❌ \" .. header\n            hl_group = HLGroups.TOOL_FAILED\n        else\n            header = \"✅ \" .. header\n        end\n    end\n    -- gptoss sometimes uses a heredoc for a python script\n    --   with \\n between python statements\n    --   stuffed in the command field!\n    --   (anything to not use the stdin arg, lol)\n    lines:append_styled_text(header, hl_group)\n    return decoded_args\nend\n\n---@type ToolCallFormatter\nfunction M.format(lines, tool_call, message)\n    local decoded_args = add_tool_header(lines, tool_call, message)\n    if decoded_args then\n        -- PRN add indication that these are inputs? right now they blend in with outputs... (color?)\n        if decoded_args.stdin then\n            lines:<|fim_middle|>\n        end\n\n        for key, value in pairs(decoded_args) do\n            -- other inputs: cwd, stdin, timeout_ms, dry_run (I'd be fine w/ hiding timeout_ms and dry_run if false)\n            lines:append_text(key .. \": \" .. vim.inspect(value))\n        end\n    end\n\n    -- -- debug dump everything:\n    -- lines:append_text(vim.inspect(tool_call))\n\n    if not tool_call.call_output then\n        -- tool not yet run/running – indicate pending state\n        lines:append_unexpected_line(\"Tool call in progress...\")\n        return\n    end\n\n    -- * tool result\n    local is_mcp = tool_call.call_output.result.content\n    if is_mcp then\n        --- https://modelcontextprotocol.io/specification/2025-06-18/server/tools#tool-result\n\n        ---@class MCPToolCallOutputResult\n        ---@field result MCPToolResult\n\n        ---@class MCPToolCallOutputError\n        ---@field error { code, messeage }  -- { \"code\": 100, \"message\": \"Unknown tool: invalid_tool_name\" }\n\n        ---@class MCPToolResult\n        ---@field content? MCPToolResultContent[]  # unstructured output items\n        ---@field isError? boolean                # see content for exit code, STDERR, etc\n        ---@field structuredContent?              # structured output, has inputSchema/outputSchema\n\n        ---@class MCPToolResultContent\n        ---@field type string      # \"text\", \"image\", \"audio\", \"resource_link\", \"resource\" …\n        ---@field text? string     # for type=text\n        ---@field name? string     # i.e.: \"STDOUT\", \"STDERR\", \"EXIT_CODE\" … describe the text value\n\n        -- * TESTING:\n        -- - date command is one liner\n        -- - `ls -R` for lots of output\n\n        ---@type MCPToolResultContent[]\n        local content = tool_call.call_output.result.content\n\n        for _, output in ipairs(content) do\n            local name = output.name\n            local text = tostring(output.text or \"\")\n            -- PRN dict. lookup of formatter functions by type (name), w/ registerType(), esp. as the list of types grows\n            -- run_process\n            if name == \"STDOUT\" then\n                -- TODO! I want tool specific formatters... b/c for run_command, I want the command (esp if its small) to be the header! I don't need to see run_command ever, right?\n                if text then\n                    lines:append_text_fold_if_long(\"STDOUT\", text)\n                else\n                    -- PRN skip STDOUT entirely if empty?\n                    lines:append_unexpected_line(\"UNEXPECTED empty STDOUT?\")\n                end\n            else\n                -- GENERIC output type\n                if name == nil or name == \"\" then\n                    name = \"[NO NAME]\" -- heads up for now so I can identify scenarios/tools, can remove this later\n                end\n                if output.type == \"text\" then\n                    local is_multi_line = text:match(\"\\n\")\n                    if is_multi_line then\n                        lines:append_text(name)\n                        lines:append_text(text)\n                    else\n                        -- single line\n                        lines:append_text(name .. \": \" .. text)\n                    end\n                else\n                    lines:append_unexpected_text(\"  UNEXPECTED type: \\n\" .. vim.inspect(output))\n                end\n            end\n        end\n    else\n        -- TODO NON-MCP tool responses\n        --  i.e. in-process tools: rag_query, apply_patch\n    end\nend\n\nreturn M\n```\n\n## Reminders about the cursor line:\nText before cursor: `            lines:`",
        "role":"user"
      }],
    "stream":true,
    "max_tokens":4096,
    "options":[],
    "raw":false
  }
}