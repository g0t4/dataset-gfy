{
  "response_message":{
    "reasoning_content":"We need to insert code at <|fim_middle|>. Likely set fs.root_path and maybe initialize ignores spec. After setting root, need to reset gitignore_spec? Probably call lsp.ignores.setup_ignores? In tests they use _is_gitignored which calls get_gitignore_spec which caches. Need to ensure spec built for this root. So after setting fs.root_path = root, we should clear cached spec: lsp.ignores.gitignore_spec = None maybe. Import? Could do: import lsp.ignores; lsp.ignores.gitignore_spec = None. Also maybe call get_gitignore_spec? Simpler: reset global. So code: import lsp.ignores; lsp.ignores.gitignore_spec = None. Return root. So insert lines.\n\nThus:\n\n```\n    # reset cached gitignore spec for new temp root\n    lsp.ignores.gitignore_spec = None\n```\n\nAdd before return.",
    "role":"assistant",
    "finish_reason":"stop",
    "content":"    # reset cached gitignore spec for the temporary repository\n    lsp.ignores.gitignore_spec = None"
  },
  "request_body":{
    "max_tokens":4096,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: ask-openai.nvim\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks across all files in the project:\n.. yanked from lua/ask-openai/rag/lsp/ignores_tests.py:\nfs.root_path, Config.default())\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/lsp/ignores.py:10-36\ndef setup_ignores(fs_root_path: Path, config: Config) -> PathSpec:\n    # TODO why not just create this on first use! have helper to create/get it\n    gitignore_path = fs_root_path.joinpath(\".gitignore\")\n\n    ignore_entries = set()\n    if gitignore_path.exists():\n        ignore_entries = set(gitignore_path.read_text().splitlines())\n\n    # ALWAYS exclude:\n    ignore_entries.update([\n        # focus on directories mostly, the languages you actually index can filter on file types implicitly (not indexed == ignored too)\n        \".git\",\n        \".venv\",\n        \"__pycache__\",\n        \"node_modules\",\n        \"bower_components\",\n        \"iterm2env\",\n\n        # files that are often committed but shouldn't ever be indexed:\n        \"package-lock.json\",\n        \"uv.lock\",  # PRN *.lock?\n        # ? other lock files?\n    ])\n    if config.ignores:\n        ignore_entries.update(config.ignores)\n\n    return PathSpec.from_lines(GitWildMatchPattern, ignore_entries)\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/lsp/fs.py:77-87\ndef relative_to_workspace(path: Path | str, override_root_path: Path | None = None) -> Path:\n    path = Path(path)\n    use_root_path = override_root_path or root_path\n\n    if use_root_path is None:\n        return path\n\n    if not path.is_relative_to(use_root_path):\n        return path\n\n    return path.relative_to(use_root_path)\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/lsp/ignores.py:71-83\ndef _is_gitignored(file_path: str | Path, fs_root_path, config):\n    \"\"\" only ignores for gitignore \"\"\"\n    file_path = Path(file_path)\n\n    if not file_path.is_relative_to(fs_root_path):\n        # FYI for now IGNORE all files NOT inside the root path\n        return IGNORED\n\n    # relative path is needed for relative patterns that start without a wildcard\n    rel_path = file_path.relative_to(fs_root_path)\n\n    spec = get_gitignore_spec(fs_root_path, config)\n    return spec.match_file(rel_path)\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/lsp/ignores.py:40-52\ndef get_gitignore_spec(fs_root_path, config):\n    global gitignore_spec, _used_fs_root_path\n\n    if (gitignore_spec is None):\n        gitignore_spec = setup_ignores(fs_root_path, config)\n        _used_fs_root_path = fs_root_path\n\n    if (_used_fs_root_path != fs_root_path):\n        # instead of cache per path, this should never change so let's just warn!\n        #  it would be invaluable to know this changed too!\n        raise RuntimeError(f\"gitignore spec cached for different root: {_used_fs_root_path} vs {fs_root_path}\")\n\n    return gitignore_spec\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/lsp/config.py:15-34\ndefault_includes: list[str] = [\n        \"lua\", \"py\", \"java\", \"js\", \"ts\", \"html\",\n        \"md\", \"json\", \"yaml\", \"yml\",\n        \"fish\", \"zsh\", \"sh\", # shells\n        \"cpp\", \"cc\", \"c\", \"h\", \"hpp\", # c related\n        \"m\", \"mm\", # objective c\n        \"cu\", \"cuh\", \"cl\", # GPU\n        \"rs\",\n        \"go\",\n        \"patch\",\n    ] # yapf: disable\n\ndefault_ignores: list[str] = []\ndefault_global_languages: list[str] = []  # no defaults b/c if you don't set it, you get all indexed file types (includes)\ndefault_enabled: bool = True\n\n@dataclass\nclass Config:\n    ignores: list[str] = field(default_factory=list)\n    include: list[str] = field(default_factory=list)\n\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```lua/ask-openai/rag/lsp/ignores_tests.py\nfrom pathlib import Path\nimport pytest\nimport rich\n\nimport lsp.ignores\nfrom lsp.ignores import _is_gitignored\nfrom lsp.config import Config\nfrom lsp import fs\n\n@pytest.fixture\ndef tmp_root(tmp_path):\n\n    # * love that pytest has tmp_path dep => makes a temp dir and cleans up after test\n    #  and then tmp_root here is an extension of that that becomes a test dependency (see cases below)\n    # print(tmp_path)  # scoped per test too (by test name!)\n    # ends with: pytest-of-wesdemos/pytest-20/test_is_ignored0\n\n    # Create a temporary directory structure with .gitignore\n    root = tmp_path / \"repo\"\n    root.mkdir()\n\n    # Create .gitignore file with some patterns\n    gitignore = root / \".gitignore\"\n    gitignore.write_text(\"\"\"\n    *.log\n    /venv/\n    *.pyc\n    \"\"\")\n\n    fs.root_path = root  # TODO! REMOVE after migrate ignores off of what else?\n    <|fim_middle|>\n\n    return root\n\ndef test_package_lock_is_ignored(tmp_root):\n    rich.print(\"\\n[red bold]tmp_root\", tmp_root, \"\\n\")\n\n    # * careful with path that is ignored for other reasons\n    assert _is_gitignored(tmp_root / \"package-lock.json\", fs.root_path, Config.default())\n    assert _is_gitignored(tmp_root / \"uv.lock\", fs.root_path, Config.default())\n\ndef test_all_paths_ignored_for_asterisk_dot_extension_pattern(tmp_root):\n    # absolute path that IS relative to root_path\n    assert _is_gitignored(tmp_root / \"subdir/file.pyc\", fs.root_path, Config.default())\n\n    # relative path upfront\n    assert _is_gitignored(\"is/relative/initially.pyc\", fs.root_path, Config.default())\n\ndef test_ignore_if_not_relative_to_workspace_root_dir(tmp_root):\n    # absolute path that IS NOT relative to root_path\n    #  IOTW in a directory outside of root_path\n    assert _is_gitignored(\"/foo/subdir/file.pyc\", fs.root_path, Config.default())\n    assert _is_gitignored(\"/foo/subdir/bar.txt\", fs.root_path, Config.default())\n    assert _is_gitignored(\"/venv/foo.c\", fs.root_path, Config.default())\n\ndef test_literal_entry(tmp_root):\n    assert _is_gitignored(tmp_root / \"venv/foo.c\", fs.root_path, Config.default())\n    assert not _is_gitignored(tmp_root / \"venvfoo.c\", fs.root_path, Config.default())\n\ndef disabled_manual_test_listing_all_ignored_files_under_dir():\n    path = Path(\"~/repos/github/g0t4/ask-openai.nvim\")\n\n    assert lsp.ignores.gitignore_spec\n    spec = lsp.ignores.gitignore_spec\n    ignored_files = spec.match_tree(path)\n\n    print(\"IGNORED FILES:\")\n    for f in ignored_files:\n        print(f)\n```\n\n## Reminders about the cursor line:\nText before cursor: `    `\nText before cursor is all whitespace (do not ignore this)",
        "role":"user"
      }],
    "top_p":1,
    "options":[],
    "model":"gpt-oss:120b",
    "raw":false,
    "stream":true,
    "temperature":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  },
  "last_sse":{
    "created":1769433381,
    "object":"chat.completion.chunk",
    "timings":{
      "prompt_ms":196.719,
      "prompt_per_token_ms":0.12302626641651,
      "predicted_ms":1330.618,
      "predicted_per_token_ms":5.7354224137931,
      "predicted_per_second":174.35507410842,
      "predicted_n":232,
      "prompt_per_second":8128.3455080597,
      "prompt_n":1599,
      "cache_n":928
    },
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "system_fingerprint":"b7785-1c7cf94b2",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-Ek3CIEP4gOnyi6bspdbTtixtL8mgXhQA"
  }
}