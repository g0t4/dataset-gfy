{
  "request_body":{
    "raw":false,
    "model":"gpt-oss:120b",
    "max_tokens":4096,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "options":[],
    "stream":true,
    "top_p":1,
    "temperature":1,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:110-129\n            constrained_layout=True,\n        )\n\n        self.message_text = self.fig.text(\n            0.05,  # x-offset ratio (0 = left, 1 = right) \n            # FYI 0.10 gives me ~10 lines @ 8pt font\n            #  use 0.15 => 5% padding to not overlap x-axis on bottom, and then leave room for ~10 lines\n            #  if need more, reposition mouse to hover over less stuff!\n            0.05,  # y-offset ratio (0 = bottom, 1 = top)\n            \"\",\n            ha=\"left\",\n            va=\"bottom\",\n            fontsize=8,\n            color=\"white\",\n        )\n\n        facecolor = \"#202124\"\n        self.ax.set_facecolor(facecolor)  # almost black, very neutral\n        self.fig.set_facecolor(facecolor)\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:70-76\ndef mark_rejected(self, why: str):\n        text_label(\n            x_pos=self.times[len(self.times) // 2],\n            y_pos=self.values.max() + 3,\n            text=why,\n        )\n        self.plot(color=\"pink\", linewidth=1)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:26-29\ndef plot_smooth_signed(self, shift, color, label_end, **kwargs):\n        self.smooth().plot(color=color, linewidth=1, shift=shift, label_end=label_end, **kwargs)\n        # FYI smooth needs to clearly stand out, it is a good guide for quickly spotting material diff changes\n        self.smooth().sign().plot(color=\"#FFFFFF\", linewidth=1.4, shift=shift, alpha=0.9)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:321-349\ndef mark_aligned_frame(self, time_point: float, arrow_y: float) -> None:\n\n        # * vertical line (hopefully cross through the RMS plot... but not guarnateed right now)\n        line_height = 6\n        color = \"deeppink\"\n        lines = self.ax.plot(\n            [time_point, time_point],\n            [arrow_y, arrow_y + line_height],\n            color=color,\n            linewidth=1,\n        )\n\n        frames = time_point * self.analysis.fps\n        frames_text = f\"{int(frames)}f\"\n\n        # * time label\n        label = f\"{time_point:.2f}s\\n{frames_text}\"\n        text = self.ax.text(\n            time_point,\n            arrow_y + line_height + 2,\n            label,\n            ha=\"center\",\n            va=\"bottom\",\n            color=color,\n        )\n\n        self.aligned_markers.append(AlignedMarker(lines, text=text))\n\n        self.fig.canvas.draw_idle()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:319-338\n\n\n    def mark_aligned_frame(self, time_point: float, arrow_y: float) -> None:\n\n        # * vertical line (hopefully cross through the RMS plot... but not guarnateed right now)\n        line_height = 6\n        color = \"deeppink\"\n        lines = self.ax.plot(\n            [time_point, time_point],\n            [arrow_y, arrow_y + line_height],\n            color=color,\n            linewidth=1,\n        )\n\n        frames = time_point * self.analysis.fps\n        frames_text = f\"{int(frames)}f\"\n\n        # * time label\n        label = f\"{time_point:.2f}s\\n{frames_text}\"\n        text = self.ax.text(\n\n"
      },{
        "role":"user",
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n            #   - smaller diff values (waters down spikes by spreading them out due to higher sampling rate)\n            #   - noisy compared to stride2\n            # - *** stride2 diff has been STELLAR for decision logic!!!\n            #   - even dropping gate threshold to 0.2 works... it flags smaller/gradual humps (that currently I don't need)\n            # - stride3/4+ lower sampling rate leads to timing slippage\n            #    begins to produce inflated diff values, for my purposes, causing issues with gating too (IIRC)\n            rms_stride2 = gap_rms.stride(2)\n            diff_stride2 = rms_stride2.diff()\n            diff_stride2_gated = diff_stride2.gate()\n\n            # * y limits\n            if plotting:\n                stack_offset = StackedPlotOffset(-2)\n                keep_bottom = plotter.get_y_limits().bottom\n                plotter.ax.set_ylim(bottom=keep_bottom, top=stack_offset.initial_offset)\n                #\n                line_args = {\"color\": \"darkorange\", \"alpha\": 0.7}\n                #\n                diff_stride2.plot(linewidth=1, **line_args, shift=stack_offset.reserve(-7), label_end=f\"stride2 diff\")\n                plot_zero_line(win, shift=stack_offset.same())\n                #\n                # * show gated data b/c I use that for crossovers...\n                #   need to clearly see what is below/above threshold\n                #   signs cuts magnitude... b/c I only need to see 1/0/-1 for crossover logic\n                #   btw no need to first plot gate()... impact of that is obvious from signs(gated)\n                diff_stride2.gate().sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"signs(gate(stride2 diff))\")\n                plot_zero_line(win, shift=stack_offset.same())\n                offset_gated = stack_offset.same()\n                #\n                # * try lower gate thresholds (finds a few more points where subtle direction shifts in overall trend... i.e. bowl/dip on way up hump... I don't need that granularity\n                # FYI OK TO NUKE THIS LINE, was just a brief experiment:\n                diff_stride2.gate(lower=-0.2, upper=0.2).sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"EXPERIMENT: 0.2 gate comparison\")\n                plot_zero_line(win, shift=stack_offset.same())\n                offset_gated_experimental__0_2 = stack_offset.same()\n                #\n                # FYI signs(smooth(diff)) leads to skewing b/c magnitude of ramp-up is extreme and pulls up the apparent crossover point long before that actually happens!\n                #  that's why this is not a good metric for crossover!\n                #  *** instead, gating seems to be better b/c that is a diff way to eliminate noise near zero!\n                #    SO I SHOULD PROBABLY GET RID OF SMOOTHING FOR THE PURPOSES OF FINDING MINIMA ENTIRELY\n                diff_stride2.plot_smooth_signed(stack_offset.reserve(-5), **line_args, label_end=f\"signs(stride2 diff)\")\n                plot_zero_line(win, shift=stack_offset.same())\n\n            # *** crossovers (on stride2, GATED diff)\n            table = Table(show_header=True, header_style=\"bold magenta\", title=\"zero crossovers in rms_stride2\")\n            table.add_column(\"before\\nidx\", justify=\"right\")\n            table.add_column(\"after\\nidx\", justify=\"right\")\n            table.add_column(\"before\\ntime\", justify=\"right\")\n            table.add_column(\"middle\\ntime\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\ntime\", justify=\"right\")\n            table.add_column(\"diff_stride2\\n(after)\", justify=\"right\")\n            table.add_column(\"before\\nhops\", justify=\"right\")\n            table.add_column(\"middle\\nhops\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\nhops\", justify=\"right\")\n\n            def plot_cross_box(cross: CrossoverData, plotter, y_middle: float) -> None:\n                \"\"\"Add a rectangle patch for a single crossover.\"\"\"\n                color = \"mediumaquamarine\" if cross.is_upward() else \"lightcoral\"\n                box_width = cross.after.seconds - cross.before.seconds\n                box_height = 2\n                lower_left_y = y_middle - 1\n                rect = plt.Rectangle(\n                    (cross.before.seconds, lower_left_y),\n                    box_width,\n                    box_height,\n                    edgecolor=color,\n                    facecolor=color,\n                    linewidth=1,\n                    alpha=0.3,\n                )\n                plotter.ax.add_patch(rect)\n\n            def plot_min_max(cross: CrossoverData, plotter, y_middle: float) -> None:\n                plotter.ax.scatter(\n                    cross.min.seconds,\n                    cross.min_rms_value,\n                    # y_middle,\n                    color=\"yellow\",\n                    edgecolor=\"black\",\n                    zorder=5,\n                )\n                <|fim_middle|>\n\n            upward_crossings = []\n            crossovers = build_crossovers(diff_stride2_gated, analysis)\n            for cross in crossovers:\n                # at before/after idx => diff == diff_gated... b/c must be non-zero after gating (IOTW not gated to zero)\n                table.add_row(\n                    str(int(cross.crossover.before_index)),\n                    str(int(cross.crossover.after_index)),\n                    f\"{cross.before.seconds:.3f}s\",\n                    f\"{cross.middle.seconds:.3f}s\",\n                    f\"{cross.after.seconds:.3f}s\",\n                    f\"{cross.after_diff_value:.2f}\",\n                    f\"{cross.before.hops:,}\",\n                    f\"{cross.middle.hops:,}\",\n                    f\"{cross.after.hops:,}\",\n                )\n                if plotting:\n                    plot_cross_box(cross, plotter, offset_gated)\n                    plot_min_max(cross, plotter, offset_gated)\n\n                if cross.is_upward():\n                    upward_crossings.append(cross.crossover)\n                    if plotting:\n                        minima_line = {\"linewidth\": 1, \"alpha\": 0.4, \"zorder\": 0}\n                        plotter.ax.axvline(cross.before.seconds, color=\"teal\", **minima_line).pps = PPS.HOPS_USEFUL\n                        plotter.ax.axvline(cross.middle.seconds, color=\"crimson\", **minima_line)\n                        plotter.ax.axvline(cross.after.seconds, color=\"orangered\", **minima_line).pps = PPS.HOPS_USEFUL\n            rich.print(table)\n\n            crossovers__0_2 = build_crossovers(diff_stride2.gate(lower=-0.2, upper=0.2).sign(), analysis)\n            if plotting:\n                for cross in crossovers__0_2:\n                    plot_cross_box(cross, plotter, offset_gated_experimental__0_2)\n\n            class VirtualGapSegment(DetectedSegment):\n                left_crossover: Crossover | None\n                right_crossover: Crossover | None\n\n            # subsegs = []\n            # left_crossover = None\n            # for c in crossings:\n            #     # TODO ok what should this look like?\n            #     # TODO how to classify here?\n            #     # TODO replace other classification with this!\n            #     s = GapSegment(left_crossover=left_crossover, right_crossover=c)\n            #     subsegs.append(s)\n            #     left_crossover = c\n            # win.gap.subsegs = subsegs\n            win.gap.crossings = crossovers\n            win.gap.upward_crossings = upward_crossings\n\n            detectors: list[BreathingDetector] = [\n                TreatOneMinimaAsSpeech(),\n                InnerSlopeHasSpike(),\n                # MinimumDurationDetector() # TODO\n            ]\n\n            context = GapContext(win, gap_rms, plotting)\n            for detector in detectors:\n                if detector.not_breathing(context):\n                    # If the detector determines this is not breathing, skip further processing\n                    return NOT_BREATHING\n\n            # * is diff(rms) negative until the first crossover? => this is taper\n            #    basically I should move the edit point b/w left_speech and gap ... to the first crossover's corresponding minima\n            start_time = win.gap.start_seconds()\n            start_hops = analysis.to_hops(start_time)\n            first_crossover = crossovers[0]\n            # KEEP IN MIND INDEXES are STRIDE2 => go to time first and back to hop/index for other lookups\n            # end_idx = first_crossover.crossover.before_index  # TODO find minima\n            end_time = diff_stride2_gated.times[first_crossover.crossover.after_index]\n            # TODO MOVE HOPS IN\n            end_hops = analysis.to_hops(end_time)\n            rms = analysis.rms_slice(start_hops, end_hops)\n            plot(rms.times, rms.values, color=\"brown\", linewidth=4)\n            minima_index = np.argmin(rms.values)\n            minima_value = rms.values[minima_index]\n            minima_time = rms.times[minima_index]\n            plot([minima_time, minima_time], [minima_value - 5, minima_value + 5])\n"
      }]
  },
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"                plotter.ax.scatter(\n                    cross.max.seconds,\n                    cross.max_rms_value,\n                    # y_middle,\n                    color=\"cyan\",\n                    edgecolor=\"black\",\n                    zorder=5,\n                )",
    "reasoning_content":"We need to fill code after scatter. Likely plot min marker and annotate. Look at similar code earlier? Search maybe. Probably add plotter.ax.scatter for max? Actually cross.min is minima, maybe also cross.max? But function name plot_min_max suggests both. Probably also plot max. Use cross.max. Implement scatter for max similar."
  },
  "last_sse":{
    "created":1767943580,
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-za2qGSRnzjbI4pQQY7vcugNBUvIoaDAz",
    "object":"chat.completion.chunk",
    "timings":{
      "prompt_n":3333,
      "prompt_ms":377.684,
      "cache_n":0,
      "predicted_ms":588.994,
      "predicted_per_token_ms":4.8677190082645,
      "predicted_per_second":205.43502989844,
      "predicted_n":121,
      "prompt_per_second":8824.8376950043,
      "prompt_per_token_ms":0.11331653165317
    },
    "system_fingerprint":"b7616-18ddaea2a"
  }
}