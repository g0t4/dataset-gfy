{
  "request_body":{
    "options":[],
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/tests/integration_tests.py:\ntest_detect_breathe_before_type\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:253-265\n#     - hump_prominence = hump_max - max(min₁, min₂) > X dB\n#         > X dB (keep in mind frame_len eats away at extremes so would need to adjust X if adjust frame_len)\n#     - hump_width > ~150–300 ms (120dB is smallest I've seen)\n#     - hump_flatness: low variance of slope near the top (breathing humps are rounded, not spiky)\n#\n#       diff_stride2 => nearly linear with slight tilt down across the hump\n#         especially linear for most of the middle of the hump (edges have min spikes)\n#\n#       slope (rate of change) starts higher\n#         => drops to zero\n#         => stays nearly zero for a bit (not always)\n#         => goes negative and increases negative\n\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:151-162\n        # * STEP 2 - check for further taper beyond first/last CP (mins) in the form of waveform humps\n        #\n        # - IOTW min0 => max1 => min2 - this is a candidate hump (if present) for extending left_speech's left_taper_end\n        #        min[-3] => max[-2] => min[-1] - candidate hump (if present) for extending right_speech's right_taper_start (rampup)\n        #\n        #   ** generally speaking the taper is over when minimums bottom out... if a subsequent minimum rises, the taper is over (in my experience)\n        #    - why? b/c a rise in subsequent minimums (critical points) only happens with a material sound source, i.e. typing/breathing/talking...\n        #    - and taper by definition is the trailing sound as you finish a sentence, in which case volume often drops while still speaking\n        #    - and that drop in volume falls below normal speech thresholds... and so we want to detect that at the end of speech and make sure not to cut that off!\n        #    - we want to cut right after the taper stops (or close to it) to avoid clicks\n\n        \n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:93-249\n    def locate(self, c: GapContext):\n        # TODO what to return? NOTE this is NOT just a breathing check\n        crosses, note, reject, win, gap = c.crosses, c.note, c.reject, c.win, c.win.gap\n\n        if win.left_speech is None:\n            return reject(\"no left_speech to taper\")\n\n        if len(crosses) == 1:\n            # PRN this should apply to most detectors/locators\n            win.gap.left_taper_end = crosses[0].critical_point\n            win.gap.right_taper_start = crosses[0].critical_point\n            return note(\"one crossover = speech\")\n\n        # * Step 1 - mark first and last CPs\n        #  - and always treat that segment before/after as taper/rampup\n        #  - gap[start] ➜ min[0] - downward segment\n        #      gap_start.rms > min[0].rms by definition...\n        #      ... b/c gap_start is RMS right when it crosses below speech threshold\n        #      btw (min[0] == first critical point == cp0 == min0)\n        #      this s/b flagged as taper\n        #      => hence, set left_taper_end (where left_speech's taper ends, into the gap)\n        #  - min[-1] ➜ gap[end] - upward segment\n        #      gap_end.rms > min[-1].rms (also by definition, same threshold reason)\n        #      this s/b flagged as rampup (taper)\n        #      => hence, set right_taper_start (rampup start where right_speech ramps up)\n        #         think of reverse taper, or just \"tapering up\"\n        #  * thus every clip at least has taper to first/last critical point\n        #     until I find a case where that doesn't work\n        #     these are local minima critical points\n        #     the reason they work well for taper, is b/c cut points work best at minimums!\n        #        even if not super quiet volume level, mins are good places to slice audio and avoid clicks\n        #        clicks can happen when cutting anywhere but the minimums!\n        #          not always, but often\n        #  upward segment [end of gap from last CP => end of gap\n\n        # * leftmost CP cp[0] (aka min0) assumptions\n        cross0 = crosses[0]\n        cp0 = cross0.critical_point\n        gap_start_rms = c.gap_rms.values[0]\n        if gap_start_rms < cp0.rms:\n            return reject(f\"assumption violated {gap_start_rms=} must be greater than {cp0.rms=} (first critical point s/b a min below gap_start.rms)\")\n        if not cross0.is_local_min():\n            return reject(\"first crossover must contain a local minimum\")\n        # FYI virt_seg[0] would make WAY more sense here...\n\n        # * rightmost CP cp[last] (aka min[last]) assumptions\n        cross_last = crosses[-1]\n        cp_last = cross_last.critical_point\n        gap_end_rms = c.gap_rms.values[-1]\n        if gap_end_rms < cp_last.rms:\n            return reject(f\"assumption violated {gap_end_rms=} must be greater than {cp0.rms=}\")\n        if not cross_last.is_local_min():\n            return reject(\"last crossover must contain a local minimum\")\n\n        # * mark taper\n        gap.left_taper_end = cp0\n        gap.right_taper_start = cp_last\n\n        # * STEP 2 - check for further taper beyond first/last CP (mins) in the form of waveform humps\n        #\n        # - IOTW min0 => max1 => min2 - this is a candidate hump (if present) for extending left_speech's left_taper_end\n        #        min[-3] => max[-2] => min[-1] - candidate hump (if present) for extending right_speech's right_taper_start (rampup)\n        #\n        #   ** generally speaking the taper is over when minimums bottom out... if a subsequent minimum rises, the taper is over (in my experience)\n        #    - why? b/c a rise in subsequent minimums (critical points) only happens with a material sound source, i.e. typing/breathing/talking...\n        #    - and taper by definition is the trailing sound as you finish a sentence, in which case volume often drops while still speaking\n        #    - and that drop in volume falls below normal speech thresholds... and so we want to detect that at the end of speech and make sure not to cut that off!\n        #    - we want to cut right after the taper stops (or close to it) to avoid clicks\n\n        def is_double_hump():\n            return len(crosses) == 5\n\n        def check_for_further_left_taper_hump():\n            if len(crosses) < 5:\n                # FYI 5 minimum so we have two humps\n                # if you think less would work, find real examples and add them as integration tests before modifying the rules here\n                return None\n\n            # also this verifies min/max/min/max/min layout (beyond making sure it has 5+ CPs)\n            at_least_two_humps = cross0.is_local_min() \\\n                and crosses[1].is_local_max() \\\n                and crosses[2].is_local_min() \\\n                and crosses[3].is_local_max() \\\n                and crosses[4].is_local_min()\n            if not at_least_two_humps:\n                return None\n\n            # * verify tapering RMS\n            cross2 = crosses[2]\n            min2 = cross2.min\n            drop_in_rms = cross0.min.rms - min2.rms\n            rich.print(f'  {drop_in_rms=}')\n            minimum_db_drop = 5  # ? find more examples to dial this in\n            if drop_in_rms < minimum_db_drop:\n                # min4@30.7s has a 0.13 lower min2 vs min0, but it is clear\n                # catches case where two humps and middle min is higher than both left/right mins  (think m w/o middle leg going down very far)\n                return None\n            # IDEAS (if/when I encounter prevalent, contradictory examples to the above rules)... here might be some diff rules:\n            # - threshold per unit time? not just absolute\n            # - 2+ humps in taper? only do this if you find real+prevalent examples\n\n            # * extend taper through hump's right min\n            gap.left_taper_end = crosses[2].min\n\n        check_for_further_left_taper_hump()\n\n        def check_for_further_right_taper_hump():\n\n            if len(crosses) < 5:\n                # FYI 5 minimum so we have two humps\n                return None\n            crossM3 = crosses[-3]  # 3rd from last\n            crossM2 = crosses[-2]  # 2nd from last\n            crossM1 = crosses[-1]  # last\n\n            if is_double_hump():\n                note(\"skip further taper search on double humps\")\n                # PRN alternatives: use hump width OR hump height to skip\n                # - minute4@7sec - gap has middle min slightly lower than right_taper_start - but its breathing\n                #   159ms+266ms=425ms total right hump (set max at 100ms or 150ms?)\n                #   40dB height (hump mins to hump max)\n                #   OR can I use the min/max relationship to find out if its up or down?\n                #     i.e. do consecutive max values need to also be descending?\n                # NOTE this skip DOESN'T apply to left taper search b/c left hump is speech:\n                #   min7:2.5s,57s - speech + breathing each (need to keep left hump, gate/mute right)\n                #     min7@29.5s - also speech+breathing but min is too shallow - not recognized on left side\n                #   if needed I can use duration/dB change on left hump decision to apply this\n                return None\n\n            # * must end in min/max/min\n            if not (crossM3.is_local_min() \\\n               and crossM2.is_local_max() \\\n               and crossM1.is_local_min()):\n                return None\n\n            # * verify rising RMS\n            # TODO would be nice to have hump.drop_db or hump.rise_db (b/w mins)\n            rise_in_rms = crossM1.min.rms - crossM3.min.rms\n            rich.print(f'  right rampup (reverse taper) {rise_in_rms=}')\n\n            if rise_in_rms <= 0:\n                # ?? non-zero threshold? first find examples (i.e. one where rise is almost level but dips by say 0.5dB) and I still want it to be flagged as part of ramp up\n                return None\n\n            # * extend taper through hump's left min\n            gap.right_taper_start = crossM3.min\n\n        check_for_further_right_taper_hump()\n\n        # * look for breathing hump after taper hump - in double hump gaps only\n        # TODO! look for breathe hump after taper (minute 7 start and end have these)\n        #   on two hump segments only\n        #   and when minimum between is lower than both outer mins (first/last)\n        #   * asymmetry on second hump duration => 200+ ms (cap it? probably only if I find an example of smth longer that is flagged as breathing and that causes an issue)\n        #      use short double hump speech gap in minute7 to set a minimum on the right hump duration... in that case both sides were short and about same duration\n        #\n        #   USE INTEGRATION TEST!\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:238-257\n            gap.right_taper_start = crossM3.min\n\n        check_for_further_right_taper_hump()\n\n        # * look for breathing hump after taper hump - in double hump gaps only\n        # TODO! look for breathe hump after taper (minute 7 start and end have these)\n        #   on two hump segments only\n        #   and when minimum between is lower than both outer mins (first/last)\n        #   * asymmetry on second hump duration => 200+ ms (cap it? probably only if I find an example of smth longer that is flagged as breathing and that causes an issue)\n        #      use short double hump speech gap in minute7 to set a minimum on the right hump duration... in that case both sides were short and about same duration\n        #\n        #   USE INTEGRATION TEST!\n\n# NOTES\n# - Let hump_max = max(envelope[min₁ : min₂])\n#     - hump_prominence = hump_max - max(min₁, min₂) > X dB\n#         > X dB (keep in mind frame_len eats away at extremes so would need to adjust X if adjust frame_len)\n#     - hump_width > ~150–300 ms (120dB is smallest I've seen)\n#     - hump_flatness: low variance of slope near the top (breathing humps are rounded, not spiky)\n#\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:91-249\nclass LeftSpeechTaper_WithOptionalBreathe_Locator():\n\n    def locate(self, c: GapContext):\n        # TODO what to return? NOTE this is NOT just a breathing check\n        crosses, note, reject, win, gap = c.crosses, c.note, c.reject, c.win, c.win.gap\n\n        if win.left_speech is None:\n            return reject(\"no left_speech to taper\")\n\n        if len(crosses) == 1:\n            # PRN this should apply to most detectors/locators\n            win.gap.left_taper_end = crosses[0].critical_point\n            win.gap.right_taper_start = crosses[0].critical_point\n            return note(\"one crossover = speech\")\n\n        # * Step 1 - mark first and last CPs\n        #  - and always treat that segment before/after as taper/rampup\n        #  - gap[start] ➜ min[0] - downward segment\n        #      gap_start.rms > min[0].rms by definition...\n        #      ... b/c gap_start is RMS right when it crosses below speech threshold\n        #      btw (min[0] == first critical point == cp0 == min0)\n        #      this s/b flagged as taper\n        #      => hence, set left_taper_end (where left_speech's taper ends, into the gap)\n        #  - min[-1] ➜ gap[end] - upward segment\n        #      gap_end.rms > min[-1].rms (also by definition, same threshold reason)\n        #      this s/b flagged as rampup (taper)\n        #      => hence, set right_taper_start (rampup start where right_speech ramps up)\n        #         think of reverse taper, or just \"tapering up\"\n        #  * thus every clip at least has taper to first/last critical point\n        #     until I find a case where that doesn't work\n        #     these are local minima critical points\n        #     the reason they work well for taper, is b/c cut points work best at minimums!\n        #        even if not super quiet volume level, mins are good places to slice audio and avoid clicks\n        #        clicks can happen when cutting anywhere but the minimums!\n        #          not always, but often\n        #  upward segment [end of gap from last CP => end of gap\n\n        # * leftmost CP cp[0] (aka min0) assumptions\n        cross0 = crosses[0]\n        cp0 = cross0.critical_point\n        gap_start_rms = c.gap_rms.values[0]\n        if gap_start_rms < cp0.rms:\n            return reject(f\"assumption violated {gap_start_rms=} must be greater than {cp0.rms=} (first critical point s/b a min below gap_start.rms)\")\n        if not cross0.is_local_min():\n            return reject(\"first crossover must contain a local minimum\")\n        # FYI virt_seg[0] would make WAY more sense here...\n\n        # * rightmost CP cp[last] (aka min[last]) assumptions\n        cross_last = crosses[-1]\n        cp_last = cross_last.critical_point\n        gap_end_rms = c.gap_rms.values[-1]\n        if gap_end_rms < cp_last.rms:\n            return reject(f\"assumption violated {gap_end_rms=} must be greater than {cp0.rms=}\")\n        if not cross_last.is_local_min():\n            return reject(\"last crossover must contain a local minimum\")\n\n        # * mark taper\n        gap.left_taper_end = cp0\n        gap.right_taper_start = cp_last\n\n        # * STEP 2 - check for further taper beyond first/last CP (mins) in the form of waveform humps\n        #\n        # - IOTW min0 => max1 => min2 - this is a candidate hump (if present) for extending left_speech's left_taper_end\n        #        min[-3] => max[-2] => min[-1] - candidate hump (if present) for extending right_speech's right_taper_start (rampup)\n        #\n        #   ** generally speaking the taper is over when minimums bottom out... if a subsequent minimum rises, the taper is over (in my experience)\n        #    - why? b/c a rise in subsequent minimums (critical points) only happens with a material sound source, i.e. typing/breathing/talking...\n        #    - and taper by definition is the trailing sound as you finish a sentence, in which case volume often drops while still speaking\n        #    - and that drop in volume falls below normal speech thresholds... and so we want to detect that at the end of speech and make sure not to cut that off!\n        #    - we want to cut right after the taper stops (or close to it) to avoid clicks\n\n        def is_double_hump():\n            return len(crosses) == 5\n\n        def check_for_further_left_taper_hump():\n            if len(crosses) < 5:\n                # FYI 5 minimum so we have two humps\n                # if you think less would work, find real examples and add them as integration tests before modifying the rules here\n                return None\n\n            # also this verifies min/max/min/max/min layout (beyond making sure it has 5+ CPs)\n            at_least_two_humps = cross0.is_local_min() \\\n                and crosses[1].is_local_max() \\\n                and crosses[2].is_local_min() \\\n                and crosses[3].is_local_max() \\\n                and crosses[4].is_local_min()\n            if not at_least_two_humps:\n                return None\n\n            # * verify tapering RMS\n            cross2 = crosses[2]\n            min2 = cross2.min\n            drop_in_rms = cross0.min.rms - min2.rms\n            rich.print(f'  {drop_in_rms=}')\n            minimum_db_drop = 5  # ? find more examples to dial this in\n            if drop_in_rms < minimum_db_drop:\n                # min4@30.7s has a 0.13 lower min2 vs min0, but it is clear\n                # catches case where two humps and middle min is higher than both left/right mins  (think m w/o middle leg going down very far)\n                return None\n            # IDEAS (if/when I encounter prevalent, contradictory examples to the above rules)... here might be some diff rules:\n            # - threshold per unit time? not just absolute\n            # - 2+ humps in taper? only do this if you find real+prevalent examples\n\n            # * extend taper through hump's right min\n            gap.left_taper_end = crosses[2].min\n\n        check_for_further_left_taper_hump()\n\n        def check_for_further_right_taper_hump():\n\n            if len(crosses) < 5:\n                # FYI 5 minimum so we have two humps\n                return None\n            crossM3 = crosses[-3]  # 3rd from last\n            crossM2 = crosses[-2]  # 2nd from last\n            crossM1 = crosses[-1]  # last\n\n            if is_double_hump():\n                note(\"skip further taper search on double humps\")\n                # PRN alternatives: use hump width OR hump height to skip\n                # - minute4@7sec - gap has middle min slightly lower than right_taper_start - but its breathing\n                #   159ms+266ms=425ms total right hump (set max at 100ms or 150ms?)\n                #   40dB height (hump mins to hump max)\n                #   OR can I use the min/max relationship to find out if its up or down?\n                #     i.e. do consecutive max values need to also be descending?\n                # NOTE this skip DOESN'T apply to left taper search b/c left hump is speech:\n                #   min7:2.5s,57s - speech + breathing each (need to keep left hump, gate/mute right)\n                #     min7@29.5s - also speech+breathing but min is too shallow - not recognized on left side\n                #   if needed I can use duration/dB change on left hump decision to apply this\n                return None\n\n            # * must end in min/max/min\n            if not (crossM3.is_local_min() \\\n               and crossM2.is_local_max() \\\n               and crossM1.is_local_min()):\n                return None\n\n            # * verify rising RMS\n            # TODO would be nice to have hump.drop_db or hump.rise_db (b/w mins)\n            rise_in_rms = crossM1.min.rms - crossM3.min.rms\n            rich.print(f'  right rampup (reverse taper) {rise_in_rms=}')\n\n            if rise_in_rms <= 0:\n                # ?? non-zero threshold? first find examples (i.e. one where rise is almost level but dips by say 0.5dB) and I still want it to be flagged as part of ramp up\n                return None\n\n            # * extend taper through hump's left min\n            gap.right_taper_start = crossM3.min\n\n        check_for_further_right_taper_hump()\n\n        # * look for breathing hump after taper hump - in double hump gaps only\n        # TODO! look for breathe hump after taper (minute 7 start and end have these)\n        #   on two hump segments only\n        #   and when minimum between is lower than both outer mins (first/last)\n        #   * asymmetry on second hump duration => 200+ ms (cap it? probably only if I find an example of smth longer that is flagged as breathing and that causes an issue)\n        #      use short double hump speech gap in minute7 to set a minimum on the right hump duration... in that case both sides were short and about same duration\n        #\n        #   USE INTEGRATION TEST!\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/tests/integration_tests.py\n        # I need to cut long pauses, and that can result in middle of the rampup cuts\n        # so I need taper detection, fortunately it is eays peasy!\n        #\n        # unused mins:\n        # | max3:30.1516s -49.6630dB | min4:30.2271s -75.0830dB | max5:30.3062s -46.1619dB | min6:30.3276s -61.3436dB | max7:30.3672s -43.6780dB\n        #\n        win = analysis4().window_at_seconds(30.7)\n        #\n        # * left_taper_end (first hump) - TINY DROP in RMS does not qualify as taper continuing\n        # min0:30.0224s -77.6650dB | max1:30.0646s -50.7167dB | min2:30.1068s -77.8038dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(30.0224, 0.001)\n        #   min2 is a smidge lower, 0.14528656 lower\n        hump1_db_drop = win.gap.crossovers[0].min.rms - win.gap.crossovers[2].min.rms  # FYI would be nice to have a cleaner way to work with this, i.e. humps[0].db_drop\n        assert hump1_db_drop == pytest.approx(0.1388, 0.01)  # (santiy check only)\n        #\n        # * right_taper_start (last hump)\n        #  I interpret the taper as including that keystroke right at end of gap...\n        #  it meets my definition of descending mins (or ascending for right_taper_start)\n        # | min8:30.6161s -92.9456dB | max9:30.6776s -32.2081dB | min10:30.7276s -48.0868dB\n        humplast_db_rise = win.gap.crossovers[-1].min.rms - win.gap.crossovers[-3].min.rms\n        rich.print(f'{win.gap.crossovers[-1].min.rms=}')\n        rich.print(f'{win.gap.crossovers[-3].min.rms=}')\n        assert humplast_db_rise == pytest.approx(44.8568, 0.001)  # -48.0868--92.9456 (santiy check only)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(30.6161, 0.001)\n        # TODO pullback at least 2 frames is goal, which is doable if you do right reverse taper (rampup)\n        #  - cut long pause resulted in 2 frames into the typing noise or w/e at start of rampup on right side\n        #  - it sounds fine b/c it is not speaking noise\n        # keep going down until min(next, inner direction) has > rms_db\n        # in this case it drops to -90smth after 1 hump (back)\n\n    def test_one_dip_marks_as_speech(self):\n        # mark as taper by setting taper points\n\n        def is_single_dip_all_taper(analysis, same_min):\n            window = analysis.window_at_seconds(same_min)\n            assert len(window.gap.crossovers) == 1\n            same_min = pytest.approx(same_min, 0.001)\n            assert window.gap.left_taper_end\n            assert window.gap.right_taper_start\n            assert window.gap.left_taper_end.time.seconds == same_min\n            assert window.gap.right_taper_start.time.seconds == same_min\n            # PRN do I need this?\n            # assert not win.breathing  # speech is implicit in taper currently, dont worry about marking breathing?\n\n        # * minute 3\n        # min0:2.1594s -88.7477dB\n        is_single_dip_all_taper(analysis3(), 2.1594)\n\n        # * minute4 @ 8sec\n        # min0:8.0453s -75.2313dB\n        is_single_dip_all_taper(analysis4(), 8.0453)\n\n        # * minute4 @ 35.88sec\n        # min0:35.8875s -83.3112dB\n        is_single_dip_all_taper(analysis4(), 35.8875)\n\n        # * minute 5\n        # min0:12.9932s -77.7741dB\n        is_single_dip_all_taper(analysis5(), 12.9932)\n        # min0:42.9948s -92.7182dB\n        is_single_dip_all_taper(analysis5(), 42.9948)\n\n        # * minute7 @ 12.9sec\n        # assert len(win11_2s.gap.subsegs) == 2\n        is_single_dip_all_taper(analysis7(), 11.96)\n\ndef only_single_breathing_hump(analysis, left, right):\n    window = analysis.window_at_seconds(left)\n    assert len(window.gap.crossovers) == 3\n    assert window.gap.left_taper_end\n    assert window.gap.right_taper_start\n    assert window.gap.left_taper_end.time.seconds == pytest.approx(left, 0.001)\n    assert window.gap.right_taper_start.time.seconds == pytest.approx(right, 0.001)\n    assert window.breathing\n\nclass TestBreathThenType:\n\n    def test_detect_breathe_before_type():\n        # min0:1.3224s -73.4771dB | max1:1.4750s -48.4294dB | min2:1.6818s -82.7256dB | max3:1.7276s -52.8202dB | min4:1.8307s -88.9060dB | max5:1.8792s -73.4860dB | min6:1.8911s -74.9349dB | max7:1.9667s -52.2062dB | min8:2.0292s -67.1965dB | max9:2.0677s -59.7394dB | min10:2.1500s -82.8229dB | max11:2.1807s -76.9041dB | min12:2.2552s -91.7403dB | max13:2.3516s -67.2748dB | min14:2.3740s -74.0532dB\n        # hump is how you find this...\n        # 1. so, if > 5 material points( maybe say like 8+ ... based on examples)\n        # 2. look at taper then for the rounded hump of breathing (very flat near zero slope for 100-150+ms)\n        # IIRC this is only example so far...\n        analysis6().window_at_seconds(1.4750)\n\n    def test_does_not_see_taper_t_as_breathe():\n        # right after breathe+type at 6.33s there is a taper_t that looks similar (no leveled off hump, but does show hill if you will)\n        # min0:6.3281s -45.0586dB | max1:6.3708s -33.4615dB | min2:6.4818s -75.7551dB | max3:6.5276s -47.2901dB | min4:6.6953s -93.7528dB | max5:6.7802s -41.8621dB | min6:6.8005s -49.8119dB | max7:6.8401s -43.3520dB | min8:6.8849s -49.7567dB | max9:6.9297s -41.3089dB | min10:7.0203s -55.3130dB | max11:7.0625s -45.5034dB | min12:7.0885s -58.8977dB | max13:7.1297s -42.8595dB | min14:7.1917s -53.3302dB | max15:7.2333s -48.8380dB | min16:7.2380s -52.4981dB | max17:7.2677s -46.8598dB | min18:7.2922s -51.6695dB | max19:7.3208s -42.6658dB | min20:7.3495s -50.4188dB | max21:7.3802s -45.4200dB | min22:7.4208s -58.6177dB | max23:7.4635s -46.8691dB | min24:7.5062s -56.5632dB | max25:7.5490s -49.5269dB | min26:7.5536s -51.3327dB | max27:7.5828s -46.6573dB | min28:7.6688s -67.6336dB\n        #\n        analysis6().window_at_seconds(6.33)\n\nclass TestSingleBreathingHump:\n\n    def test_backtoback_critical_points_skipped(self):\n        # cp2/cp3 are inconsequential, should be skipped, back to back (3 hops apart, < 1dB difference in y-value)\n        #  I could gate a little bit higher, or just skip these when it's obvious from x/y deltas\n        #\n        # min0:54.3500s -57.7805dB | max1:54.4312s -45.5440dB | min2:54.7208s -77.6351dB | max3:54.7224s -76.9973dB | min4:54.7724s -87.6577dB\n        # really is just 3 critical points... two are local tiny minimas that slipped past my gate threshold...\n        # but it is easy to see min3-min2 = 0.0016  that is too small to matter\n        #   plus dB values diff -76.9973 - -77.6351dB = 0.6378dB\n        #    inconsequentially tiny, that is not a hump of any material magnitude!\n        #     so lets put criteria together to skip these (both time is super short and dB under say 5dB (or 1 for now for this case and add more to threshold later if new cases arise?)\n        only_single_breathing_hump(analysis5(), 54.3500, 54.7724)\n        # TODO anything else for the hump that had moot cps but was really just simple breathing (minute 5)?? run and check this?\n\n    def test_minute6_single_hump_breath_missing_left_critical_point(self):\n        # min0:11.4995s -60.5834dB\n        # TODO missing critical point on left side of hump, WTF?!\n        # and the hump is CLEARLY visible!\n        # I should be able to detect missing CP from just half of it... \n        pass\n\n    def test_minute6_single_hump_breath(self):\n        # min0:13.9156s -76.4758dB | max1:14.1047s -43.4169dB | min2:14.3000s -79.7663dB\n        <|fim_middle|>\n\n\n\n\n    def test_minute7_single_hump_breath(self):\n        assert len(analysis7().windows) == 20\n\n        # * normal breathing\n        only_single_breathing_hump(analysis7(), 6.91, 7.16)\n        only_single_breathing_hump(analysis7(), 11.03, 11.33)\n        only_single_breathing_hump(analysis7(), 13.61, 13.93)\n        only_single_breathing_hump(analysis7(), 15.18, 15.40)\n        only_single_breathing_hump(analysis7(), 18.49, 18.63)\n        only_single_breathing_hump(analysis7(), 21.09, 21.33)\n        only_single_breathing_hump(analysis7(), 23.70, 23.86)\n        only_single_breathing_hump(analysis7(), 27.05, 27.32)\n        only_single_breathing_hump(analysis7(), 29.22, 29.51)\n        # FYI this one has blue vertical lines at top of hump, if use those lines, then use this test to eliminate when slope == 0\n        only_single_breathing_hump(analysis7(), 32.58, 32.83)\n        only_single_breathing_hump(analysis7(), 34.43, 34.65)\n        # BREATHING (non-standard?)\n        only_single_breathing_hump(analysis7(), 37.98, 38.35)\n        only_single_breathing_hump(analysis7(), 41.91, 42.24)\n        only_single_breathing_hump(analysis7(), 52.99, 53.33)\n        only_single_breathing_hump(analysis7(), 55.20, 55.44)\n\n        return  # TODO! below?\n        # * not breathing => word is \"at\"\n        # * PATTERN: lazy_middle_m (middle leg is barely drawn, barely dips)\n        #    think breathing but w/ a hump that dips in the middle\n        #    140ms side to side of full m\n        #    ~40ms to max of first hump => 30ms to middle leg's lazy dip\n        #      mirror on way out\n        win43s = analysis7().windows[15]\n        assert win43s.gap.crossovers\n        # assert not win43s.breathing # TODO GET WORKING BY REJECTING 3 MINIMA with this little duration within a given subset (between minima)\n        only_single_breathing_hump(win43s, 43.69, 43.83)\n\n        # * typing fingers waveform\n        win46s = analysis7().windows[16]\n        assert not win46s.breathing\n        # min0:46.3167s -47.2853dB | max1:46.3505s -39.1514dB | min2:46.6266s -94.3020dB | max3:47.1578s -75.2083dB | min4:47.2547s -92.1545dB | max5:47.2995s -64.9374dB\n        # | min6:47.3948s -86.9671dB | max7:47.4391s -70.0614dB | min8:47.4510s -73.0575dB | max9:47.4568s -71.3409dB | min10:47.5854s -92.4671dB | max11:47.6906s -69.5855dB\n        # | min12:47.9583s -94.3020dB | max13:48.0708s -60.1251dB | min14:48.0849s -65.0497dB | max15:48.1755s -43.5629dB | min16:48.5620s -78.9731dB\n```\n\n## Reminders about the cursor line:\nText before cursor: `        `\nText before cursor is all whitespace (do not ignore this)"
      }],
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "raw":false,
    "model":"gpt-oss:120b",
    "max_tokens":4096,
    "temperature":1,
    "stream":true,
    "top_p":1
  },
  "response_message":{
    "role":"assistant",
    "content":"only_single_breathing_hump(analysis6(), 13.9156, 14.3000)",
    "finish_reason":"stop",
    "reasoning_content":"We need to insert code for test_minute6_single_hump_breath. Likely similar to other tests: call only_single_breathing_hump. Probably:\n\nonly_single_breathing_hump(analysis6(), 13.9156, 14.3000)\n\nCheck pattern: left is min time, right is min after hump? In other calls left/right are start and end of hump. For this hump min0 at 13.9156, max1 at 14.1047, min2 at 14.3000. So left =13.9156, right=14.3000. Use analysis6(). So code:\n\nonly_single_breathing_hump(analysis6(), 13.9156, 14.3000)\n\nAdd indentation 8 spaces? The line is inside method with 8 spaces before cursor. So insert that line."
  },
  "last_sse":{
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "timings":{
      "cache_n":0,
      "prompt_per_second":10100.999543239,
      "prompt_n":9664,
      "predicted_per_second":217.52101263147,
      "prompt_ms":956.737,
      "prompt_per_token_ms":0.099000103476821,
      "predicted_n":214,
      "predicted_per_token_ms":4.5972570093458,
      "predicted_ms":983.813
    },
    "system_fingerprint":"b7785-1c7cf94b2",
    "created":1769571723,
    "object":"chat.completion.chunk",
    "id":"chatcmpl-GS0ZfL1Ln4Qdgy518qbVXIu4REJ9XVSo",
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }]
  }
}