{
  "last_sse":{
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7616-18ddaea2a",
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "id":"chatcmpl-PYkuSS6BM7SY0ohXmh5LiUFEIS5leSo3",
    "created":1767943114,
    "timings":{
      "prompt_per_token_ms":0.12252775941837,
      "predicted_ms":438.061,
      "predicted_per_token_ms":4.9779659090909,
      "predicted_per_second":200.88526483755,
      "predicted_n":88,
      "prompt_per_second":8161.4158681012,
      "prompt_ms":370.769,
      "prompt_n":3026,
      "cache_n":0
    },
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"cross.is_upward()",
    "reasoning_content":"We need to fill condition: color = \"mediumaquamarine\" if <|fim_middle|> else \"lightcoral\". Likely based on cross.is_upward()? In plot_cross_box called for each cross; they want different color for upward vs downward. So condition: cross.is_upward(). Return bool. Thus code: cross.is_upward()."
  },
  "request_body":{
    "raw":false,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:530-545\n                for hop in range(first_hop, last_hop + 1):\n                    hop_sec = hop * hop_interval\n                    color = \"#B0B0B0\" if hop % 2 == 0 else \"#8FBBD9\"\n                    line = self.ax.axvline(hop_sec, color=color, linewidth=0.4, alpha=0.2, zorder=-1)\n                    hop_items.append(line)\n                    # much of my testing involves timing w/in a given gap, useful to see this at a glance\n                    #  otherwise I'd have to hover over the hop line to find this, one by one\n                    if cur.seconds_wide < 0.09:\n                        num_hops_past_gap_start = hop - gap_start_hop\n                        label = f\"{int(num_hops_past_gap_start):,}\"\n                        # y value places it in the plot, so it is closer to plot data for counting\n                        hop_txt = self.ax.text(hop_sec, -80, label, \\\n                                               ha='center', va='bottom', size='small', rotation=90)\n                        hop_items.append(hop_txt)\n\n            \n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:88-93\ndef plot_color(self) -> str:\n        return {\n            SegmentLabel.SILENCE: \"cornflowerblue\",\n            SegmentLabel.BREATH: \"magenta\",\n            SegmentLabel.SPEECH: \"red\",\n        }.get(self.label, \"green\")\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/time_series.py:26-29\ndef plot_smooth_signed(self, shift, color, label_end, **kwargs):\n        self.smooth().plot(color=color, linewidth=1, shift=shift, label_end=label_end, **kwargs)\n        # FYI smooth needs to clearly stand out, it is a good guide for quickly spotting material diff changes\n        self.smooth().sign().plot(color=\"#FFFFFF\", linewidth=1.4, shift=shift, alpha=0.9)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:63-70\ndef __str__(self, no_color=False) -> str:\n\n        label = self.label.value.lower()\n        if not no_color:\n            label = colorize(self.label.value.lower(), self.plot_color())\n\n        # 4 for left padding id\n        return f\"{self.id:4} {label}: [{self.start_seconds:.3f}->{self.end_seconds:.3f}) {self.duration_seconds:.3f}s {self.rms_summary}\"\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/ranges.py:52-54\n\n\n# PRN how much of this ContentRange model do I really need? review later\n\n"
      },{
        "role":"user",
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n    def same(self) -> float:\n        return self.current_offset\n\ndef mark_breathing(analysis: AudioAnalysisResult, plotter: SegmentPlotter | None = None):\n    plotting = plotter is not None\n    if plotting:\n        clear()\n        breathing_state.set_plotter(plotter)\n\n    for win in analysis.windows:\n        win.breathing = None  # reset just in case was set elsewhere?\n\n        assert win.first_min and win.last_min\n\n        console.print(f\"gap: {seconds_to_timecode_markup(win.gap.start_seconds(), fps=analysis.fps)} => \"\n                      f\"{seconds_to_timecode_markup(win.gap.end_seconds(), fps=analysis.fps)}\", highlight=False)\n\n        gap_rms = analysis.rms_slice_for_gap(win)\n        NOT_BREATHING = True\n\n        def analyze_rms_stride2():\n\n            # strides:\n            # - stride1 diff (no stride)\n            #   - smaller diff values (waters down spikes by spreading them out due to higher sampling rate)\n            #   - noisy compared to stride2\n            # - *** stride2 diff has been STELLAR for decision logic!!!\n            #   - even dropping gate threshold to 0.2 works... it flags smaller/gradual humps (that currently I don't need)\n            # - stride3/4+ lower sampling rate leads to timing slippage\n            #    begins to produce inflated diff values, for my purposes, causing issues with gating too (IIRC)\n            rms_stride2 = gap_rms.stride(2)\n            diff_stride2 = rms_stride2.diff()\n            diff_stride2_gated = diff_stride2.gate()\n\n            # * y limits\n            if plotting:\n                stack_offset = StackedPlotOffset(-2)\n                keep_bottom = plotter.get_y_limits().bottom\n                plotter.ax.set_ylim(bottom=keep_bottom, top=stack_offset.initial_offset)\n                #\n                line_args = {\"color\": \"darkorange\", \"alpha\": 0.7}\n                #\n                diff_stride2.plot(linewidth=1, **line_args, shift=stack_offset.reserve(-7), label_end=f\"stride2 diff\")\n                plot_zero_line(win, shift=stack_offset.same())\n                #\n                # * show gated data b/c I use that for crossovers...\n                #   need to clearly see what is below/above threshold\n                #   signs cuts magnitude... b/c I only need to see 1/0/-1 for crossover logic\n                #   btw no need to first plot gate()... impact of that is obvious from signs(gated)\n                diff_stride2.gate().sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"signs(gate(stride2 diff))\")\n                plot_zero_line(win, shift=stack_offset.same())\n                offset_gated = stack_offset.same()\n                #\n                # * try lower gate thresholds (finds a few more points where subtle direction shifts in overall trend... i.e. bowl/dip on way up hump... I don't need that granularity\n                # FYI OK TO NUKE THIS LINE, was just a brief experiment:\n                diff_stride2.gate(lower=-0.2, upper=0.2).sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"EXPERIMENT: 0.2 gate comparison\")\n                plot_zero_line(win, shift=stack_offset.same())\n                offset_gated_experimental__0_2 = stack_offset.same()\n                #\n                # FYI signs(smooth(diff)) leads to skewing b/c magnitude of ramp-up is extreme and pulls up the apparent crossover point long before that actually happens!\n                #  that's why this is not a good metric for crossover!\n                #  *** instead, gating seems to be better b/c that is a diff way to eliminate noise near zero!\n                #    SO I SHOULD PROBABLY GET RID OF SMOOTHING FOR THE PURPOSES OF FINDING MINIMA ENTIRELY\n                diff_stride2.plot_smooth_signed(stack_offset.reserve(-5), **line_args, label_end=f\"signs(stride2 diff)\")\n                plot_zero_line(win, shift=stack_offset.same())\n\n            # *** crossovers (on stride2, GATED diff)\n            table = Table(show_header=True, header_style=\"bold magenta\", title=\"zero crossovers in rms_stride2\")\n            table.add_column(\"before\\nidx\", justify=\"right\")\n            table.add_column(\"after\\nidx\", justify=\"right\")\n            table.add_column(\"before\\ntime\", justify=\"right\")\n            table.add_column(\"middle\\ntime\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\ntime\", justify=\"right\")\n            table.add_column(\"diff_stride2\\n(after)\", justify=\"right\")\n            table.add_column(\"before\\nhops\", justify=\"right\")\n            table.add_column(\"middle\\nhops\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\nhops\", justify=\"right\")\n\n            def plot_cross_box(cross: CrossoverData, plotter, y_middle: float) -> None:\n                \"\"\"Add a rectangle patch for a single crossover.\"\"\"\n                color = \"mediumaquamarine\" if <|fim_middle|> else \"lightcoral\"\n                box_width = cross.after.seconds - cross.before.seconds\n                box_height = 2\n                lower_left_y = y_middle - 1\n                rect = plt.Rectangle(\n                    (cross.before.seconds, lower_left_y),\n                    box_width,\n                    box_height,\n                    edgecolor=color,\n                    facecolor=color,\n                    linewidth=1,\n                    alpha=0.3,\n                )\n                plotter.ax.add_patch(rect)\n\n            def plot_min_max(cross: CrossoverData, plotter, y_middle: float) -> None:\n                plotter.ax.scatter(\n                    cross.min.seconds,\n                    # cross.min.value,\n                    y_middle,\n                    color=\"yellow\",\n                    edgecolor=\"black\",\n                    zorder=5,\n                )\n\n            upward_crossings = []\n            crossovers = build_crossovers(diff_stride2_gated, analysis)\n            for cross in crossovers:\n                # at before/after idx => diff == diff_gated... b/c must be non-zero after gating (IOTW not gated to zero)\n                table.add_row(\n                    str(int(cross.crossover.before_index)),\n                    str(int(cross.crossover.after_index)),\n                    f\"{cross.before.seconds:.3f}s\",\n                    f\"{cross.middle.seconds:.3f}s\",\n                    f\"{cross.after.seconds:.3f}s\",\n                    f\"{cross.after_diff_value:.2f}\",\n                    f\"{cross.before.hops:,}\",\n                    f\"{cross.middle.hops:,}\",\n                    f\"{cross.after.hops:,}\",\n                )\n                if plotting:\n                    plot_cross_box(cross, plotter, offset_gated)\n                    plot_min_max(cross, plotter, offset_gated)\n\n                if cross.is_upward():\n                    upward_crossings.append(cross.crossover)\n                    if plotting:\n                        minima_line = {\"linewidth\": 1, \"alpha\": 0.4, \"zorder\": 0}\n                        plotter.ax.axvline(cross.before.seconds, color=\"teal\", **minima_line).pps = PPS.HOPS_USEFUL\n                        plotter.ax.axvline(cross.middle.seconds, color=\"crimson\", **minima_line)\n                        plotter.ax.axvline(cross.after.seconds, color=\"orangered\", **minima_line).pps = PPS.HOPS_USEFUL\n            rich.print(table)\n\n            crossovers__0_2 = build_crossovers(diff_stride2.gate(lower=-0.2, upper=0.2).sign(), analysis)\n            if plotting:\n                for cross in crossovers__0_2:\n                    plot_cross_box(cross, plotter, offset_gated_experimental__0_2)\n\n            class VirtualGapSegment(DetectedSegment):\n                left_crossover: Crossover | None\n                right_crossover: Crossover | None\n\n            # subsegs = []\n            # left_crossover = None\n            # for c in crossings:\n            #     # TODO ok what should this look like?\n            #     # TODO how to classify here?\n            #     # TODO replace other classification with this!\n            #     s = GapSegment(left_crossover=left_crossover, right_crossover=c)\n            #     subsegs.append(s)\n            #     left_crossover = c\n            # win.gap.subsegs = subsegs\n            win.gap.crossings = crossovers\n            win.gap.upward_crossings = upward_crossings\n\n            detectors: list[BreathingDetector] = [\n                TreatOneMinimaAsSpeech(),\n                InnerSlopeHasSpike(),\n                # MinimumDurationDetector() # TODO\n            ]\n"
      }],
    "model":"gpt-oss:120b",
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "max_tokens":4096,
    "top_p":1,
    "stream":true,
    "options":[],
    "temperature":1
  }
}