{
  "request_body":{
    "max_tokens":8192,
    "options":[],
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks (copy to clipboard):\n```fish/load_last_interactive_only/pythons/av/dropped_frames.py\n    rich.print(f'{timestamps=}')\n```\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:182-229\ndef find_missing_frames(\n    timestamps: NDArray[np.float64],\n    fps: float,\n    duration_frames: int,\n) -> tuple[list[float], list[float]]:\n    # PRN read r_frame_rate instead of throw/hardcode this\n    frame_numbers = np.array(timestamps) * fps\n    extra_frames = []\n    missing_frames = []\n    last_int: int = -1  # thus 0 is the next frame to find\n    # print()\n    for _cur in frame_numbers:\n\n        # * anything before/after expected frames => extras\n        if _cur >= duration_frames:\n            # add all frames past duration_frames as extras\n            # BTW duration_frames is NOT inclusive b/c 0 is first frame\n            extra_frames.append(_cur)\n            continue\n        if _cur < 0:\n            # everything below zero is always extra, and should never happen b/c I test for start_time == 0\n            extra_frames.append(_cur)\n            continue\n\n        # * any timestamp not on a frame exactly (i.e. 2.000 or 3.000, after rounding 3rd digit) => extras (not an exact frame)\n        #    so 2.105 => not on a frame boundary, mark as extra (b/w expected video frames)\n        cur_is_on_a_frame = np.isclose(_cur % 1, 0, atol=1e-3)\n        if not cur_is_on_a_frame:\n            extra_frames.append(_cur)\n            # do not increment last until hit an exact frame at which time will add all missing since last frame\n            continue\n\n        # * cur is a frame exactly (close test above means its on a frame => so round any error away and integer it)\n        cur_int: int = int(round(_cur))\n        diff = cur_int - last_int\n        if diff > 1:\n            # * add missing frames since last\n            _missing_since_last = np.arange(last_int + 1, cur_int)\n            # rich.print(f'{_missing_since_last=}')\n            missing_frames.extend(_missing_since_last)\n\n        last_int = cur_int\n\n    # * missing frames after last frame:\n    if last_int < duration_frames:\n        missing_frames.extend(np.arange(last_int + 1, duration_frames))\n\n    return [float(m) for m in missing_frames], [float(e) for e in extra_frames]\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:77-83\ndef warn_if_unexpected(data: dict, key: str, expected: str | int | float, convert: Callable[[Any], Any] | None = None):\n    actual = data.get(key)\n    if convert is not None:\n        actual = convert(actual)\n    if actual != expected:\n        rich.inspect(actual)\n        rich.print(f\"WARNING: {key} is not {expected}, should be fine but just a heads up: {actual}\")\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:68-75\ndef throw_if_unexpected(data: dict, key: str, expected: str | int | float, convert: Callable[[Any], Any] | None = None):\n    actual = data.get(key)\n    if convert is not None:\n        actual = convert(actual)\n\n    if actual != expected:\n        rich.inspect(actual)\n        raise MediaValidationError(f\"{key} is {actual}, expected {expected}\")\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:180-199\n    return frames\n\ndef find_missing_frames(\n    timestamps: NDArray[np.float64],\n    fps: float,\n    duration_frames: int,\n) -> tuple[list[float], list[float]]:\n    # PRN read r_frame_rate instead of throw/hardcode this\n    frame_numbers = np.array(timestamps) * fps\n    extra_frames = []\n    missing_frames = []\n    last_int: int = -1  # thus 0 is the next frame to find\n    # print()\n    for _cur in frame_numbers:\n\n        # * anything before/after expected frames => extras\n        if _cur >= duration_frames:\n            # add all frames past duration_frames as extras\n            # BTW duration_frames is NOT inclusive b/c 0 is first frame\n            extra_frames.append(_cur)\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:231-243\ndef report_missing_frames(video_path: Path, video: dict) -> None:\n    frames = get_frame_info(video_path, \"v:0\")\n    timestamps = np.array([frame.pts_time for frame in frames])\n    rich.print(f'{timestamps=}')\n    fps = 30\n    duration_frames = int(float(video.get(\"duration\", 0)) * fps)\n    missing_frames, extra_frames = find_missing_frames(timestamps, fps, duration_frames)\n    if missing_frames:\n        missing_times = [f\"{int(m) / fps:.5f}\" for m in missing_frames]\n        print(f\"[FAILURE] missing frames detected: {missing_times}\")\n    if extra_frames:\n        extra_times = [f\"{int(e) / fps:.5f}\" for e in extra_frames]\n        print(f\"[FAILIURE] extra frames detected: {extra_times}\")\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```fish/load_last_interactive_only/pythons/av/dropped_frames_tests.py\nimport numpy as np\nfrom numpy._typing import NDArray\nimport rich\nfrom dropped_frames import find_missing_frames\n\nclass TestMissingFrames:\n\n    def test_negative_are_extras(self):\n        frames: NDArray[np.float64] = np.array([-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == []\n        expected_extras = np.array([-2.0, -1.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_all_ten_present(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == []\n        assert extras == []\n\n    def test_one_of_ten_is_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [7]\n        assert extras == []\n\n    def test_two_in_a_row_are_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [6.0, 7.0]\n        assert extras == []\n\n    def test_first_missing(self):\n        frames: NDArray[np.float64] = np.array([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0]\n        assert extras == []\n\n    def test_last_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [8.0, 9.0]\n        assert extras == []\n\n    def test_negatives_and_first_missing(self):\n        frames: NDArray[np.float64] = np.array([-2.0, -1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        expected_missing = np.array([0.0, 1.0])\n        np.testing.assert_array_equal(missing, expected_missing)\n        expected_extras = np.array([-2.0, -1.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_frames_past_end_are_extras(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        expected_missing = np.array([])\n        np.testing.assert_array_equal(missing, expected_missing)\n        expected_extras = np.array([10.0, 11.0, 12.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_all_missing(self):\n        frames: NDArray[np.float64] = np.array([])\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == []\n\n    def test_all_missing_with_extras_before(self):\n        frames: NDArray[np.float64] = np.array([-1.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [-1.0]\n\n    def test_all_missing_with_midframe_extras_before(self):\n        frames: NDArray[np.float64] = np.array([-1.5]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [-1.5]\n\n    def test_all_missing_with_midframe_extras_after(self):\n        frames: NDArray[np.float64] = np.array([10.5]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [10.5]\n\n    def test_actual_samples_ffmpeg(self):\n        timestamps=np.array(\n              [0.      , 0.033333, 0.066667, 0.1     , 0.133333, 0.166667, \\\n               0.2     , 0.233333, 0.266667, 0.3     , 0.333333, 0.366667,\n               0.4     , 0.433333, 0.466667, 0.5     , 0.533333, 0.566667,\n               0.6     , 0.633333, 0.666667, 0.7     , 0.733333, 0.766667,\n               0.8     , 0.833333, 0.866667, 0.9     , 0.933333, 0.966667,\n               1.      , 1.033333, 1.066667, 1.1     , 1.133333, 1.166667,\n               1.2     , 1.233333, 1.266667, 1.3     , 1.333333, 1.366667,\n               1.4     , 1.433333, 1.466667, 1.5     , 1.533333, 1.566667,\n               1.6     , 1.633333, 1.666667, 1.7     , 1.733333, 1.766667,\n               1.8     , 1.833333, 1.866667, 1.9     , 1.933333, 1.966667,\n               2.      , 2.033333, 2.066667, 2.1     , 2.133333, 2.166667,\n               2.2     , 2.233333, 2.266667, 2.3     , 2.333333, 2.366667,\n               2.4     , 2.433333, 2.466667, 2.5     , 2.533333, 2.566667,\n               2.6     , 2.633333, 2.666667, 2.7     , 2.733333, 2.866667,\n               2.933333, 2.966667, 3.      , 3.033333, 3.066667, 3.1     ,\n               3.133333, 3.166667, 3.2     , 3.233333, 3.266667, 3.3     ,\n               3.333333, 3.366667, 3.4     , 3.433333, 3.466667, 3.5     ,\n               3.533333, 3.566667, 3.6     , 3.633333, 3.666667, 3.7     ,\n               3.733333, 3.766667, 3.8     , 3.833333, 3.866667, 3.9     ,\n               3.933333, 3.966667])\n\n        expected_missing = <|fim_middle|>\n        \n\n\n```\n\n## Reminders about the cursor line:\nText before cursor: `        expected_missing = `"
      }],
    "temperature":1,
    "top_p":1,
    "model":"gpt-oss:120b",
    "raw":false,
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"medium"
    }
  },
  "last_sse":{
    "choices":[{
        "index":0,
        "delta":[],
        "finish_reason":"stop"
      }],
    "object":"chat.completion.chunk",
    "id":"chatcmpl-ybtJWvddekg7bF1hT9aDwoZ2XcTrEFVR",
    "system_fingerprint":"b7785-1c7cf94b2",
    "created":1770019250,
    "timings":{
      "predicted_n":1334,
      "prompt_per_second":5002.9100870238,
      "cache_n":1459,
      "prompt_n":2871,
      "prompt_per_token_ms":0.19988366422849,
      "predicted_ms":6229.902,
      "predicted_per_token_ms":4.6700914542729,
      "prompt_ms":573.866,
      "predicted_per_second":214.12856895662
    },
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "content":"np.array([83, 84, 85, 87])",
    "reasoning_content":"We need to suggest code to replace <|fim_middle|> in test file. The test is \"test_actual_samples_ffmpeg\". They have timestamps array of many values from 0 to about 3.966667 (maybe). They need expected_missing based on find_missing_frames with fps=30 and duration_frames maybe? In earlier code they call find_missing_frames(timestamps, fps, duration_frames). In this test they probably will compute missing frames from this timestamps list. Let's compute: timestamps array includes values every 0.033333 approx, but there are some missing? Look at list: after 2.733333, next is 2.866667 (gap 0.133334) skipping 2.766667, 2.8? Actually they have 2.733333 then 2.866667 (they omitted 2.766667, 2.8, 2.833333?). Let's examine earlier part: sequence up to 2.733333 seems continuous every 0.033333. Then they have 2.866667, 2.933333, 2.966667, 3., etc. So missing frames correspond to frames that are not present in timestamps. With fps=30, each frame duration = 1/30 ≈ 0.0333333. The timestamps correspond to frame numbers: timestamp * fps gives frame numbers. So missing frames are those integers from 0 up to duration_frames-1 that are not present.\n\nBut they also need duration_frames perhaps derived from video duration? Not provided. In this test they likely compute expected_missing using numpy arange based on known missing indices. Could simply set expected_missing = np.array([...]) of missing frame numbers? Or missing timestamps? In earlier tests, missing is list of floats (frame numbers) not timestamps. For test_actual_samples_ffmpeg they may compare missing (list) to expected_missing (array) using np.testing.assert_array_equal? The code after placeholder probably calls find_missing_frames and asserts something.\n\nLet's view rest of test file after placeholder. Not provided. Probably they compute missing, extras = find_missing_frames(timestamps, 30, ???). But need to infer expected_missing.\n\nWe need to write code for expected_missing variable: maybe it's np.array([82, 83, 84]) etc. Let's compute missing frames from the timestamps list.\n\nFirst, convert timestamps to frame numbers: frame = timestamp * fps = timestamp *30.\n\nGiven timestamps values like 0.0 => 0, 0.033333*30 ≈ 0.99999 ~1, 0.066667*30≈2, etc. So each timestamp corresponds to integer frame numbers (0,1,2...). The list seems to include many frames up to maybe 119? Let's compute length: timestamps list seems from 0 to 3.966667 step 0.033333 approx, which corresponds to frames 0 to 119 (since 3.966667*30 = 119). Let's verify: 30*3.966667 ≈ 119.0. So duration_frames maybe 120? Actually frames 0-119 inclusive would be 120 frames, but duration_frames maybe int(duration * fps) where duration maybe 4 seconds? Not sure.\n\nMissing frames: Look at the sequence around 2.733333 (frame 82?) Let's compute: 2.733333*30 = 82 (since 2.733333*30 = 81.99999 ≈82). Next timestamp is 2.866667*30 = 86 (since 2.866667*30 = 86.00001 ≈86). So frames 83,84,85 are missing (i.e., timestamps for frames 83,84,85). Also after that maybe there is another missing later: after 2.733333 they have 2.866667 (86), 2.933333 (88?) Wait compute: 2.933333*30 = 88 (since 2.933333*30=87.99999). Actually 2.866667*30 ≈86, 2.933333*30≈88 (skip 87). Wait 2.866667 corresponds to 86, 2.933333 corresponds to 88, missing frame 87. Also they have 2.966667*30 = 89 (so missing 87 only). So missing frames: 83,84,85,87? Let's double-check earlier: after 2.733333 (82) they skip 2.766667 (83), 2.8 (84), 2.833333 (85), then have 2.866667 (86). Then they skip 2.9? Actually 2.9*30 = 87, they have 2.933333 (88) so missing 87. Good.\n\nAny other gaps later? Look near end: after 3.933333 (118), 3.966667 (119). All good.\n\nSo missing frames are [83,84,85,87]? Let's verify there is also maybe missing 0? No earlier they start at 0. Good.\n\nThus expected_missing = np.array([83,84,85,87])? But the test expects missing list maybe floats? In other tests missing returned as list of floats, but they compare with np.testing.assert_array_equal for missing? Not earlier. For this test they likely will compare missing (list) to expected_missing (np.array). They might also convert missing to np.array. Let's assume they will use np.testing.assert_array_equal(missing, expected_missing). So we should set expected_missing as np.array([...], dtype=float?) Actually missing frames from function are list of floats (converted to float). So np.testing.assert_array_equal works with list vs array.\n\nThus code: expected_missing = np.array([83, 84, 85, 87]) maybe as floats: np.array([83.,84.,85.,87.]) but integer array will be fine.\n\nLet's produce code: `np.array([83, 84, 85, 87])`\n\nAdd appropriate indentation: line currently has 8 spaces before `expected_missing = `. So we just output the RHS.\n\nThus answer: `np.array([83, 84, 85, 87])`",
    "role":"assistant",
    "finish_reason":"stop"
  }
}