{
  "request_body":{
    "max_tokens":4096,
    "options":[],
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: dotfiles\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks (copy to clipboard):\n```fish/load_last_interactive_only/pythons/av/dropped_frames.py\n    rich.print(f'{timestamps=}')\n```\n\n```fish/load_last_interactive_only/pythons/av/dropped_frames_tests.py\n        np.testing.assert_array_equal(missing, expected_missing)\n```\n\n```fish/load_last_interactive_only/pythons/av/dropped_frames_tests.py\n        np.testing.assert_array_equal(missing, expected_missing)\n        expected_extras = np.array([-2.0, -1.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n```\n\n```fish/load_last_interactive_only/pythons/av/dropped_frames_tests.py\n        missing, extras = find_missing_frames(frames, 30, 10)\n```\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:180-199\n    return frames\n\ndef find_missing_frames(\n    timestamps: NDArray[np.float64],\n    fps: float,\n    duration_frames: int,\n) -> tuple[list[float], list[float]]:\n    # PRN read r_frame_rate instead of throw/hardcode this\n    frame_numbers = np.array(timestamps) * fps\n    extra_frames = []\n    missing_frames = []\n    last_int: int = -1  # thus 0 is the next frame to find\n    # print()\n    for _cur in frame_numbers:\n\n        # * anything before/after expected frames => extras\n        if _cur >= duration_frames:\n            # add all frames past duration_frames as extras\n            # BTW duration_frames is NOT inclusive b/c 0 is first frame\n            extra_frames.append(_cur)\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:182-229\ndef find_missing_frames(\n    timestamps: NDArray[np.float64],\n    fps: float,\n    duration_frames: int,\n) -> tuple[list[float], list[float]]:\n    # PRN read r_frame_rate instead of throw/hardcode this\n    frame_numbers = np.array(timestamps) * fps\n    extra_frames = []\n    missing_frames = []\n    last_int: int = -1  # thus 0 is the next frame to find\n    # print()\n    for _cur in frame_numbers:\n\n        # * anything before/after expected frames => extras\n        if _cur >= duration_frames:\n            # add all frames past duration_frames as extras\n            # BTW duration_frames is NOT inclusive b/c 0 is first frame\n            extra_frames.append(_cur)\n            continue\n        if _cur < 0:\n            # everything below zero is always extra, and should never happen b/c I test for start_time == 0\n            extra_frames.append(_cur)\n            continue\n\n        # * any timestamp not on a frame exactly (i.e. 2.000 or 3.000, after rounding 3rd digit) => extras (not an exact frame)\n        #    so 2.105 => not on a frame boundary, mark as extra (b/w expected video frames)\n        cur_is_on_a_frame = np.isclose(_cur % 1, 0, atol=1e-3)\n        if not cur_is_on_a_frame:\n            extra_frames.append(_cur)\n            # do not increment last until hit an exact frame at which time will add all missing since last frame\n            continue\n\n        # * cur is a frame exactly (close test above means its on a frame => so round any error away and integer it)\n        cur_int: int = int(round(_cur))\n        diff = cur_int - last_int\n        if diff > 1:\n            # * add missing frames since last\n            _missing_since_last = np.arange(last_int + 1, cur_int)\n            # rich.print(f'{_missing_since_last=}')\n            missing_frames.extend(_missing_since_last)\n\n        last_int = cur_int\n\n    # * missing frames after last frame:\n    if last_int < duration_frames:\n        missing_frames.extend(np.arange(last_int + 1, duration_frames))\n\n    return [float(m) for m in missing_frames], [float(e) for e in extra_frames]\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:231-243\ndef report_missing_frames(video_path: Path, video: dict) -> None:\n    frames = get_frame_info(video_path, \"v:0\")\n    timestamps = np.array([frame.pts_time for frame in frames])\n    rich.print(f'{timestamps=}')\n    fps = 30\n    duration_frames = int(float(video.get(\"duration\", 0)) * fps)\n    missing_frames, extra_frames = find_missing_frames(timestamps, fps, duration_frames)\n    if missing_frames:\n        missing_times = [f\"{int(m) / fps:.5f}\" for m in missing_frames]\n        print(f\"[FAILURE] missing frames detected: {missing_times}\")\n    if extra_frames:\n        extra_times = [f\"{int(e) / fps:.5f}\" for e in extra_frames]\n        print(f\"[FAILIURE] extra frames detected: {extra_times}\")\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:165-184\n        \"json\",\n        str(video_path),\n    ]\n\n    joined_cmd = \" \".join(str(arg) for arg in cmd)\n    rich.print(\"cmd\", joined_cmd)\n\n    result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n    data = json.loads(result.stdout)\n    frames = [FrameInfo(\n        pts=int(frame[\"pts\"]),\n        pts_time=float(frame[\"pts_time\"]),\n        duration=int(frame[\"duration\"]),\n        duration_time=float(frame[\"duration_time\"]),\n    ) for frame in data.get(\"frames\", [])]\n    return frames\n\ndef find_missing_frames(\n    timestamps: NDArray[np.float64],\n    fps: float,\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/pythons/av/dropped_frames.py:195-214\n        # * anything before/after expected frames => extras\n        if _cur >= duration_frames:\n            # add all frames past duration_frames as extras\n            # BTW duration_frames is NOT inclusive b/c 0 is first frame\n            extra_frames.append(_cur)\n            continue\n        if _cur < 0:\n            # everything below zero is always extra, and should never happen b/c I test for start_time == 0\n            extra_frames.append(_cur)\n            continue\n\n        # * any timestamp not on a frame exactly (i.e. 2.000 or 3.000, after rounding 3rd digit) => extras (not an exact frame)\n        #    so 2.105 => not on a frame boundary, mark as extra (b/w expected video frames)\n        cur_is_on_a_frame = np.isclose(_cur % 1, 0, atol=1e-3)\n        if not cur_is_on_a_frame:\n            extra_frames.append(_cur)\n            # do not increment last until hit an exact frame at which time will add all missing since last frame\n            continue\n\n        # * cur is a frame exactly (close test above means its on a frame => so round any error away and integer it)\n\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```fish/load_last_interactive_only/pythons/av/dropped_frames_tests.py\nimport numpy as np\nfrom numpy._typing import NDArray\nimport rich\nfrom dropped_frames import find_missing_frames\n\nclass TestMissingFrames:\n\n    def test_negative_are_extras(self):\n        frames: NDArray[np.float64] = np.array([-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == []\n        expected_extras = np.array([-2.0, -1.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_all_ten_present(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == []\n        assert extras == []\n\n    def test_one_of_ten_is_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [7]\n        assert extras == []\n\n    def test_two_in_a_row_are_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [6.0, 7.0]\n        assert extras == []\n\n    def test_first_missing(self):\n        frames: NDArray[np.float64] = np.array([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0]\n        assert extras == []\n\n    def test_last_missing(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [8.0, 9.0]\n        assert extras == []\n\n    def test_negatives_and_first_missing(self):\n        frames: NDArray[np.float64] = np.array([-2.0, -1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        expected_missing = np.array([0.0, 1.0])\n        np.testing.assert_array_equal(missing, expected_missing)\n        expected_extras = np.array([-2.0, -1.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_frames_past_end_are_extras(self):\n        frames: NDArray[np.float64] = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        expected_missing = np.array([])\n        np.testing.assert_array_equal(missing, expected_missing)\n        expected_extras = np.array([10.0, 11.0, 12.0])\n        np.testing.assert_array_equal(extras, expected_extras)\n\n    def test_all_missing(self):\n        frames: NDArray[np.float64] = np.array([])\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == []\n\n    def test_all_missing_with_extras_before(self):\n        frames: NDArray[np.float64] = np.array([-1.0]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [-1.0]\n\n    def test_all_missing_with_midframe_extras_before(self):\n        frames: NDArray[np.float64] = np.array([-1.5]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [-1.5]\n\n    def test_all_missing_with_midframe_extras_after(self):\n        frames: NDArray[np.float64] = np.array([10.5]) / 30\n        missing, extras = find_missing_frames(frames, 30, 10)\n        assert missing == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert extras == [10.5]\n\n    def test_actual_samples_ffmpeg(self):\n        timestamps=np.array(\n              [0.      , 0.033333, 0.066667, 0.1     , 0.133333, 0.166667, \\\n               0.2     , 0.233333, 0.266667, 0.3     , 0.333333, 0.366667,\n               0.4     , 0.433333, 0.466667, 0.5     , 0.533333, 0.566667,\n               0.6     , 0.633333, 0.666667, 0.7     , 0.733333, 0.766667,\n               0.8     , 0.833333, 0.866667, 0.9     , 0.933333, 0.966667,\n               1.      , 1.033333, 1.066667, 1.1     , 1.133333, 1.166667,\n               1.2     , 1.233333, 1.266667, 1.3     , 1.333333, 1.366667,\n               1.4     , 1.433333, 1.466667, 1.5     , 1.533333, 1.566667,\n               1.6     , 1.633333, 1.666667, 1.7     , 1.733333, 1.766667,\n               1.8     , 1.833333, 1.866667, 1.9     , 1.933333, 1.966667,\n               2.      , 2.033333, 2.066667, 2.1     , 2.133333, 2.166667,\n               2.2     , 2.233333, 2.266667, 2.3     , 2.333333, 2.366667,\n               2.4     , 2.433333, 2.466667, 2.5     , 2.533333, 2.566667,\n               2.6     , 2.633333, 2.666667, 2.7     , 2.733333, 2.866667,\n               2.933333, 2.966667, 3.      , 3.033333, 3.066667, 3.1     ,\n               3.133333, 3.166667, 3.2     , 3.233333, 3.266667, 3.3     ,\n               3.333333, 3.366667, 3.4     , 3.433333, 3.466667, 3.5     ,\n               3.533333, 3.566667, 3.6     , 3.633333, 3.666667, 3.7     ,\n               3.733333, 3.766667, 3.8     , 3.833333, 3.866667, 3.9     ,\n               3.933333, 3.966667])\n        missing, extras = find_missing_frames(timestamps, 30, <|fim_middle|>\n\n        expected_missing = np.array([83, 84, 85, 87])\n        np.testing.assert_array_equal(missing, expected_missing)\n        assert extras == []\n```\n\n## Reminders about the cursor line:\nText before cursor: `        missing, extras = find_missing_frames(timestamps, 30, `"
      }],
    "temperature":1,
    "top_p":1,
    "model":"gpt-oss:120b",
    "raw":false,
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  },
  "last_sse":{
    "choices":[{
        "index":0,
        "delta":[],
        "finish_reason":"stop"
      }],
    "object":"chat.completion.chunk",
    "id":"chatcmpl-Z6kdFuZC7RxWaXLRUO6Sz9q7bjJISkYz",
    "system_fingerprint":"b7785-1c7cf94b2",
    "created":1770019518,
    "timings":{
      "predicted_n":164,
      "prompt_per_second":1049.3019860701,
      "cache_n":4665,
      "prompt_n":69,
      "prompt_per_token_ms":0.95301449275362,
      "predicted_ms":945.359,
      "predicted_per_token_ms":5.7643841463415,
      "prompt_ms":65.758,
      "predicted_per_second":173.479069856
    },
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "content":"120",
    "reasoning_content":"We need to fill missing argument: duration_frames likely 100? timestamps go up to about 3.966667 seconds. At 30 fps, duration_frames = int(3.966667*30)=119? Actually 3.966667*30=119.0. So duration_frames=120? In test expected missing frames [83,84,85,87] these are frame indices. Compute total frames maybe 100? Let's see timestamps array length 120? Count? Probably 120 entries (0 to 3.966667 step 0.033333). That's 120 frames. Missing frames 83,84,85,87 correspond to missing timestamps at those indices. So duration_frames should be 120. Provide 120.",
    "role":"assistant",
    "finish_reason":"stop"
  }
}