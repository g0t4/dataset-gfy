{
  "request_body":{
    "options":[],
    "top_p":1,
    "raw":false,
    "max_tokens":4096,
    "model":"gpt-oss:120b",
    "messages":[{
        "_logged":true,
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "_logged":true,
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks (copy to clipboard):\n```auto_edit/new_silence/tests/integration_tests.py\n562.133s-562.267s\n```\n\n```auto_edit/fcpxml/builder.py\n            add_noise_gate(clip)\n```\n\n```auto_edit/ranges.py\n        new.dampen = self.dampen\n```\n\n```auto_edit/fcpxml/builder.py\n            # adjust_volume(clip, -96) # or just mute it\n```\n\n```auto_edit/fcpxml/builder_tests.py\n    def test_long_second_silence__keeps_first_15_frames(self, fcp_xml):\n        long_second = SilenceRange(start_frame=10, end_frame=100)\n\n        # preceding content range so the silence is treated as a non‑first silence\n        dummy_content = ContentRange(start_frame=0, end_frame=10)\n        fcp_xml.process_ranges([dummy_content, long_second])\n\n        clips = list(fcp_xml.spine)\n        assert len(clips) == 2\n        clip = clips[1]\n\n        assert clip.get(\"name\").startswith(\"trim-\")\n        assert clip.get(\"start\") == \"10/30s\"\n        assert clip.get(\"duration\") == \"15/30s\"\n\n```\n\n```auto_edit/fcpxml/builder.py\nSilenceRange(new_start_frame, silence.end_frame)\n```\n\n```auto_edit/fcpxml/builder.py\n                new_start_frame = round(silence.end_frame - max_silence_frames)\n                silence = SilenceRange(new_start_frame, silence.end_frame)\n```\n\n",
        "role":"user"
      },{
        "_logged":true,
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/range-tests.py:58-63\n    def test_trim_end__keeps_first_15_frames(self):\n        silence = SilenceRange(10, 100)\n        keep_frames = 15\n        trimmed = silence.trim_end(keep_frames)\n        assert trimmed.start_frame == 10\n        assert trimmed.end_frame == 25\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/range-tests.py:56-76\nclass TestSilenceRangeTrim:\n    # silence ranges get trimmed when they're long, this will help carefully create the trimmed result\n    def test_trim_end__keeps_first_15_frames(self):\n        silence = SilenceRange(10, 100)\n        keep_frames = 15\n        trimmed = silence.trim_end(keep_frames)\n        assert trimmed.start_frame == 10\n        assert trimmed.end_frame == 25\n\n    def test_trim_end_ask_to_keep_more_frames_than_original__raises(self):\n        silence = SilenceRange(0, 10)\n        keep_frames = 20\n        with pytest.raises(ValueError):\n            silence.trim_end(keep_frames)\n\n    def test_trim_start__keeps_last_15_frames(self):\n        silence = SilenceRange(0, 100)\n        keep_frames = 15\n        trimmed = silence.trim_start(keep_frames)\n        assert trimmed.start_frame == 85\n        assert trimmed.end_frame == 100\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/range-tests.py:71-76\n    def test_trim_start__keeps_last_15_frames(self):\n        silence = SilenceRange(0, 100)\n        keep_frames = 15\n        trimmed = silence.trim_start(keep_frames)\n        assert trimmed.start_frame == 85\n        assert trimmed.end_frame == 100\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/range-tests.py:65-69\n    def test_trim_end_ask_to_keep_more_frames_than_original__raises(self):\n        silence = SilenceRange(0, 10)\n        keep_frames = 20\n        with pytest.raises(ValueError):\n            silence.trim_end(keep_frames)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/fcpxml/builder.py:98-117\n\n\n    def add_silence(self, silence: SilenceRange, is_first_silence: bool):\n        name = \"\"\n\n        max_silence_frames = round(0.5 * self.fps)\n        if is_first_silence:\n            # limit to last 0.5s @ 1x only when trimming is needed\n            if silence.duration_frames() > max_silence_frames:\n                name += \"trim-\"\n                new_start_frame = round(silence.end_frame - max_silence_frames)\n                silence = SilenceRange(new_start_frame, silence.end_frame)\n\n        if silence.duration_frames() > max_silence_frames:\n            name += \"trim-\"\n            new_end_frame = round(silence.start_frame + max_silence_frames)  # KEEP\n            silence = SilenceRange(silence.start_frame, new_end_frame)  # KEEP\n\n        name += f\"silent{silence.start_frame}-{silence.end_frame} / {self.show_seconds(silence.start_frame)}-{self.show_seconds(silence.end_frame)}\"\n\n\n",
        "role":"user"
      },{
        "_logged":true,
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/ranges.py\nimport copy\n\nfrom auto_edit.new_silence.detects.segments import GapWindow\nfrom auto_edit.transcribe import WhisperSegment\n\nclass FrameRange:\n    \"\"\"\n    Base class representing a range of frames with a start and end (exclusive). \n    Provides utilities for duration, copying, comparison, containment, and iteration. \n    \"\"\"\n\n    def __init__(self, start_frame: int, end_frame: int):\n        self.start_frame: int = start_frame\n        self.end_frame: int = end_frame\n\n    def duration_frames(self) -> int:\n        return round(self.end_frame - self.start_frame)\n\n    def __len__(self):\n        return self.duration_frames()\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return f\"Frames[{self.start_frame}➜{self.end_frame})\"\n\n    def __copy__(self):\n        return FrameRange(self.start_frame, self.end_frame)\n\n    def __deepcopy__(self, memo=None):\n        return FrameRange(self.start_frame, self.end_frame)\n\n    def copy(self):\n        return self.__copy__()\n\n    def deepcopy(self):\n        return self.__deepcopy__()\n\n    def clone(self):\n        return self.copy()\n\n    def __lt__(self, other):\n        # FYI __gt__ is not needed because it is the opposite of __lt__, at least in this case of non-overlapping ranges\n        # PRN handle non FrameRange\n        # PRN handle overlapping ranges\n        return self.end_frame <= other.start_frame\n\n    def __contains__(self, frame):\n        return self.start_frame <= frame < self.end_frame\n\n    def __iter__(self):\n        return iter(range(self.start_frame, self.end_frame))  # range is non-inclusive of end_frame\n\n# PRN how much of this ContentRange model do I really need? review later\nclass ContentRange(FrameRange):\n\n    transcriptions: list[WhisperSegment]\n\n    def __init__(self, start_frame: int, end_frame: int):\n        super().__init__(start_frame, end_frame)\n        self.transcriptions = []\n\n    def __str__(self):\n        return f\"Content[{self.start_frame}➜{self.end_frame})\"\n\n    def __copy__(self):\n        return ContentRange(self.start_frame, self.end_frame)\n\n    def __deepcopy__(self, memo=None):\n        return ContentRange(self.start_frame, self.end_frame)\n\nclass SilenceRange(FrameRange):\n\n    # reduce audio level of entire clip, defaults to True for legacy silence detect approach\n    dampen: bool = True  # use noise gate\n\n    # mute: bool = False  # use mute (not noise gate)\n\n    def __str__(self):\n        result = f\"Silence[{self.start_frame}➜{self.end_frame})\"\n        if self.dampen:\n            result += f\" dampen\"\n        return result\n\n    def __copy__(self):\n        return self.__deepcopy__()\n\n    def __deepcopy__(self, memo=None):\n        new = SilenceRange(self.start_frame, self.end_frame)\n        new.dampen = self.dampen\n        # new.mute = self.mute\n        return new\n\n    def trim_end(self, keep_frames: int) -> \"SilenceRange\":\n        <|fim_middle|>\n        new_end = self.start_frame + keep_frames\n        trimmed = SilenceRange(self.start_frame, new_end)\n        # trimmed.dampen = self.dampen\n        # trimmed.mute = self.mute\n        return trimmed\n\n    def trim_start(self, keep_frames: int) -> \"SilenceRange\":\n        new_start = self.end_frame - keep_frames\n        trimmed = SilenceRange(new_start, self.end_frame)\n        # trimmed.dampen = self.dampen\n        # trimmed.mute = getattr(self, \"mute\", False)\n        return trimmed\n```\n\n## Reminders about the cursor line:\nText before cursor: `        `\nText before cursor is all whitespace (do not ignore this)",
        "role":"user"
      }],
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "temperature":1
  },
  "last_sse":{
    "timings":{
      "cache_n":1234,
      "predicted_per_second":219.15477161172,
      "prompt_per_second":3583.6099868116,
      "prompt_n":1576,
      "predicted_n":136,
      "prompt_ms":439.78,
      "prompt_per_token_ms":0.27904822335025,
      "predicted_ms":620.566,
      "predicted_per_token_ms":4.5629852941176
    },
    "choices":[{
        "finish_reason":"stop",
        "index":0,
        "delta":[]
      }],
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7785-1c7cf94b2",
    "id":"chatcmpl-PV5dpWKNtPJUf7gOeGxt9opffl3gNP7A",
    "created":1770965590
  },
  "response_message":{
    "content":"        if keep_frames > self.duration_frames():\n            raise ValueError(\"keep_frames exceeds silence duration\")\n        if keep_frames < 0:\n            raise ValueError(\"keep_frames must be non‑negative\")",
    "finish_reason":"stop",
    "reasoning_content":"We need to implement trim_end logic. Likely check keep_frames <= duration else raise. Also ensure keep_frames non-negative. Return trimmed. Also maybe preserve dampen. Code: if keep_frames > self.duration_frames(): raise ValueError. Then compute new_end = self.start_frame + keep_frames. Return trimmed. Also preserve dampen attribute. So include that. Insert at <|fim_middle|>. Provide code lines.",
    "role":"assistant"
  }
}