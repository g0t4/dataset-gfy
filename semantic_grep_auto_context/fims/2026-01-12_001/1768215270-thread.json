{
  "last_sse":{
    "created":1768215270,
    "system_fingerprint":"b7616-18ddaea2a",
    "object":"chat.completion.chunk",
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "timings":{
      "prompt_per_second":6017.5821175422,
      "cache_n":483,
      "prompt_n":3350,
      "prompt_ms":556.702,
      "prompt_per_token_ms":0.16617970149254,
      "predicted_ms":397.847,
      "predicted_per_token_ms":6.1207230769231,
      "predicted_per_second":163.37938956433,
      "predicted_n":65
    },
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-L017LJdUfSjySLyPbrJJogJJWh3guZTB"
  },
  "response_message":{
    "content":"win = self.analysis.window_at_seconds(43.7)",
    "reasoning_content":"Need to fill win = ?. Likely get window at seconds 43.7. Use self.analysis.window_at_seconds(43.7). So code: win = self.analysis.window_at_seconds(43.7).",
    "role":"assistant",
    "finish_reason":"stop"
  },
  "request_body":{
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/tests/integration_tests.py:\nwin.gap.breathing\n\n\n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:15-26\ndef __init__(\n        self,\n        win: GapWindow,\n        gap_rms: TimeSeries,\n        analysis: AudioAnalysisResult,\n        plotting: bool = False,\n    ):\n        self.win = win\n        self.gap_rms = gap_rms\n        self.analysis = analysis\n        self.plotting = plotting\n        self.journal = []\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:70-93\ndef test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1.5),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2.1),\n        )\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:69-88\n\n    def test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n            first_min=SimpleNamespace(frame_aligned_at_seconds=1.5),\n            last_min=SimpleNamespace(frame_aligned_at_seconds=2.1),\n        )\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges.py:15-34\n\n        left = win.left_speech\n        left_end_frame = None\n        if left:\n            if prev_win and prev_win.last_min:\n                assert prev_win.right_speech == win.left_speech\n                left_start_frame = round(prev_win.last_min.frame_aligned_at_seconds * fps)  # round b/c this is an exact frame\n                # if I use int() instead of round... then 23.9999 becomes 23 when it s/b 24 for aligned frames b/c aligned is always off only by tiny sliver\n            else:\n                left_start_frame = round(left.start_seconds * fps)\n            if win.gap.left_taper_end:\n                # TODO! which way should I round, perhaps put that logic into locator\n                left_end_frame = round(win.gap.left_taper_end.time.frames)\n            else:\n                left_end_frame = round(win.first_min.frame_aligned_at_seconds * fps)  # round b/c this is an exact frame\n            left_content = ContentRange(left_start_frame, left_end_frame)\n            all.append(left_content)\n\n        right = win.right_speech\n        right_start_frame = None\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges.py:45-54\n        # for now, only mute if detected breathing... if unknown or flagged as not breathing (False) then don't mute it\n        silence.dampen = win.breathing == True\n\n        all.append(silence)\n        if right and win == last_win:\n            all.append(right_content)\n\n        prev_win = win\n\n    return all\n\n"
      },{
        "role":"user",
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n        mark_breathing(cls.analysis)\n\n    def test_detect_first_taper_at_start(self):\n        # minute7@gap2.24s-2.69s\n        mark_breathing(self.analysis)\n\n        # TODO taper + breathe => need to detect breathing part and flag it\n        #  first bounce ~90ms\n        #  second is 320ms (breathing)\n\n        win2 = self.analysis.windows[0]\n        first_min = pytest.approx(2.25625, 0.001)\n        assert win2.first_min.seconds == first_min\n        assert win2.last_min.seconds == pytest.approx(2.65, 0.1)\n\n        # ctx = GapContext(win2, self.analysis.rms_slice_for_gap(win2), self.analysis)\n        # LeftSpeechTaper_WithOptionalBreathe_Locator().locate(ctx)\n\n        # * first hump\n        assert len(win2.gap.crossovers) == 5\n        #\n        assert win2.gap.left_taper_end\n        end_of_taper_hump = pytest.approx(2.334, 0.001)\n        assert win2.gap.left_taper_end.time.seconds == end_of_taper_hump\n\n        # TODO setup assertions and code to flag breathing, or NOT breathing for second hump\n        # assert win2s.breathing # TODO sub asserts on taper + breathing\n\n    def test_detect_first_taper_at_end(self):\n        # minute7@gap2.24s-2.69s\n        mark_breathing(self.analysis)\n\n        # * taper start/end have strikingly similar amplitudes for max/right_min!\n        # observation: minute7 (start + end have taper+breathe)\n        # and weirdly they have VERY similar dB levels\n        # could I tie to a ratio of these or? closer to these?\n        # * first off, the left_min is higher than right_min (hence taper is continuing)\n        # TODO! assert left_min > right_min? any negative test case I can use for this?\n        #    but it is also nearly the same values:\n        #    start taper:\n        #      hump left half:  dur=35.94ms 2.256s->2.292s A=8.20B -45.4dB -> -37.2dB\n        #      hump right half: dur=39.58ms 2.292s->2.332s A=-22.8dB -37.2dB -> -60.1dB\n        #\n        #      -45.4dB min -> -37.2dB max -> -60.1dB min\n        #\n        #    end taper:\n        #      hump left half:  dur=42.71ms 57.182s->57.225s A=13.0dB -50.3dB > -37.3dB\n        #      hump right half: dur=48.44ms 57.225s->57.273s A=-23.4dB -37.3dB > -60.7dB\n        #\n        #      -50.3dB min -> -37.3dB max -> -60.7dB min\n        #\n        #    note both peak/conclude at almost same level\n        #      and these aren't just b/c of my DetectThresholds (not AFAICT, TODO lookup values for thresholds)\n        # TODO! use these ratios or smth about the similarity IF NEEDED\n\n        first_min = pytest.approx(57.182, 0.001)\n        win = self.analysis.window_at_seconds(first_min.expected)\n\n        # * legacy first/last_min\n        assert win.first_min.seconds == first_min\n        assert win.last_min.seconds == pytest.approx(57.502, 0.1)\n\n        # ctx = GapContext(win, self.analysis.rms_slice_for_gap(win), self.analysis)\n        # LeftSpeechTaper_WithOptionalBreathe_Locator().locate(ctx)\n\n        # * first hump\n        assert len(win.gap.crossovers) == 5\n        #\n        end_of_taper_hump = pytest.approx(57.273, 0.001)\n        assert win.gap.left_taper_end\n        assert win.gap.left_taper_end.time.seconds == end_of_taper_hump\n\n        # TODO setup assertions and code to flag breathing, or NOT breathing for second hump\n        # assert win2s.breathing # TODO sub asserts on taper + breathing\n\n    def test_double_hump_NOT_detected_as_taper_nor_breathing(self):\n        # ~43.7 seconds\n        #  use duration and/OR middle min is higher than first_min... use that! too?\n        #  min0:43.69s -49.7dB | max1:43.73s -34.4dB | min2:43.76s -41.1dB | max3:43.79s -36.5dB | min4:43.83s -47.6dB\n        #    btw each CP is numberd 0+ ... I am not numbering min/max separately\n        win = <|fim_middle|>\n        assert not win.breathing\n\n        pass\n\n    def test_taper_then_typing_DOES_DETECT_TAPER_at_start(self):\n        # min:46.32s -47.3dB | max:46.35s -39.2dB | min:46.63s -94.3dB |\n        # observations:\n        #     - this bottoms out (literally) at -94dB (basically zero, is zero on my mixpre6 w/ noisegate)\n        #     - so far the taper always continues while subsequent mins are lower than before (no increase in mins so far)\n        #        - stop when mins bottom/level out then?\n        #        - here you can see 5th min is -92.2 so that is higher/same\n        #           rest of critical points:\n        #             max:47.16s -75.2dB | min:47.25s -92.2dB | max:47.30s -64.9dB | min:47.39s -87.0dB | max:47.44s -70.1dB | min:47.45s -73.1dB | max:47.46s -71.3dB | min:47.59s -92.5dB | max:47.69s -69.6dB | min:47.96s -94.3dB | max:48.07s -60.1dB | min:48.08s -65.0dB | max:48.18s -43.6dB | min:48.56s -79.0dB\n        #     - Ideally I'd like to see cut off at cp3 (min) at -94dB\n        #       * in this case doesn't matter how I round the frame!\n        #     - ? will taper's always stop at a 3rd minimum?\n        #     -   do I have any examples of tapers that go beyond that?\n        #     -   PRN add logging to detect if it happens and flag it?\n        #          basically I could be adding _minimal_ logging of assumptions (or potential assumptions)\n        #\n        #     rest of critical points are from typing, not that important:\n        win = self.analysis.window_at_seconds(46.32)\n        pass\n\n    def test_detect_last_taper(self):\n        # PRN... for now THIS IS NOT NEEDED thanks to how Noise Gate works\n        pass\n        # minute7@gap57.15s-57.53s\n        # rich.inspect(self.analysis.windows[-1])\n\n    def test_split_first_gap_into_taper_and_breath(self):\n        # assert len(self.analysis.merged_segments) == 5\n        # rich.print(self.analysis.merged_segments)\n        assert len(self.analysis.windows) == 20\n        #\n        # * windows[0] is in taper test above\n        #\n        # * breathing\n        win6s = self.analysis.windows[1]\n        assert win6s.breathing\n        assert win6s.first_min.seconds == pytest.approx(6.91, 0.1)\n        assert win6s.last_min.seconds == pytest.approx(7.16, 0.1)\n        #\n        # * breathing\n        win11s = self.analysis.windows[2]\n        assert win11s.breathing\n        assert win11s.first_min.seconds == pytest.approx(11.03, 0.1)\n        assert win11s.last_min.seconds == pytest.approx(11.33, 0.1)\n        #\n        # * one dip only:\n        win11_2s = self.analysis.windows[3]\n        assert len(win11_2s.gap.crossovers) == 1\n        # assert len(win11_2s.gap.subsegs) == 2\n        assert not win11_2s.breathing  # TODO classify as speech (glue together windows or just mark this as speech)\n        assert win11_2s.first_min.seconds == pytest.approx(11.96, 0.1)\n        assert win11_2s.first_min.seconds == win11_2s.last_min.seconds\n        #\n        # * breathing\n        win13s = self.analysis.windows[4]\n        assert win13s.breathing\n        assert win13s.first_min.seconds == pytest.approx(13.61, 0.1)\n        assert win13s.last_min.seconds == pytest.approx(13.93, 0.1)\n        #\n        # * breathing\n        win15s = self.analysis.windows[5]\n        assert win15s.breathing\n        assert win15s.first_min.seconds == pytest.approx(15.18, 0.1)\n        assert win15s.last_min.seconds == pytest.approx(15.40, 0.1)\n        #\n        win18s = self.analysis.windows[6]\n        assert win18s.breathing\n        assert win18s.first_min.seconds == pytest.approx(18.49, 0.1)\n        assert win18s.last_min.seconds == pytest.approx(18.63, 0.1)\n        # TODO! switch to new minima reporting?\n        # TODO categorized subsets of gap identified\n        #\n        win21s = self.analysis.windows[7]\n        assert win21s.breathing\n        assert win21s.first_min.seconds == pytest.approx(21.09, 0.1)\n        assert win21s.last_min.seconds == pytest.approx(21.33, 0.1)"
      }],
    "raw":false,
    "max_tokens":4096,
    "model":"gpt-oss:120b",
    "options":[],
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "top_p":1,
    "stream":true,
    "temperature":1
  }
}