{"messages":[{"content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n","role":"developer"},{"content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks (copy to clipboard):\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0].min_max_label() == \"min\"\n        assert result[0].cp.rms == MIN\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[1].cp.rms == MAX\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[1].min_max_label() == \"max\"\n        assert result[1].cp.rms == MAX\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        # trio is widdled down to just:\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0].min_max_label() == \"min\"\n        assert result[0].cp.rms == MIN\n        assert result[1].min_max_label() == \"max\"\n        assert result[1].cp.rms == MAX\n        assert result[2].min_max_label() == \"min\"\n        assert result[2].cp.rms == MIN\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0].cp == cps[0].cp\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0].cp.rms == MIN\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0] == cps[0]\n        assert result[1] == cps[1]\n        assert result[2] == cps[2]\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[0] == cps[0]\n```\n\n```auto_edit/new_silence/detects/moot_tests.py\n        assert result[1] == cps[]\n```\n\n","role":"user"},{"content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:227-232\n    def test_minute8(self):\n        # min0:5.2818s -49.2369dB | max1:5.3120s -44.9767dB | min2:5.4062s -71.7467dB | max3:5.4495s -48.5885dB | min4:5.5443s -85.3891dB | max5:5.5844s -74.8381dB | min6:5.7417s -94.2208dB | max7:5.9693s -75.0007dB | min8:6.1052s -94.0321dB\n        #  not sure the taper recognition is important at all here, so just assert not breathing\n        assert not analysis8().window_at_seconds(5.2818).breathing\n        # min0:7.4516s -93.6818dB | max1:7.5109s -63.7591dB | min2:7.5271s -72.8285dB | max3:7.5286s -71.7537dB | min4:7.6615s -91.6643dB | max5:7.7083s -49.4017dB | min6:7.7547s -63.4935dB\n        assert not analysis8().window_at_seconds(7.4516).breathing\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:63-64\ndef analysis2():\n    return get_full_analysis(gptoss_fim_video.minute2)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:129-142\n\n        assert ranges[2].start_frame == 64\n        assert ranges[2].end_frame == 91\n        assert type(ranges[2]) == ContentRange\n        assert ranges[3].start_frame == 91\n        assert ranges[3].end_frame == 152\n        assert type(ranges[3]) == SilenceRange\n\n        # this is the edge case at the end (if no silence after, then need to take this from last window)\n        assert ranges[4].start_frame == 152\n        assert ranges[4].end_frame == 180\n        assert type(ranges[4]) == ContentRange\n\n    \n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:84-103\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n\n    def test_two_back_to_back_windows_with_frame_alignment_shifts(self):\n        # TODO do another test like this but with fraction of frames for all start/end times that way I can test out rounding\n        #   might need different cases to round up/down\n        #   and especially need more cases if I go the route of looking at RMS values to decide how to round\n        #       but only do this when real videos you're editing show the need for it\n        win1 = GapWindow(\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:98-108\n    def test_double_hump_NOT_detected_as_taper_nor_breathing(self):\n        # ~43.7 seconds\n        #  use duration and/OR middle min is higher than first min (left) ... use that! too?\n        #  min0:43.6906s -49.73dB | max1:43.7328s -34.39dB | min2:43.7630s -41.11dB | max3:43.7896s -36.46dB | min4:43.8312s -47.59dB\n        #    btw each CP is numberd 0+ ... I am not numbering min/max separately\n        win = analysis7().window_at_seconds(43.7)\n        assert len(win.gap.crossovers) == 5\n        min0 = pytest.approx(43.6906, 0.001)\n        assert win.gap.left_taper_end  # thru min0 (not min1)\n        assert win.gap.left_taper_end.time.seconds == min0\n        # assert not win.breathing\n","role":"user"},{"content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/detects/moot_tests.py\n\nclass _FakeTime:\n\n    def __init__(self, hops: int):\n        self.hops = hops\n        # Assuming 1 hop = 0.001 s (matches original test data)\n        self.seconds = hops * 0.001\n\nclass _FakeCP:\n\n    def __init__(self, time: _FakeTime, rms: float):\n        self.time = time\n        self.rms = rms\n\nclass _FakeCrossoverData:\n    \"\"\"Minimal stand‑in for :class:`CrossoverData` used by ``is_moot``.\n\n    Only the attributes accessed by ``is_moot`` are provided: ``cp`` and\n    ``min_max_label``.\n    \"\"\"\n\n    def __init__(self, label: str, hops: int, rms: float):\n        self._label = label\n        self.cp = _FakeCP(_FakeTime(hops), rms)\n\n    def min_max_label(self) -> str:\n        return self._label\n\ndef _make(label: str, hops: int, rms: float) -> CrossoverData:\n    \"\"\"Factory for fake crossover data.\n\n    ``label`` should be either ``\"min\"`` or ``\"max\"``.\n    \"\"\"\n    return _FakeCrossoverData(label, hops, rms)  # type: ignore[return-value]\n\n# auto_edit/new_silence/detects/moot_tests.py\nMIN = -70.0\nMAX = -10.0\n# FYI for non-moot: use -70 for min, -10 for max\n#    for moot: use -50s\n#\n#    HOPS:\n#      100 for non-moot gaps\n#        4 for moot gaps\n#        reasonable room for thresholds to change w/o touching tests\n#\n#    => simplifies test setup\n#    demystifies what params are critical\n#\n\nclass TestMootMaterialCrossovers:\n\n    def test_three_crossovers_no_moots(self):\n        cps = [\n            _make(\"min\", 0, MIN),\n            _make(\"max\", 100, MAX),\n            _make(\"min\", 200, MIN),\n        ]\n        result = get_material_crossovers(cps)\n        assert len(result) == 3\n        assert result[0] == cps[0]\n        assert result[1] == cps[1]\n        assert result[2] == cps[2]\n\n    def test_five_crossovers_no_moots(self):\n        cps = [\n            _make(\"min\", 0, MIN),\n            _make(\"max\", 100, MAX),\n            _make(\"min\", 200, MIN),\n            _make(\"max\", 300, MAX),\n            _make(\"min\", 400, MIN),\n        ]\n        result = get_material_crossovers(cps)\n        assert len(result) == 5\n        assert result[0] == cps[0]\n        assert result[1] == cps[1]\n        assert result[2] == cps[2]\n        assert result[3] == cps[3]\n        assert result[4] == cps[4]\n\n    def test_five_crossovers_with_moot_pair(self):\n        cps = [\n            _make(\"min\", 0, MIN),  # min1\n            _make(\"max\", 100, -51),  # max2 \n            # * moot gap\n            _make(\"min\", 104, -52),  # min3 \n            _make(\"max\", 200, MAX),  # max4 \n            _make(\"min\", 300, MIN),  # min5\n        ]\n        result = get_material_crossovers(cps)\n        # pair should be removed, leaving three material crossovers\n        assert len(result) == 3\n        #\n        # double check:\n        assert result[0] == cps[0]\n        assert result[1] == cps[3]\n        assert result[2<|fim_middle|>\n\n    def test_seven_crossovers_with_moot_trio_maximum(self):\n        cps = [\n            _make(\"min\", 0, MIN),  # min1\n            _make(\"max\", 100, -50),  # max2\n            # * moot gap\n            _make(\"min\", 104, -51),  # min3\n            # * moot gap\n            _make(\"max\", 108, -50.1),  # max4\n            _make(\"min\", 200, MIN),  # min5\n            _make(\"max\", 300, MAX),  # max6 \n            _make(\"min\", 400, MIN),  # min7\n        ]\n\n        result = get_material_crossovers(cps)\n\n        assert len(result) == 5\n        assert result[0].min_max_label() == \"min\"\n        assert result[0].cp.rms == MIN\n        #\n        # * trio is widdled down to just:\n        assert result[1].min_max_label() == \"max\"\n        # PRN pass reverse max scenario as test case data change... so two parameterized tests\n        #   ensure -50 always wins\n        assert result[1].cp.rms == -50  # max(max2,max4) is -50\n        assert result[1].cp.time.hops == 100\n        #\n        assert result[2].min_max_label() == \"min\"\n        assert result[2].cp.rms == MIN\n        assert result[3].min_max_label() == \"max\"\n        assert result[3].cp.rms == MAX\n        assert result[4].min_max_label() == \"min\"\n        assert result[4].cp.rms == MIN\n\n    def test_seven_crossovers_with_moot_trio_minimum(self):\n        cps = [\n            _make(\"min\", 0, MIN),  # min1\n            _make(\"max\", 100, MAX),  # max2\n            _make(\"min\", 200, -52),  # min3\n            # * moot gap\n            _make(\"max\", 204, -51),  # max4\n            # * moot gap\n            _make(\"min\", 208, -52.1),  # min5\n            _make(\"max\", 300, MAX),  # max6\n            _make(\"min\", 400, MIN),  # min7\n        ]\n\n        result = get_material_crossovers(cps)\n\n        assert len(result) == 5\n        assert result[0].min_max_label() == \"min\"\n        assert result[0].cp.rms == MIN\n        assert result[1].min_max_label() == \"max\"\n        assert result[1].cp.rms == MAX\n        #\n        # * trio is widdled down to just:\n        assert result[2].min_max_label() == \"min\"\n        assert result[2].cp.rms == -52\n        #\n        assert result[3].min_max_label() == \"max\"\n        assert result[3].cp.rms == MAX\n        assert result[4].min_max_label() == \"min\"\n        assert result[4].cp.rms == MIN\n```\n\n## Reminders about the cursor line:\nText before cursor: `        assert result[2`","role":"user"}]}