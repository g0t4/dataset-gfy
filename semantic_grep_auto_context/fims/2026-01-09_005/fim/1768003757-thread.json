{
  "request_body":{
    "model":"gpt-oss:120b",
    "temperature":1,
    "max_tokens":4096,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from AskQuestion:\nI created a class RmsPoint to consolidate AVTime + an RMS value. Please update CrossoverData, replace min:AVTime + min_rms_value:float with a single min:RmsPoint field, do the same for max:AVTime + max_rms_value:float \n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:129-148\n\n\ndef zero_crossings(signal) -> list[Crossover]:\n    \"\"\"Detect zero‑crossings in *signal*.\n\n    Returns a list of :class:`Crossover` objects where ``before`` is the index\n    of the last sample with the previous sign and ``after`` is the index of the\n    first sample with the new sign.\n    \"\"\"\n    signs = np.sign(signal)  # -1, 0, +1\n\n    crossing_indices: list[Crossover] = []\n    previous_nonzero_sign = 0\n    previous_nonzero_sign_index = 0\n\n    for index, current_sign in enumerate(signs):\n        # skip zeros\n        if current_sign == 0:\n            continue\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:62-64\ndef test_no_crossings_negative(self):\n        indices = zero_crossings([-1, -2, -3])\n        np.testing.assert_array_equal(indices, [])\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:17-30\n@dataclass(frozen=True, slots=True)\nclass Crossover:\n    \"\"\"Represent a zero‑crossing event.\n\n    Attributes\n    ----------\n    before_index: int\n        Index of the sample just before the sign change.\n    after_index: int\n        Index of the sample just after the sign change.\n    \"\"\"\n\n    before_index: int\n    after_index: int\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:70-72\ndef test_no_crossings_positive_to_zero(self):\n        indices = zero_crossings([1, 2, 0])\n        np.testing.assert_array_equal(indices, [])\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:56-72\nclass TestNoCrossings:\n\n    def test_no_crossings_positive(self):\n        indices = zero_crossings([1, 2, 3])\n        np.testing.assert_array_equal(indices, [])\n\n    def test_no_crossings_negative(self):\n        indices = zero_crossings([-1, -2, -3])\n        np.testing.assert_array_equal(indices, [])\n\n    def test_no_crossings_negative_to_zero(self):\n        indices = zero_crossings([-1, -2, 0])\n        np.testing.assert_array_equal(indices, [])\n\n    def test_no_crossings_positive_to_zero(self):\n        indices = zero_crossings([1, 2, 0])\n        np.testing.assert_array_equal(indices, [])\n"
      },{
        "role":"user",
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nfrom dataclasses import dataclass\n\nimport rich\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult, GapWindow\nfrom auto_edit.new_silence.detects.time_series import TimeSeries\n\n@dataclass\nclass GapContext:\n    \"\"\" goal is convenience in detectors/locators so I don't need to create intermediate variable refs instead\"\"\"\n    win: GapWindow\n    gap_rms: TimeSeries\n    analysis: AudioAnalysisResult\n    plotting: bool\n\n    @property\n    def crosses(self):\n        return self.win.gap.crossovers\n\n    def rms_at(self, seconds) -> float:\n        hops = self.analysis.to_hops(seconds)\n        return self.analysis.rms_db[hops]\n\nclass BreathingDetector:\n\n    def not_breathing(self, context: GapContext) -> bool:\n        return False\n\n# TODO DETECTORS / SegmentsBuilder?\n# double bounce => smaller first one < 100ms => treat as taper\n\n# TODO => maybe this is some sort of SegmentClassifier?\n#   TODO or maybe I need to make detectors just all classify various subsegments and not just \"reject\" as breathing/not?\n# look for left_speech taper! and then we can shift the left_speech segment's end_seconds()\n#   in theory, later I can find how to incorprate this detection logic\n\n# - is diff(rms) negative until the first crossover? => this is taper\n#    basically I should move the edit point b/w left_speech and gap ... to the first crossover's corresponding minima\nclass LeftSpeechTaper_WithOptionalBreathe_Locator():\n\n    def log_fail(self, message):\n        \"\"\" log why this locator doesn't apply (i.e. assumption violated) \"\"\"\n        is_logging = True\n        if is_logging:\n            rich.print(f'[left_taper]: {message=}')\n\n    # TODO what to return? NOTE this is NOT just a breathing check\n    def locate(self, c: GapContext):\n        if len(c.crosses) == 0:\n            return self.log_fail(\"no crossovers, cannot find taper_end\")\n\n        # * standard => use first min on left...\n        # virt_seg[0] would make WAY more sense here...\n        cross0 = c.crosses[0]\n        gap_rms_starts_at = c.gap_rms.values[0]\n        cp0 = cross0.critical_point\n        if gap_rms_starts_at < cp0.rms:\n            return self.log_fail(f\"gap RMS starts lower than first min's (critical point) RMS\")\n        # TODO I think this is the same check:\n        if not cross0.<|fim_middle|>():\n            return self.log_fail(\"first crossover must be a minimum critical point\")\n\n        # check for extra, short bounce right before\n        #    s/b ~90-100ms total with min/max/min\n        #    TODO IIRC the second min on the right edge of this taper hump... is lower\n        #    TODO set gap.left_taper_end ? or left_speech.taper_end?\n\n        # minute7 start/end two examples of taper+breathe\n        # look for breathe hump after\n        #\n        return\n\n# TODO breathing... crest scoring?\n# - Let hump_max = max(envelope[min₁ : min₂])\n#   - ? require\n#     - hump_prominence = hump_max - max(min₁, min₂) > X dB # * > X dB (keep in mind frame_len eats away at extremes so would need to adjust X if adjust frame_len)\n#     - hump_width > ~150–300 ms (120dB is smallest I've seen)\n#     - hump_flatness: low variance of slope near the top (breathing humps are rounded, not spiky)\n#   - ? use smoothed RMS (uniform_filter1d) - moving avg\n#     - over JUST the data b/w mins?\n#\n#       diff_stride2 => nearly linear with slight tilt down across the hump\n#         especially linear for most of the middle of the hump (edges have min spikes)\n#\n#       slope (rate of change) starts higher\n#         => drops to zero\n#         => stays nearly zero for a bit (not always)\n#         => goes negative and increases negative\n# - * try weighted scoring + threshold:\n#     instead of exact cutoffs, estimate with probabilities (adjust weights over time)\n#     do this timing ON the hump part once split out, not whole duraiton of gap...\n#       PRN find duration when not the whole gap?\n#     duration score\n#       300-400ms 80% ?\n#       200-300ms 90% ? highest score b/c most are in this range\n#       <200ms    60% - less likely\n#       PRN sample videos and count by length to determine scores above\n#       <100ms => 0%-10% never happens (usually typing)\n\nclass TreatOneMinimaAsSpeech(BreathingDetector):\n\n    # PRN? beyond just not_breathing?\n    #    maybe just have it return matching detectors, attached to the window so I can use it in fcpxml builder?\n    def not_breathing(self, context: GapContext) -> bool:\n        if not len(context.win.gap.crossovers) == 1:\n            return False\n\n        rich.print(f'reject, one dip == speech')\n        if context.plotting:\n            context.gap_rms.mark_rejected(\"one dip == speech\")\n        return True\n\nclass InnerSlopeHasSpike(BreathingDetector):\n\n    def not_breathing(self, context: GapContext) -> bool:\n        # more than one bounce = not breathing (DONE)\n        # TODO more precise rule (i.e. 2+ rampups... cross.is_upward())\n        if len(context.win.gap.crossovers) <= 3:\n            return False\n\n        # TODO track \"minima\" too / instead of crossings?\n        rich.print(f'reject, 2+ bounces')\n        if context.plotting:\n            context.gap_rms.mark_rejected(\"2+ bounces\")\n        return True\n\nclass MinimumDurationDetector(BreathingDetector):\n    # TODO I am not sure I am even using this anywhere at this point...\n    #   this has to overlap with TreatOneMinimaAsSpeech detector (single minima often the case with super short gaps)\n\n    def not_breathing(self, context: GapContext) -> bool:\n        win = context.win\n        # TODO! based on first/last minima\n        duration_seconds = win.last_min.seconds - win.first_min.seconds\n        if duration_seconds > 0.120:\n            return False\n        rich.print(f'reject, too short')\n        if context.plotting:\n            context.gap_rms.mark_rejected(\"reject, too short\")\n        return True"
      }],
    "stream":true,
    "top_p":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "raw":false,
    "options":[]
  },
  "last_sse":{
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-RsEfAeqU3TC2s4VYy8Qj1xdtMGsQetnu",
    "choices":[{
        "finish_reason":"stop",
        "index":0,
        "delta":[]
      }],
    "object":"chat.completion.chunk",
    "timings":{
      "predicted_per_second":192.28616773668,
      "predicted_n":67,
      "prompt_per_second":3802.874030462,
      "cache_n":498,
      "prompt_per_token_ms":0.26295901257569,
      "predicted_ms":348.439,
      "predicted_per_token_ms":5.2005820895522,
      "prompt_ms":564.573,
      "prompt_n":2147
    },
    "system_fingerprint":"b7616-18ddaea2a",
    "created":1768003757
  },
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"cross0.is_minimum()",
    "reasoning_content":"We need to fill cross0.<|fim_middle|>() call. Likely checking if crossover is a minimum. Method maybe is_minimum or is_min()? Search context not available. Guess name is is_minimum(). Use cross0.is_minimum()."
  }
}