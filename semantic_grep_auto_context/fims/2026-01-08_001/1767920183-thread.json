{
  "request_body":{
    "raw":false,
    "model":"gpt-oss:120b",
    "temperature":1,
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "max_tokens":4096,
    "top_p":1,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:15-24\nclass TreatOneMinimaAsSpeech(BreathingDetector):\n\n    # PRN? beyond just not_breathing?\n    #    maybe just have it return matching detectors, attached to the window so I can use it in fcpxml builder?\n    def not_breathing(self, context: GapContext) -> bool:\n        if not len(context.win.gap.crossings) == 1:\n            return False\n\n        context.gap_rms.mark_rejected(\"one dip == speech\")\n        return True\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:9-10\nclass BreathingDetector:\n    pass\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:19-24\ndef not_breathing(self, context: GapContext) -> bool:\n        if not len(context.win.gap.crossings) == 1:\n            return False\n\n        context.gap_rms.mark_rejected(\"one dip == speech\")\n        return True\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:26-30\nclass InnerSlopHasSpike(BreathingDetector):\n\n    def not_breathing(self, context: GapContext) -> bool:\n        # more than one bounce = not breathing (DONE)\n        pass\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:30-44\nclass TestsLeftSpeechTaper:\n\n    @classmethod\n    def setup_class(cls):\n        cls.analysis = full_analysis(gptoss_fim_video.minute7)\n\n    def test_detect_first_taper(self):\n        # minute7@gap2.24s-2.69s\n        # rich.inspect(self.analysis.windows[0])\n        mark_breathing(self.analysis)\n\n    def test_detect_last_taper(self):\n        pass\n        # minute7@gap57.15s-57.53s\n        # rich.inspect(self.analysis.windows[-1])\n"
      },{
        "role":"user",
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n                #\n                # * try lower gate thresholds (finds a few more points where subtle direction shifts in overall trend... i.e. bowl/dip on way up hump... I don't need that granularity\n                # FYI OK TO NUKE THIS LINE, was just a brief experiment:\n                diff_stride2.gate(lower=-0.2, upper=0.2).sign().plot(linewidth=1, **line_args, shift=stack_offset.reserve(-5), label_end=f\"EXPERIMENT: 0.2 gate comparison\")\n                plot_zero_line(win, shift=stack_offset.same())\n                offset_gated_experimental__0_2 = stack_offset.same()\n                #\n                # FYI signs(smooth(diff)) leads to skewing b/c magnitude of ramp-up is extreme and pulls up the apparent crossover point long before that actually happens!\n                #  that's why this is not a good metric for crossover!\n                #  *** instead, gating seems to be better b/c that is a diff way to eliminate noise near zero!\n                #    SO I SHOULD PROBABLY GET RID OF SMOOTHING FOR THE PURPOSES OF FINDING MINIMA ENTIRELY\n                diff_stride2.plot_smooth_signed(stack_offset.reserve(-5), **line_args, label_end=f\"signs(stride2 diff)\")\n                plot_zero_line(win, shift=stack_offset.same())\n\n            # *** crossovers (on stride2, GATED diff)\n            table = Table(show_header=True, header_style=\"bold magenta\", title=\"zero crossovers in rms_stride2\")\n            table.add_column(\"before\\nidx\", justify=\"right\")\n            table.add_column(\"after\\nidx\", justify=\"right\")\n            table.add_column(\"before\\ntime\", justify=\"right\")\n            table.add_column(\"middle\\ntime\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\ntime\", justify=\"right\")\n            table.add_column(\"diff_stride2\\n(after)\", justify=\"right\")\n            table.add_column(\"before\\nhops\", justify=\"right\")\n            table.add_column(\"middle\\nhops\", justify=\"right\", style=\"underline\")\n            table.add_column(\"after\\nhops\", justify=\"right\")\n\n            def plot_cross_box(cross: CrossoverData, plotter, y_middle: float) -> None:\n                \"\"\"Add a rectangle patch for a single crossover.\"\"\"\n                color = \"mediumaquamarine\" if cross.after_diff > 0 else \"lightcoral\"\n                box_width = cross.after.seconds - cross.before.seconds\n                box_height = 2\n                lower_left_y = y_middle - 1\n                rect = plt.Rectangle(\n                    (cross.before.seconds, lower_left_y),\n                    box_width,\n                    box_height,\n                    edgecolor=color,\n                    facecolor=color,\n                    linewidth=1,\n                    alpha=0.3,\n                )\n                plotter.ax.add_patch(rect)\n\n            upward_crossings = []\n            crossovers = build_crossovers(diff_stride2_gated, diff_stride2.values, analysis)\n            for cross in crossovers:\n                # at before/after idx => diff == diff_gated... b/c must be non-zero after gating (IOTW not gated to zero)\n                table.add_row(\n                    str(int(cross.crossover.before_index)),\n                    str(int(cross.crossover.after_index)),\n                    f\"{cross.before.seconds:.3f}s\",\n                    f\"{cross.middle.seconds:.3f}s\",\n                    f\"{cross.after.seconds:.3f}s\",\n                    f\"{cross.after_diff:.2f}\",\n                    f\"{cross.before.hops:,}\",\n                    f\"{cross.middle.hops:,}\",\n                    f\"{cross.after.hops:,}\",\n                )\n                if plotting:\n                    plot_cross_box(cross, plotter, offset_gated)\n\n                is_upward_crossover = cross.after_diff > 0\n                if is_upward_crossover:\n                    upward_crossings.append(cross.crossover)\n                    if plotting:\n                        minima_line = {\"linewidth\": 1, \"alpha\": 0.4, \"zorder\": 0}\n                        plotter.ax.axvline(cross.before.seconds, color=\"teal\", **minima_line).pps = PPS.HOPS_USEFUL\n                        plotter.ax.axvline(cross.middle.seconds, color=\"crimson\", **minima_line)\n                        plotter.ax.axvline(cross.after.seconds, color=\"orangered\", **minima_line).pps = PPS.HOPS_USEFUL\n            rich.print(table)\n\n            crossovers__0_2 = build_crossovers(diff_stride2.gate(lower=-0.2, upper=0.2).sign(), diff_stride2.values, analysis)\n            if plotting:\n                for cross in crossovers__0_2:\n                    plot_cross_box(cross, plotter, offset_gated_experimental__0_2)\n\n            detectors: list[BreathingDetector] = [\n                TreatOneMinimaAsSpeech(),\n                InnerSlopHasSpike(),\n            ]\n            <|fim_middle|>\n\n\n\n            @dataclass\n            class GapSegment:\n                # start_seconds: float\n                # end_seconds: float\n                left_crossover: Crossover | None\n                right_crossover: Crossover | None\n\n            # subsegs = []\n            # left_crossover = None\n            # for c in crossings:\n            #     # TODO ok what should this look like?\n            #     # TODO how to classify here?\n            #     # TODO replace other classification with this!\n            #     s = GapSegment(left_crossover=left_crossover, right_crossover=c)\n            #     subsegs.append(s)\n            #     left_crossover = c\n            # win.gap.subsegs = subsegs\n            win.gap.crossings = crossovers\n            win.gap.upward_crossings = upward_crossings\n\n            # TODO next step => either minima signal\n            #   if slope is not ~0 =>\n            #      split each sub-segment\n            #      identify breathing? find easy way to get 95% success rate (if simple enough)\n            #       then, if you can find breathing, heuristics can be based on it for short gaps\n            #         *** i.e. then look at downward slop into the breathing's dip and extend left_speech to that point!\n\n            # TODO! WIP ...\n            # * gap analysis to identify key aspects!\n            # FIRST let's look for left_speech taper! and then we can shift the left_speech segment's end_seconds()\n            #   in theory, later I can find how to incorprate this detection logic\n            #\n            # * is diff(rms) negative until the first crossover? => this is taper\n            #    basically I should move the edit point b/w left_speech and gap ... to the first crossover's corresponding minima\n            start_time = win.gap.start_seconds()\n            start_hops = analysis.to_hops(start_time)\n            first_crossover = crossovers[0]\n            # KEEP IN MIND INDEXES are STRIDE2 => go to time first and back to hop/index for other lookups\n            # end_idx = first_crossover.crossover.before_index  # TODO find minima\n            end_time = diff_stride2_gated.times[first_crossover.crossover.after_index]\n            # TODO MOVE HOPS IN\n            end_hops = analysis.to_hops(end_time)\n            rms = analysis.rms_slice(start_hops, end_hops)\n            plot(rms.times, rms.values, color=\"brown\", linewidth=4)\n            minima_index = np.argmin(rms.values)\n            minima_value = rms.values[minima_index]\n            minima_time = rms.times[minima_index]\n            plot([minima_time, minima_time], [minima_value - 5, minima_value + 5])\n\n            #\n            # * THEN if there is another short hump, move that in as part of speech too! (most likely is taper too)\n            #\n            # BOUND with this (remember you're in one window here, its gap region)\n            prev_crossover = None\n            for crossover in crossovers:\n                # * look at slope of curve to determine if likely breathing hump\n                #   duration matters, start with > 120ms and < 500ms\n                #   ALSO keep in mind you should keep existing breathing detection logic in place\n                #   this is only for exceptional cases like multi hump (i.e. taper after left_speech)\n                #    if < 2 crossovers => ignore gap\n                prev_crossover = crossover\n\n        analyze_rms_stride2()\n\n        # TODO turn into speech segment for timeline purposes\n        # only_one_dip = win.first_min.seconds == win.last_min.seconds\n        only_one_dip = len(win.gap.crossings) == 1\n        if only_one_dip:\n            print(\"  REJECTED, only [red]one dip[/]\")\n            if plotting:\n                gap_rms.mark_rejected(\"reject, only one dip\")\n            continue\n\n        # PRN remove min2min after switch to multi-min, crossover anlaysis\n        m2m_start = analysis.to_hops(win.first_min.seconds)\n        m2m_end = analysis.to_hops(win.last_min.seconds)\n        min2min_rms = analysis.rms_slice(m2m_start, m2m_end)"
      }],
    "options":[]
  },
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"for detector in detectors:\n    if detector.not_breathing(context):\n        # If the detector determines this is not breathing, skip further processing\n        continue\n",
    "reasoning_content":"We need to fill after detectors list. Likely loop through detectors to filter. Probably something like:\n\nfor detector in detectors:\n    if detector.not_breathing(context):\n        ...\n\nSearch context? Probably create context = GapContext(...). But not enough info. Simpler: return detectors? Maybe assign to variable? Probably filter crossovers? I think they want to apply detectors to win.gap. Maybe:\n\nfor d in detectors:\n    if d.not_breathing(context):\n        ...\n\nBut need context variable; earlier they have context? Not seen. Probably they want to call not_breathing on each detector with context=win? Actually GapContext likely defined elsewhere. I'd just write pass? No.\n\nProbably they intend to filter out windows where not_breathing true. So:\n\nfor detector in detectors:\n    if detector.not_breathing(context):\n        continue\n\nBut need context variable; maybe use win.gap? I'd write placeholder:\n\nfor detector in detectors:\n    if detector.not_breathing(context):\n        # handle non-breathing case\n        pass\n\nReturn? Probably nothing. I'll insert that loop."
  },
  "last_sse":{
    "id":"chatcmpl-PCniJcvuSFzf3XxI8v8fFr7DU7MXkCHf",
    "timings":{
      "cache_n":2961,
      "predicted_per_second":237.66576743873,
      "predicted_n":268,
      "prompt_per_second":426.43923240938,
      "prompt_ms":2.345,
      "prompt_per_token_ms":2.345,
      "predicted_ms":1127.634,
      "predicted_per_token_ms":4.2075895522388,
      "prompt_n":1
    },
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "created":1767920183,
    "choices":[{
        "delta":[],
        "index":0,
        "finish_reason":"stop"
      }],
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7616-18ddaea2a"
  }
}