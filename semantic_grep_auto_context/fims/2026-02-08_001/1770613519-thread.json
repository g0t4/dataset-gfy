{
  "last_sse":{
    "timings":{
      "predicted_per_token_ms":4.733487544484,
      "predicted_per_second":211.26072279736,
      "predicted_n":281,
      "prompt_per_second":8688.548306116,
      "cache_n":1139,
      "prompt_n":2042,
      "prompt_ms":235.022,
      "prompt_per_token_ms":0.11509402546523,
      "predicted_ms":1330.11
    },
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "object":"chat.completion.chunk",
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "id":"chatcmpl-YAi9mjZOX4eIc3zB1bRnHwESrQ6SYYhf",
    "created":1770613519,
    "system_fingerprint":"b7973-39bf692af"
  },
  "response_message":{
    "content":"\"--no-config\"",
    "finish_reason":"stop",
    "reasoning_content":"We need to insert arguments for rg: likely \"--ignore-stdin\"? Actually to avoid stdin detection, we want to not pass any stdin, so we may add \"--no-config\"? No they already have \"--debug\". Need to pass \"--no-config\"? The test expects stderr not containing \"concluded that is_stdin_readable=true\". To avoid that, we should add \"--no-config\" maybe disables debug? Actually debug prints that line; we want debug but not the warning. The issue is stdin detection; we need to add \"--no-stdin\"? rg option: \"--no-config\" irrelevant. There is \"--no-ignore\"? Not. There is \"--no-config\" disables config. To prevent reading stdin, use \"--no-ignore\"? Not. Actually we want to avoid rg reading stdin, so pass \"--no-config\"? Not. Use \"--no-ignore\"? No. The fix is to set stdin to \"ignore\" via runProcess? Not here. Perhaps we need to add \"--no-config\" to avoid debug detection? Hmm.\n\nSimpler: add \"--no-config\". So argv: [\"rg\", \"--debug\", \"--no-config\", \"foo\"]? But order? They have placeholder before \"--debug\". Probably insert \"--no-config\". So final line: argv: [\"rg\", \"--no-config\", \"--debug\", \"foo\"],.",
    "role":"assistant"
  },
  "request_body":{
    "raw":false,
    "model":"gpt-oss:120b",
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "options":[],
    "stream":true,
    "top_p":1,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: mcp-server-commands\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## TypeScript Code Preferences\n\n- Use camelCase\n- Use PascalCase for classes and interfaces\n- Terminate with a semicolon.\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/mcp-server-commands/src/tools.ts:30-49\n                                enum: [\"shell\", \"executable\"], // * I made this up\n                                description: \"What are you running, two choices: 'shell' or 'executable' (required, no default)\",\n                                // FYI only use default system shell, if the model wants a different shell, can explicitly run it with command_line/argv\n                                //   DO NOT duplicate the mechanism of specifying what runs by adding yet another executable field!\n                                //   spawn's options.shell is bool/string... string is command_name/path... that duplicates and complicates needlessly!\n                            },\n                            command_line: {\n                                type: \"string\",\n                                description: \"Shell command line. Required when mode='shell'. Forbidden when mode='executable'.\"\n                            },\n                            argv: {\n                                minItems: 1, // * made up too\n                                type: \"array\",\n                                items: { type: \"string\" },\n                                description: \"Executable and arguments. argv[0] is the executable. Required when mode='executable'. Forbidden when mode='shell'.\"\n                            },\n                            cwd: {\n                                // or \"workdir\" like before? => eval model behavior w/ each name?\n                                type: \"string\",\n                                description: \"Optional to set working directory\",\n\n\n## ~/repos/github/g0t4/mcp-server-commands/src/run_process.ts:11-118\n       async function runProcess(args: RunProcessArgs): Promise<CallToolResult> {\n\n    const command_line = args?.command_line as string;\n    const argv = args?.argv as string;\n\n    const mode = String(args?.mode);\n    if (!mode) {\n        return errorResult(\"Mode is required\");\n    }\n\n    const isShell = mode === \"shell\";\n    const isExecutable = mode === \"executable\";\n\n    if (!isShell && !isExecutable) {\n        return errorResult(\n            `Invalid mode '${mode}'. Allowed values are 'shell' or 'executable'.`\n        );\n    }\n\n    // * shared args\n    const spawn_options: ObjectEncodingOptions & SpawnOptions = {\n        // spawn options: https://nodejs.org/api/child_process.html#child_processspawncommand-args-options\n        encoding: \"utf8\"\n    };\n    if (args?.cwd) {\n        spawn_options.cwd = String(args.cwd);\n    }\n    // PRN args.env\n    if (args?.timeout_ms) {\n        spawn_options.timeout = Number(args.timeout_ms);\n    } else {\n        // default timeout after 30s\n        spawn_options.timeout = 30000;\n    }\n    // PRN windowsHide on Windows, signal, killSignal\n    // FYI spawn_options.stdio => default is perfect ['pipe', 'pipe', 'pipe'] https://nodejs.org/api/child_process.html#optionsstdio \n    //   do not set inherit (this is what causes ripgrep to see STDIN socket and search it, thus hanging)\n    const stdin_input = args?.input ? String(args.input) : undefined; // TODO\n    const dryRun = Boolean(args?.dry_run);\n\n        try {\n        if (dryRun) {\n            // Build a descriptive plan without executing anything\n            let plan = '';\n            if (isShell) {\n                const cmd = String(args?.command_line);\n                const shell = process.env.SHELL || (process.platform === 'win32' ? 'cmd.exe' : '/bin/sh');\n                plan = `Shell mode: will execute command_line via ${shell}: ${cmd}`;\n            } else if (isExecutable) {\n                const argv = args?.argv as string[];\n                plan = `Executable mode: will spawn '${argv[0]}' with arguments ${JSON.stringify(argv.slice(1))}`;\n            }\n            return { content: [{ name: \"PLAN\", type: \"text\", text: plan }] } as any;\n        }\n        if (isShell) {\n            if (!args?.command_line) {\n                return errorResult(\n                    \"Mode 'shell' requires a non‑empty 'command_line' parameter.\"\n                );\n            }\n            if (args?.argv) {\n                return errorResult(\n                    \"Mode 'shell' does not accept an 'argv' parameter.\"\n                );\n            }\n\n            spawn_options.shell = true\n\n            const command_line = String(args?.command_line)\n            const result = await spawn_wrapped(command_line, [], stdin_input, spawn_options);\n            return resultFor(result);\n        }\n        if (isExecutable) {\n            const argv = args?.argv;\n            if (!Array.isArray(argv) || argv.length === 0) {\n                return errorResult(\n                    \"Mode 'executable' requires a non‑empty 'argv' array.\"\n                );\n            }\n            if (args?.command_line) {\n                return errorResult(\n                    \"Mode 'executable' does not accept a 'command_line' parameter.\"\n                );\n            }\n\n            spawn_options.shell = false\n\n            const command = argv[0]\n            const commandArgs = argv.slice(1);\n\n            const result = await spawn_wrapped(command, commandArgs, stdin_input, spawn_options);\n            return resultFor(result);\n        }\n\n        // TODO... fish shell workaround (see exec-utils.ts) - ADD or FIX via a TEST FIRST\n\n        return errorResult(\"Unexpected execution path in runProcess, should not be possible\");\n    } catch (error) {\n        // TODO check if not SpawnFailure => i.e. test aborting/killing\n        const response = {\n            isError: true,\n            content: messagesFor(error as SpawnFailure),\n        };\n        always_log(\"WARN: run_process failed\", error);\n        return response;\n    }\n\n}\n\n## ~/repos/github/g0t4/mcp-server-commands/tests/integration/dry_run.test.ts:15-34\n        expect((plan as any).text).toContain(\"echo hello\");\n        // PRN mention how is called via child_process\n    });\n\n    test(\"executable mode returns PLAN with argv\", async () => {\n        const result = await runProcess({\n            mode: \"executable\",\n            argv: [\"node\", \"-v\"],\n            dry_run: true,\n        } as any);\n        expect(result.content).toBeDefined();\n        const plan = result.content?.find((c) => c.name === \"PLAN\");\n        expect(plan).toBeDefined();\n        expect(plan?.type).toBe(\"text\");\n        expect((plan as any).text).toContain(\"Executable mode\");\n        expect((plan as any).text).toContain(\"node\");\n        // PRN mention how is called via child_process\n    });\n\n});\n\n\n## ~/repos/github/g0t4/mcp-server-commands/tests/integration/run_process.test.ts:255-274\n                name: \"executable mode without argv\",\n                args: { mode: \"executable\" },\n                expectedMessage:\n                    \"Mode 'executable' requires a non‑empty 'argv' array.\"\n            },\n            {\n                name: \"executable mode with command_line (forbidden)\",\n                args: { mode: \"executable\", argv: [\"date\"], command_line: \"echo hi\" },\n                expectedMessage:\n                    \"Mode 'executable' does not accept a 'command_line' parameter.\"\n            }\n        ];\n\n        test.each(scenarios)(\"$name\", async ({ args, expectedMessage }) => {\n            const result = await runProcess(args as any);\n            expect(result.isError).toBe(true);\n            expect(result.content).toEqual([\n                {\n                    name: \"ERROR\",\n                    type: \"text\",\n\n\n## ~/repos/github/g0t4/mcp-server-commands/tests/integration/run_process.test.ts:45-64\n                    text: \"Hello World\",\n                },\n            ]);\n        });\n    });\n\n    describe(\"when mode=executable+argv is successful\", () => {\n        const request = runProcess({\n            mode: \"executable\",\n            argv: [\"cat\"],\n            input: \"Hello World\",\n        });\n\n        test(\"should not set isError\", async () => {\n            const result = await request;\n\n            expect(result.isError).toBeUndefined();\n        });\n\n        test(\"should include STDOUT from command\", async () => {\n\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```tests/integration/typical-commands.test.ts\nimport { runProcess } from \"../../src/run_process.js\";\n\ndescribe(\"validate common commands work\", () => {\n\n    // TODO! add integration tests of all the common commands you will use\n    //   AND common scenarios of each that materially are affected by how STDIO and process are setup\n    // i.e. grep, sed, fd, ls, pwd, git (status,...?), ...\n\n    describe(\"ripgrep\", () => {\n        test(\"ripgrep shouldn't hang on searching STDIN when there's no STDIN\", async () => {\n            // previously using `child_process.exec()` resulted in `rg` hanging\n            //   b/c rg sees STDIN==socket => sets is_stdin_readable\n            //   => IIUC STDIN never closes => thus rg hangs until timeout\n            //\n            // * `spawn` allows controlling STDIO (unlike `exec`)\n            //   spawn defaults to `pipe` which rg also sees as socket/searchable\n            //   * setting STDIN to `ignore` attaches /dev/null\n            //   => ripgrep doesn't hang now (and is_stdin_readable=false)\n\n            // * --debug output, key output \n            //   > for heuristic stdin detection on Unix, found that is_file=false, is_fifo=false and is_socket=true, \n            //   > and thus concluded that is_stdin_readable=true\\nrg: DEBUG|rg::flags::hiargs\n            const request = runProcess({\n                mode: \"executable\",\n                argv: [\"rg\", <|fim_middle|> \"--debug\", \"foo\"],\n                timeout_ms: 10, // FYI set timeout_ms so you get result object below\n                // if you let test itself timeout, you won't get result object to assert below\n            });\n\n            const result = await request;\n            // console.log(result);\n            expect(result.content).toEqual(\n                expect.arrayContaining([\n                    {\n                        name: \"STDERR\",\n                        type: \"text\",\n                        text: expect.not.stringContaining(\"concluded that is_stdin_readable=true\")\n                    }\n                ])\n            );\n\n        });\n        test(\"ripgrep can search over STDIN when STDIN is provided\", async () => {\n            const result = await runProcess({\n                mode: \"executable\",\n                argv: [\"rg\", \"--no-config\", \"bar\"],\n                input: \"foo\\nbar\\nbaz\",\n                timeout_ms: 5000,\n            });\n            // console.log(result);\n            expect(result.content).toEqual(\n                expect.arrayContaining([{\n                    name: \"STDOUT\",\n                    type: \"text\",\n                    text: \"bar\\n\",\n                }])\n            );\n\n        });\n    });\n\n});\n\n```\n\n## Reminders about the cursor line:\nText before cursor: `                argv: [\"rg\", `\nText after cursor: ` \"--debug\", \"foo\"],`",
        "role":"user"
      }],
    "temperature":1,
    "max_tokens":4096
  }
}