{
  "last_sse":{
    "object":"chat.completion.chunk",
    "timings":{
      "predicted_per_token_ms":4.5349347826087,
      "predicted_per_second":220.5103376205,
      "predicted_n":138,
      "prompt_per_second":4107.5850598378,
      "prompt_n":2440,
      "cache_n":1163,
      "prompt_ms":594.023,
      "prompt_per_token_ms":0.24345204918033,
      "predicted_ms":625.821
    },
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "system_fingerprint":"b7785-1c7cf94b2",
    "id":"chatcmpl-k0tPn6WUsfF9zhGUVV3JjwwC4W7AfdLv",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "created":1769574405
  },
  "response_message":{
    "role":"assistant",
    "content":"            txt = win.gap.crossovers.as_label_string_one_crossover(cross)",
    "finish_reason":"stop",
    "reasoning_content":"We need to fill else branch: when not shift, probably copy single crossover label. Use as_label_string_one_crossover. So code: txt = win.gap.crossovers.as_label_string_one_crossover(cross). Ensure indentation matches. Cursor line has 12 spaces? Actually line shows 12 spaces before <|fim_middle|>. We need to output code at that point. So:\n\n```\ntxt = win.gap.crossovers.as_label_string_one_crossover(cross)\n```\n\nAdd appropriate indentation (12 spaces). Provide just that line."
  },
  "request_body":{
    "max_tokens":4096,
    "top_p":1,
    "temperature":1,
    "options":[],
    "stream":true,
    "raw":false,
    "messages":[{
        "role":"developer",
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n"
      },{
        "role":"user",
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/detects/segments.py:\n        for idx, c in enumerate(self):\n            cp = c.critical_point\n            label = c.min_max_label()\n            rows.append(f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\")\n        return \" | \".join(rows)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        if is_shift(event):\n            # Find the index of the current crossover within the gap.\n            try:\n                idx = win.gap.crossovers.index(cross)\n            except ValueError:\n                idx = -1\n            cp = cross.critical_point\n            label = cross.min_max_label()\n            txt = f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n            idx = win.gap.crossovers.index(cross)\n            cp = cross.critical_point\n            label = cross.min_max_label()\n            txt = f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:84-88\n    def as_label_string_one_crossover(self, cross: CrossoverData):\n        cp = cross.critical_point\n        label = cross.min_max_label()\n        idx = self.index(cross)\n        return f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:60-88\nclass Crossovers(list[\"CrossoverData\"]):\n    \"\"\"Thin ``list`` subclass for :class:`CrossoverData` objects.\n\n    Keeps the full list interface while providing convenience helpers.\n    \"\"\"\n\n    def __init__(self, iterable: list[\"CrossoverData\"] | None = None):\n        super().__init__(iterable or [])\n\n    def critical_points(self) -> list[\"RmsPoint\"]:\n        \"\"\"Return the ``critical_point`` of each stored crossover.\"\"\"\n        return [c.critical_point for c in self]\n\n    def as_label_string(self) -> str:\n        \"\"\"Return a formatted string of labels and critical points:\n              min0:0.12s -3.4dB | max1:0.45s 2.1dB\n        \"\"\"\n        rows = []\n        for idx, c in enumerate(self):\n            cp = c.critical_point\n            label = c.min_max_label()\n            rows.append(f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\")\n        return \" | \".join(rows)\n\n    def as_label_string_one_crossover(self, cross: CrossoverData):\n        cp = cross.critical_point\n        label = cross.min_max_label()\n        idx = self.index(cross)\n        return f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:29-31\n    @property\n    def crosses(self):\n        return self.win.gap.crossovers\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:73-82\n    def as_label_string(self) -> str:\n        \"\"\"Return a formatted string of labels and critical points:\n              min0:0.12s -3.4dB | max1:0.45s 2.1dB\n        \"\"\"\n        rows = []\n        for idx, c in enumerate(self):\n            cp = c.critical_point\n            label = c.min_max_label()\n            rows.append(f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\")\n        return \" | \".join(rows)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:193-212\n\n\n            crossovers = get_material_crossovers(crossovers)\n            win.gap.crossovers = Crossovers(crossovers)\n\n            # TODO listify\n            locator = LeftSpeechTaper_WithOptionalBreathe_Locator()\n            c = GapContext(win, gap_rms, analysis, plotting)\n            locator.locate(c)\n            a = ApplyNotesAsLabelSegments(plotter)\n            a.apply(c)\n\n            if plotting:\n                # * arrows at taper bounds\n\n                if win.gap.left_taper_end:\n                    seconds = win.gap.left_taper_end.time.seconds\n                    rms = analysis.rms_db[analysis.to_hops(seconds)]\n\n                    x_offset = 2 / analysis.fps  # 2 frames\n\n"
      },{
        "role":"user",
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/player/plot_helpers.py\n\n    def pan_up(event: KeyEvent):\n        _pan_y_by_factor(0.1)\n\n    def pan_down(event: KeyEvent):\n        _pan_y_by_factor(-0.1)\n\n    def cycle_fixed_zoom(event: KeyEvent, up: bool = True):\n        FIXED_ZOOM_LEVELS_SECONDS = [0.2, 2, 10, 60]\n        cur = plotter.get_x_limits()\n        try:\n            current_index = next( \\\n                i\n                for i, lvl in enumerate(FIXED_ZOOM_LEVELS_SECONDS)\n                if abs(lvl - cur.width) < 0.1 * lvl\n            )\n        except StopIteration:\n            current_index = -1\n        step = 1 if up else -1\n        next_index = (current_index + step) % len(FIXED_ZOOM_LEVELS_SECONDS)\n        new_width = FIXED_ZOOM_LEVELS_SECONDS[next_index]\n        plotter.zoom_and_center_to(new_width)\n\n    def zoom_x_axis(event: KeyEvent):\n        # FYI shift variant of keys is for faster zoom (hence 0.5)\n        match event.key:\n            case \"=\":\n                zoom_factor = 0.8\n            case \"+\":\n                zoom_factor = 0.5\n            case \"-\":\n                zoom_factor = 1 / 0.8\n            case \"_\":\n                zoom_factor = 1 / 0.5\n            case _:\n                return\n        cur = plotter.get_x_limits()\n        new_width_seconds = cur.width * zoom_factor\n        plotter.zoom_and_center_to(new_width_seconds)\n\n    def zoom_y_axis(event: KeyEvent):\n        # FYI unlike x-axis, no need for fast y-axis zooming\n        match event.key:\n            case \"ctrl+up\":\n                zoom_factor = 0.8\n            case \"ctrl+down\":\n                zoom_factor = 1 / 0.8\n            case _:\n                return\n        cur = plotter.get_y_limits()\n        new_height = cur.height * zoom_factor\n        new_half = new_height / 2\n        # zoom in on the middle (middle stays in the middle) ...\n        # PRN zoom in on mouse position?\n        # - cursor => ratio => scale that ratio so the cursor's y-position points at the same thing before/after\n        # - DO NOT move the cursor's position to the middle?\n        plotter.set_y_limits(cur.middle - new_half, cur.middle + new_half)\n\n    def on_motion_notify_event(event: MouseEvent):\n        # PRN throttle this and cancel previous, would that help with timing?\n        messages = []\n        if event.inaxes is not None:\n            if event.xdata is not None and event.ydata is not None:\n\n                # * mouse coords\n                cursor_seconds = event.xdata\n                cursor_timecode = seconds_to_timecode(cursor_seconds, plotter.analysis.fps)\n                cursor_hops = plotter.analysis.to_hops(cursor_seconds)\n                cursor_db = event.ydata\n                cursor_frames = cursor_seconds * plotter.analysis.fps\n                x_width_seconds = plotter.get_x_limits().width\n                messages += [\n                    f\"x-axis width: {x_width_seconds:.4f}s\",  # ideally this would go elsewhere... fine for now\n                    # FYI try to put almost/always present messages at bottom\n                    f\"cursor: {cursor_timecode} | {cursor_seconds:.2f}s | {cursor_hops:,} hops | {cursor_frames:,.2f} frames\",\n                    f\"              {cursor_db:.1f}dB\",\n                ]\n\n                # * primary window segment\n                window = plotter.analysis.window_at_seconds(cursor_seconds)\n                if window:\n                    l = window.left_speech\n                    r = window.right_speech\n                    g = window.gap\n\n                    def show_relative(seg_start_sec, seg_end_sec):\n                        # show offset relative to primary window segment (i.e. to start/end of gap)\n                        from_sec = cursor_seconds - seg_start_sec\n                        to_sec = cursor_seconds - seg_end_sec\n                        from_hops = from_sec * plotter.analysis.hops_per_second()\n                        to_hops = to_sec * plotter.analysis.hops_per_second()\n                        messages.append(f\"     from start: {from_sec:.4f}s | {from_hops:,.1f} hops\")\n                        messages.append(f\"          to end: {to_sec:.4f}s | {to_hops:,.1f} hops\")\n\n                    if l and l.contains(cursor_seconds):\n                        # TODO standardize on function/property for start_seconds()/end_seconds()/duration_seconds() and cleanup duplication\n                        messages.append(f\"  [speech dur={l.duration_seconds:.2f}s ({l.start_seconds:.2f}s➜{l.end_seconds:.2f}s)]\")\n                        show_relative(l.start_seconds, l.end_seconds)\n                    elif r and r.contains(cursor_seconds):\n                        messages.append(f\"  [speech dur={r.duration_seconds:.2f}s ({r.start_seconds:.2f}s➜{r.end_seconds:.2f}s)]\")\n                        show_relative(r.start_seconds, r.end_seconds)\n                    elif g and g.contains(cursor_seconds):\n                        messages.append(f\"  [gap dur={g.duration_seconds():.2f}s ({g.start_seconds():.2f}s➜{g.end_seconds():.2f}s)]\")\n                        show_relative(g.start_seconds(), g.end_seconds())\n\n        plotter.set_message(messages)\n        event.canvas.draw_idle()\n\n    plotter.fig.canvas.mpl_connect('scroll_event', on_scroll)\n    plotter.fig.canvas.mpl_connect(\"motion_notify_event\", on_motion_notify_event)\n    plotter.fig.canvas.mpl_connect(\"key_press_event\", on_key)\n    plotter.fig.canvas.mpl_connect(\"button_press_event\", plotter._on_click)\n    plotter.fig.canvas.mpl_connect(\"close_event\", on_close)\n\n    def on_pick(event: PickEvent) -> None:\n\n        artist = event.artist\n        if not hasattr(artist, \"cross\"):\n            return\n        cross: CrossoverData = artist.cross\n        win: GapWindow = artist.win\n\n        if is_shift(event):\n            # Use the ``Crossovers`` helper to generate the formatted string.\n            # This keeps the logic in one place and mirrors the earlier manual\n            # construction.\n            txt = win.gap.crossovers.as_label_string()\n        else:\n            <|fim_middle|>\n\n        subprocess.run([\"pbcopy\"], input=txt.encode())\n        plotter.set_message(f\"Copied: {txt}\")\n\n    plotter.fig.canvas.mpl_connect('pick_event', on_pick)\n\n    plotter.toggle_zoom_level_elements()\n\n    def copy_gap_timing_for_notes(event: KeyEvent):\n        # Bail if mouse is not over the axes\n        if event.inaxes != plotter.ax or event.xdata is None:\n            return\n\n        x = event.xdata\n\n        for win in plotter.windows:\n            start = win.gap.start_seconds()\n            end = win.gap.end_seconds()\n            if start <= x <= end:\n                path: Path = plotter.analysis.path\n                filename = path.stem\n\n                txt = f\"{filename}@gap{start:.2f}s-{end:.2f}s\"\n\n                # I have pbcopy aliased on all platforms to a local copy method\n                subprocess.run(['pbcopy'], input=txt.encode())\n\n                plotter.set_message(f\"Copied: {txt}\")\n                return\n\n        plotter.set_message(\"mouse is not over a NonSpeechGap, nothing to copy\")\n```\n\n## Reminders about the cursor line:\nText before cursor: `            `\nText before cursor is all whitespace (do not ignore this)"
      }],
    "model":"gpt-oss:120b",
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  }
}