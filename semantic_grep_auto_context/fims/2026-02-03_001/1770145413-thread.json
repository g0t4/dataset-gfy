{
  "last_sse":{
    "timings":{
      "prompt_per_token_ms":0.25487352812909,
      "predicted_n":324,
      "prompt_per_second":3923.5145655987,
      "prompt_n":2293,
      "cache_n":1434,
      "predicted_per_second":141.12032990797,
      "predicted_per_token_ms":7.0861512345679,
      "predicted_ms":2295.913,
      "prompt_ms":584.425
    },
    "created":1770145413,
    "object":"chat.completion.chunk",
    "choices":[{
        "finish_reason":"stop",
        "delta":[],
        "index":0
      }],
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-gTOvu4t0ngDzKYjwIdBnyy2YO1u02dvo",
    "system_fingerprint":"b7785-1c7cf94b2"
  },
  "request_body":{
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. then the CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:29-110\n@dataclass\nclass CrossoverData:\n    crossover: Crossover\n\n    before: AVTime\n    middle: AVTime\n    after: AVTime\n\n    min: RmsPoint\n    max: RmsPoint\n\n    after_diff_value: float\n\n    def __init__(self, crossover: Crossover, diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = AVTime(diff_stride2_gated.times[crossover.after_index], analysis)\n        self.before = AVTime(diff_stride2_gated.times[crossover.before_index], analysis)\n        self.after_diff_value = diff_stride2_gated.values[crossover.after_index]\n\n        self.middle = AVTime(\n            (self.before.seconds + self.after.seconds) / 2,\n            analysis,\n        )\n\n        # get rms values (not stride 2 btw, so make sure to map via time/hops, not array offsets)\n        rms_segment = analysis.rms_slice(\n            analysis.to_hops(self.before.seconds),\n            analysis.to_hops(self.after.seconds),\n        )\n\n        # min makes most sense for upward crossover (rampup)\n        min_idx = np.argmin(rms_segment.values)\n        self.min = RmsPoint(\n            AVTime(rms_segment.times[min_idx], analysis),\n            rms_segment.values[min_idx],\n        )\n\n        # max makes most sense for downward crossover (taper)\n        max_idx = np.argmax(rms_segment.values)\n        self.max = RmsPoint(\n            AVTime(rms_segment.times[max_idx], analysis),\n            rms_segment.values[max_idx],\n        )\n\n    @property\n    def cp(self) -> RmsPoint:\n        \"\"\"\n        aliases critical_point\n        - for cases where code gets absurdly long\n        - thus use this for readability (avoids super long lines)\n        \"\"\"\n        return self.critical_point\n\n    @property\n    def critical_point(self) -> RmsPoint:\n        \"\"\"\n        critical RMS value of the crossover.\n        1. for upward crossovers (ramp‑up) the minimum RMS is the critical point\n        2. for downward crossovers (taper) the maximum RMS is the critical point\n        \"\"\"\n        return self.min if self.is_upward() else self.max\n\n    def is_local_min(self) -> bool:\n        return self.is_upward()\n\n    def is_upward(self) -> bool:\n        return self.after_diff_value > 0\n\n    def is_local_max(self) -> bool:\n        return self.is_downward()\n\n    def is_downward(self) -> bool:\n        return self.after_diff_value < 0\n\n    def min_max_label(self) -> str:\n        return \"min\" if self.is_local_min() else \"max\"\n\n    def label(self) -> str:\n        label = self.min_max_label()\n        cp = self.critical_point\n        return f\"{label}{cp.time.seconds:.4f}s {cp.rms:.2f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:100-104\n    def as_label_string_one_crossover(self, cross: \"CrossoverData\"):\n        cp = cross.critical_point\n        label = cross.min_max_label()\n        idx = self.index(cross)\n        return f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:27-46\n\n\n@dataclass\nclass CrossoverData:\n    crossover: Crossover\n\n    before: AVTime\n    middle: AVTime\n    after: AVTime\n\n    min: RmsPoint\n    max: RmsPoint\n\n    after_diff_value: float\n\n    def __init__(self, crossover: Crossover, diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = AVTime(diff_stride2_gated.times[crossover.after_index], analysis)\n        self.before = AVTime(diff_stride2_gated.times[crossover.before_index], analysis)\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:76-104\nclass Crossovers(list[\"CrossoverData\"]):\n    \"\"\"Thin ``list`` subclass for :class:`CrossoverData` objects.\n\n    Keeps the full list interface while providing convenience helpers.\n    \"\"\"\n\n    def __init__(self, iterable: list[\"CrossoverData\"] | None = None):\n        super().__init__(iterable or [])\n\n    def critical_points(self) -> list[\"RmsPoint\"]:\n        \"\"\"Return the ``critical_point`` of each stored crossover.\"\"\"\n        return [c.critical_point for c in self]\n\n    def as_label_string(self) -> str:\n        \"\"\"Return a formatted string of labels and critical points:\n              min0:0.12s -3.4dB | max1:0.45s 2.1dB\n        \"\"\"\n        rows = []\n        for idx, c in enumerate(self):\n            cp = c.critical_point\n            label = c.min_max_label()\n            rows.append(f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\")\n        return \" | \".join(rows)\n\n    def as_label_string_one_crossover(self, cross: \"CrossoverData\"):\n        cp = cross.critical_point\n        label = cross.min_max_label()\n        idx = self.index(cross)\n        return f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:42-72\n    def __init__(self, crossover: Crossover, diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = AVTime(diff_stride2_gated.times[crossover.after_index], analysis)\n        self.before = AVTime(diff_stride2_gated.times[crossover.before_index], analysis)\n        self.after_diff_value = diff_stride2_gated.values[crossover.after_index]\n\n        self.middle = AVTime(\n            (self.before.seconds + self.after.seconds) / 2,\n            analysis,\n        )\n\n        # get rms values (not stride 2 btw, so make sure to map via time/hops, not array offsets)\n        rms_segment = analysis.rms_slice(\n            analysis.to_hops(self.before.seconds),\n            analysis.to_hops(self.after.seconds),\n        )\n\n        # min makes most sense for upward crossover (rampup)\n        min_idx = np.argmin(rms_segment.values)\n        self.min = RmsPoint(\n            AVTime(rms_segment.times[min_idx], analysis),\n            rms_segment.values[min_idx],\n        )\n\n        # max makes most sense for downward crossover (taper)\n        max_idx = np.argmax(rms_segment.values)\n        self.max = RmsPoint(\n            AVTime(rms_segment.times[max_idx], analysis),\n            rms_segment.values[max_idx],\n        )\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/detects/moot_tests.py\nimport pytest\n\nfrom auto_edit.new_silence.detects.crossings import CrossoverData\nfrom auto_edit.new_silence.detects.moot import get_material_crossovers\n\nclass _FakeTime:\n\n    def __init__(self, hops: int, seconds: float):\n        self.hops = hops\n        self.seconds = seconds\n\nclass _FakeCP:\n\n    def __init__(self, time: _FakeTime, rms: float):\n        self.time = time\n        self.rms = rms\n\nclass _FakeCrossoverData:\n    \"\"\"Minimal stand‑in for :class:`CrossoverData` used by ``is_moot``.\n\n    Only the attributes accessed by ``is_moot`` are provided: ``cp`` and\n    ``min_max_label``.\n    \"\"\"\n\n    def __init__(self, label: str, hops: int, seconds: float, rms: float):\n        self._label = label\n        self.cp = _FakeCP(_FakeTime(hops, seconds), rms)\n\n    def min_max_label(self) -> str:\n        return self._label\n\ndef _make(label: str, hops: int, seconds: float, rms: float) -> CrossoverData:\n    \"\"\"Factory for fake crossover data.\n\n    ``label`` should be either ``\"min\"`` or ``\"max\"``.\n    \"\"\"\n    return _FakeCrossoverData(label, hops, seconds, rms) # <|fim_middle|>\n\nclass TestMootMaterialCrossovers:\n\n    def test_three_crossovers_no_moots(self):\n        cps = [\n            _make(\"min\", 0, 0.0, -60.0),\n            _make(\"max\", 100, 0.100, -55.0),\n            _make(\"min\", 200, 0.200, -50.0),\n        ]\n        result = get_material_crossovers(cps)\n        assert len(result) == 3\n\n    def test_five_crossovers_no_moots(self):\n        cps = [\n            _make(\"min\", 0, 0.0, -70.0),\n            _make(\"max\", 100, 0.100, -65.0),\n            _make(\"min\", 200, 0.200, -60.0),\n            _make(\"max\", 300, 0.300, -55.0),\n            _make(\"min\", 400, 0.400, -50.0),\n        ]\n        result = get_material_crossovers(cps)\n        assert len(result) == 5\n\n    def test_five_crossovers_with_moot_pair(self):\n        cps = [\n            _make(\"min\", 0, 0.0, -70.0),  # min1\n            _make(\"max\", 100, 0.100, -68.5),  # max2 (far enough to avoid moot)\n            _make(\"min\", 104, 0.104, -68.0),  # min3 (still moot pair with max2 based on db diff)\n            _make(\"max\", 200, 0.200, -60.0),  # max4 (non‑moot spacing ≥100)\n            _make(\"min\", 300, 0.300, -55.0),  # min5\n        ]\n        result = get_material_crossovers(cps)\n        # pair should be removed, leaving three material crossovers\n        assert len(result) == 3\n\n    def test_seven_crossovers_with_moot_trio_maximum(self):\n        cps = [\n            _make(\"min\", 0, 0.0, -80.0),  # min1\n            _make(\"max\", 100, 0.100, -78.0),  # max2 (far enough to avoid moot)\n            _make(\"min\", 104, 0.104, -78.3),  # min3\n            _make(\"max\", 108, 0.108, -77.5),  # max4\n            _make(\"min\", 130, 0.130, -70.0),  # min5\n            _make(\"max\", 200, 0.200, -65.0),  # max6 (non‑moot spacing ≥100)\n            _make(\"min\", 300, 0.300, -60.0),  # min7\n        ]\n        result = get_material_crossovers(cps)\n        # Expected future length 5, but current implementation removes all three moot points → length 4\n        assert len(result) == 5\n\n    def test_seven_crossovers_with_moot_trio_minimum(self):\n        cps = [\n            _make(\"min\", 0, 0.0, -80.0),  # min1\n            _make(\"max\", 100, 0.100, -70.0),  # max2 (far enough to avoid moot)\n            _make(\"min\", 104, 0.104, -71.0),  # min3 (candidate)\n            _make(\"max\", 108, 0.108, -70.5),  # max4 (candidate)\n            _make(\"min\", 112, 0.112, -71.2),  # min5 (candidate)\n            _make(\"max\", 200, 0.200, -65.0),  # max6 (non‑moot spacing ≥100)\n            _make(\"min\", 300, 0.300, -60.0)\n        ]\n        result = get_material_crossovers(cps)\n        # Future behavior would keep a single minimum, resulting in length 5, but current code gives 4\n        assert len(result) == 5\n```\n\n## Reminders about the cursor line:\nText before cursor: `    return _FakeCrossoverData(label, hops, seconds, rms) # `",
        "role":"user"
      }],
    "stream":true,
    "top_p":1,
    "max_tokens":4096,
    "options":[],
    "raw":false,
    "model":"gpt-oss:120b",
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "temperature":1
  },
  "response_message":{
    "finish_reason":"stop",
    "content":"type: ignore[return-value]",
    "reasoning_content":"We need to replace <|fim_middle|> with appropriate return type cast? The function _make returns CrossoverData but we are returning _FakeCrossoverData instance. Should cast to CrossoverData type via typing cast: return _FakeCrossoverData(... )  # type: ignore[return-value] maybe. Simpler: return _FakeCrossoverData(label, hops, seconds, rms)  # noqa: E501\n\nBut need to match type hint: def _make(... ) -> CrossoverData: So return _FakeCrossoverData(...). That's fine. Probably no extra code. Just nothing after comment. So replace with nothing? Actually cursor after \"# \". We need to insert appropriate comment or remove space? Probably just return the instance, comment stays. So nothing to add. But need to delete trailing space? The line currently: return _FakeCrossoverData(label, hops, seconds, rms) # <|fim_middle|>\n\nWe need to place code after #? No, the comment marker is before cursor. Actually line: return _FakeCrossoverData(label, hops, seconds, rms) # <|fim_middle|>\n\nSo we need to replace <|fim_middle|> with maybe \"type: ignore\" or nothing. Probably add \"type: ignore\" to silence type checker. So: type: ignore[return-value] . So final line: return _FakeCrossoverData(label, hops, seconds, rms) # type: ignore[return-value]\n\nThus fill.",
    "role":"assistant"
  }
}