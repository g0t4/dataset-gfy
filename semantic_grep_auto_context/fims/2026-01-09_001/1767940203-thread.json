{
  "last_sse":{
    "created":1767940203,
    "timings":{
      "cache_n":483,
      "prompt_per_token_ms":0.2272119589469,
      "predicted_ms":423.572,
      "predicted_per_token_ms":5.3616708860759,
      "predicted_per_second":186.50902325933,
      "predicted_n":79,
      "prompt_per_second":4401.1767894387,
      "prompt_n":2241,
      "prompt_ms":509.182
    },
    "choices":[{
        "index":0,
        "delta":[],
        "finish_reason":"stop"
      }],
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7616-18ddaea2a",
    "id":"chatcmpl-iaGRRNLCCHMe5gkr8zMR8eWNGkGiNl5C",
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "reasoning_content":"We need to fill max point. After computing min, need max similar. Compute max_idx = start_idx + np.argmax(segment). Then self.max = _Point(...). Also maybe need return. So insert code.",
    "role":"assistant",
    "content":"max_idx = start_idx + np.argmax(segment)\nself.max = _Point(series.times[max_idx], values[max_idx], analysis)",
    "finish_reason":"stop"
  },
  "request_body":{
    "stream":true,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/detects/crossings.py:\n    min: _Point\n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/standalone.py:23-42\n\n\n        print(f'{segment=}')\n        start_seconds = segment.start_seconds\n        end_seconds = segment.end_seconds\n\n        # * play literal audio samples without any frame rounding\n\n        start_sample = int(start_seconds * analysis.sample_rate)\n        end_sample = int(end_seconds * analysis.sample_rate)\n        play_samples(analysis, start_sample, end_sample)\n        time.sleep(1)\n\n        start_frame = start_seconds * analysis.fps\n        start_frame_before = math.floor(start_frame)\n        start_frame_after = math.ceil(start_frame)\n        rich.print(f\"{start_frame_before=}, {start_frame=}, {start_frame_after=}\")\n\n        end_frame = end_seconds * analysis.fps\n        end_frame_before = math.floor(end_frame)\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:199-218\n            start_hops = analysis.to_hops(start_time)\n            first_crossover = crossovers[0]\n            # KEEP IN MIND INDEXES are STRIDE2 => go to time first and back to hop/index for other lookups\n            # end_idx = first_crossover.crossover.before_index  # TODO find minima\n            end_time = diff_stride2_gated.times[first_crossover.crossover.after_index]\n            # TODO MOVE HOPS IN\n            end_hops = analysis.to_hops(end_time)\n            rms = analysis.rms_slice(start_hops, end_hops)\n            plot(rms.times, rms.values, color=\"brown\", linewidth=4)\n            minima_index = np.argmin(rms.values)\n            minima_value = rms.values[minima_index]\n            minima_time = rms.times[minima_index]\n            plot([minima_time, minima_time], [minima_value - 5, minima_value + 5])\n\n            # * THEN classify virtual gap sub-segments\n            prev_crossover = None\n            for crossover in crossovers:\n                # * look at slope of curve to determine if likely breathing hump\n                #   duration matters, start with > 120ms and < 500ms\n                #   ALSO keep in mind you should keep existing breathing detection logic in place\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/spectral_analysis.py:52-60\ndef analyze_segment_spectrally(\n    analysis: AudioAnalysisResult,\n    segment: DetectedSegment,\n) -> SpectralFeatures:\n    return extract_features_from_interval(\n        analysis,\n        segment.start_seconds,\n        segment.end_seconds,\n    )\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/spectral_analysis.py:62-89\ndef extract_features_from_interval(\n    analysis: AudioAnalysisResult,\n    start_seconds: float,\n    end_seconds: float,\n) -> SpectralFeatures:\n\n    start_idx = int(start_seconds * analysis.sample_rate)\n    end_idx = int(end_seconds * analysis.sample_rate)\n    samples = analysis.audio.samples[start_idx:end_idx]\n\n    centroid = librosa.feature.spectral_centroid(y=samples, sr=analysis.sample_rate, hop_length=analysis.hop_length)[0]\n\n    bandwidth = librosa.feature.spectral_bandwidth(y=samples, sr=analysis.sample_rate, hop_length=analysis.hop_length)[0]\n\n    rolloff = librosa.feature.spectral_rolloff(y=samples, sr=analysis.sample_rate, hop_length=analysis.hop_length, roll_percent=0.85)[0]\n\n    zcr = librosa.feature.zero_crossing_rate(samples, hop_length=analysis.hop_length)[0]\n\n    return SpectralFeatures(\n        centroid_mean=float(np.mean(centroid)),\n        centroid_std=float(np.std(centroid)),\n        bandwidth_mean=float(np.mean(bandwidth)),\n        rolloff_mean=float(np.mean(rolloff)),\n        zcr_mean=float(np.mean(zcr)),\n        samples=samples,\n        start_seconds=start_seconds,\n        end_seconds=end_seconds,\n    )\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:82-131\ndef __init__(\n        self,\n        analysis: AudioAnalysisResult,\n        segments_subset: list[DetectedSegment] | None = None,\n        windows_subset: list[GapWindow] | None = None,\n    ):\n        self.analysis = analysis\n        # simple idea => pass a subset of either OR just use all available on the analysis\n\n        self.aligned_markers = []\n        self.arrows = []\n\n        self.segments = segments_subset or []\n        self.windows = windows_subset or []\n\n        plt.style.use(\"dark_background\")\n\n        plt.rcParams.update({\n            # or can I shrink toolbar? status bar like?\n            \"toolbar\": \"none\",\n            \"axes.titlesize\": 8,\n            \"axes.labelsize\": 8,\n            \"xtick.labelsize\": 8,\n            \"ytick.labelsize\": 8,\n        })\n\n        self.fig, (self.ax) = plt.subplots(\n            figsize=(20, 10),\n            constrained_layout=True,\n        )\n\n        self.message_text = self.fig.text(\n            0.05,  # x-offset ratio (0 = left, 1 = right) \n            # FYI 0.10 gives me ~10 lines @ 8pt font\n            #  use 0.15 => 5% padding to not overlap x-axis on bottom, and then leave room for ~10 lines\n            #  if need more, reposition mouse to hover over less stuff!\n            0.05,  # y-offset ratio (0 = bottom, 1 = top)\n            \"\",\n            ha=\"left\",\n            va=\"bottom\",\n            fontsize=8,\n            color=\"white\",\n        )\n\n        facecolor = \"#202124\"\n        self.ax.set_facecolor(facecolor)  # almost black, very neutral\n        self.fig.set_facecolor(facecolor)\n\n        self._setup_plot()\n        setup_events(self)\n",
        "role":"user"
      },{
        "content":"Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\nfrom __future__ import annotations\nfrom dataclasses import dataclass\nimport numpy as np\nfrom numpy.typing import NDArray\nfrom auto_edit.new_silence.detects.segments import AudioAnalysisResult\nfrom auto_edit.new_silence.detects.time_series import TimeSeries\n\n#   IDEA => look for zero crossovers to find minima\n#   *** works BETTER!! (no delays)\n#   - removes noise near zero slope\n#   - better fit for exactly when the plot turns upward! unlike uniform_filter1d\n#     - uniform_filter1d (moving average) results in premature (shifted) crossovers\n#       b/c spike (i.e. rampup) pulls up points way ahead of it\n\n@dataclass(frozen=True, slots=True)\nclass Crossover:\n    \"\"\"Represent a zero‑crossing event.\n\n    Attributes\n    ----------\n    before_index: int\n        Index of the sample just before the sign change.\n    after_index: int\n        Index of the sample just after the sign change.\n    \"\"\"\n\n    before_index: int\n    after_index: int\n\nclass _Point:\n    __slots__ = (\"seconds\", \"hops\", \"frames\", \"value\")\n\n    def __init__(self, seconds: float, value: float, analysis: \"AudioAnalysisResult\"):\n        self.seconds = seconds\n        self.hops = int(round(seconds * analysis.hops_per_second(), 8))\n        self.frames = self.hops / analysis.hops_per_frame()\n        self.value = value\n\n@dataclass\nclass CrossoverData:\n    crossover: Crossover\n    after: _Point\n    before: _Point\n    middle: _Point\n    min: _Point\n    max: _Point\n\n    def __init__(self, crossover: Crossover, series: \"TimeSeries\", values: NDArray[np.float32], analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = _Point(series.times[crossover.after_index], values[crossover.after_index], analysis)\n        self.before = _Point(series.times[crossover.before_index], values[crossover.before_index], analysis)\n\n        self.middle = _Point(\n            (self.before.seconds + self.after.seconds) / 2,\n            (self.before.value + self.after.value) / 2,\n            analysis,\n        )\n\n        start_idx = crossover.before_index\n        end_idx = crossover.after_index\n        segment = values[start_idx:end_idx + 1]\n\n        min_idx = start_idx + np.argmin(segment)\n        self.min = _Point(series.times[min_idx], values[min_idx], analysis)\n        <|fim_middle|>\n\n    def is_upward(self) -> bool:\n        return self.after.value > 0\n\ndef build_crossovers(series: \"TimeSeries\", values, analysis: \"AudioAnalysisResult\"):\n    return [CrossoverData(cross, series, values, analysis) for cross in zero_crossings(series.values)]\n\ndef zero_crossings(signal) -> list[Crossover]:\n    \"\"\"Detect zero‑crossings in *signal*.\n\n    Returns a list of :class:`Crossover` objects where ``before`` is the index\n    of the last sample with the previous sign and ``after`` is the index of the\n    first sample with the new sign.\n    \"\"\"\n    signs = np.sign(signal)  # -1, 0, +1\n\n    crossing_indices: list[Crossover] = []\n    previous_nonzero_sign = 0\n    previous_nonzero_sign_index = 0\n\n    for index, current_sign in enumerate(signs):\n        # skip zeros\n        if current_sign == 0:\n            continue\n\n        # initialise on first non‑zero sign\n        if previous_nonzero_sign == 0:\n            previous_nonzero_sign = current_sign\n            previous_nonzero_sign_index = index\n            continue\n\n        if current_sign != previous_nonzero_sign:\n            # sign change detected\n            crossing_indices.append(Crossover(previous_nonzero_sign_index, index))\n            previous_nonzero_sign = current_sign\n            previous_nonzero_sign_index = index\n        else:\n            # same sign (plateau), move the \"before\" pointer forward\n            previous_nonzero_sign_index = index\n\n    return crossing_indices",
        "role":"user"
      }],
    "options":[],
    "raw":false,
    "max_tokens":4096,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "top_p":1,
    "temperature":1,
    "model":"gpt-oss:120b"
  }
}