{
  "response_message":{
    "reasoning_content":"Need to fill diff value. Compute -76.9973 - -77.6351 = 0.6378 approx. Probably 0.6378dB. Provide numeric. No extra.",
    "role":"assistant",
    "finish_reason":"stop",
    "content":"0.6378dB"
  },
  "request_body":{
    "temperature":1,
    "stream":true,
    "top_p":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "options":[],
    "raw":false,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/tests/integration_tests.py:\n54.7208\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/learn.py:82-101\n    # 20*log10(1/1000) = 20*10^-3\n    # 20*10^-3, 20*10^-2, 20*10^-1, 20\n    # -60, -40, -20, 0\n    ref = 1000.\n    lr_dbfs = librosa.amplitude_to_db(S=values, ref=ref)\n    print(f'{lr_dbfs=}')\n    my_dbfs = to_dbfs(values, full_scale_aka_max_possible_value=ref)\n    print(f'{my_dbfs=}')\n    assert np.allclose(my_dbfs, lr_dbfs)\n\n    # ***! dBFS where FULL SCALE == 100_000\n    # same inputs => diff dB values b/c \"full scale\" definition has changed\n    #  this is a RELATIVE SCALE\n    ref = 100_000.\n    lr_dbfs = librosa.amplitude_to_db(S=values, ref=ref)\n    print(f'{lr_dbfs=}')\n    my_dbfs = to_dbfs(values, full_scale_aka_max_possible_value=ref)\n    print(f'{my_dbfs=}')\n    assert np.allclose(my_dbfs, lr_dbfs)\n\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/learn.py:69-102\ndef test_db():\n\n    # ***! dB (no ref)\n    # 20*log10(x)\n    # 0, 20, 40, 60\n    values = np.array([1., 10., 100., 1000.])\n    lr_db = librosa.amplitude_to_db(S=values)  # no ref == NOT dBFS\n    print(f'{lr_db=}')\n    my_db = [to_db(v) for v in values]\n    print(f'{my_db=}')\n    assert np.allclose(my_db, lr_db)\n\n    # ***! dBFS\n    # 20*log10(1/1000) = 20*10^-3\n    # 20*10^-3, 20*10^-2, 20*10^-1, 20\n    # -60, -40, -20, 0\n    ref = 1000.\n    lr_dbfs = librosa.amplitude_to_db(S=values, ref=ref)\n    print(f'{lr_dbfs=}')\n    my_dbfs = to_dbfs(values, full_scale_aka_max_possible_value=ref)\n    print(f'{my_dbfs=}')\n    assert np.allclose(my_dbfs, lr_dbfs)\n\n    # ***! dBFS where FULL SCALE == 100_000\n    # same inputs => diff dB values b/c \"full scale\" definition has changed\n    #  this is a RELATIVE SCALE\n    ref = 100_000.\n    lr_dbfs = librosa.amplitude_to_db(S=values, ref=ref)\n    print(f'{lr_dbfs=}')\n    my_dbfs = to_dbfs(values, full_scale_aka_max_possible_value=ref)\n    print(f'{my_dbfs=}')\n    assert np.allclose(my_dbfs, lr_dbfs)\n\n    # TIP => set ref = MAX_POSSIBLE_VALUE_NORMALIZED_AUDIO (not just max value of a given set of values)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/learn.py:60-61\ndef to_db(value):\n    return 20 * np.log10(value)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/fcpxml/audio_effects.py:2-5\ndef adjust_volume(clip: ET.Element, dB=-96):\n    # https://developer.apple.com/documentation/professional-video-applications/adjust-volume\n    # PRN move this to a clip builder?\n    ET.SubElement(clip, \"adjust-volume\", amount=f\"{dB:.1f}dB\")\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/learn.py:63-67\ndef to_dbfs(value, full_scale_aka_max_possible_value):\n    # assuming value <= max_value => then result <= 0 (negative)\n    #  b/c log10(1) == 0 (aka 10^0 == 1)\n    #  and log10(0 < value < 1) => -negative\n    return to_db(value / full_scale_aka_max_possible_value)\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/tests/integration_tests.py\nimport subprocess\nimport pytest\nimport os\nimport rich\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom auto_edit.new_silence.detects.breathing import mark_breathing\nfrom auto_edit.new_silence.player.segment_plotter import SegmentPlotter\nfrom auto_edit.silences.align import AlignedSilencePeriod, align_silences_to_frame_boundaries_asymmetric_pad_WIP\nfrom auto_edit.new_silence.detect import full_analysis\nfrom auto_edit.new_silence.tests.analysis_loader import get_full_analysis\nfrom auto_edit.silences.detect_raw import ffmpeg_detect_silence_raw\nfrom auto_edit.tests.test_files import gptoss_fim_video, gptoss_fim_examples\nfrom auto_edit.new_silence.detects.detectors.ideas import GapContext, LeftSpeechTaper_WithOptionalBreathe_Locator\n\ndef only_has_taper(window, left, right):\n    assert window.gap.left_taper_end\n    assert window.gap.right_taper_start\n    assert window.gap.left_taper_end.time.seconds == pytest.approx(left, 0.001)\n    assert window.gap.right_taper_start.time.seconds == pytest.approx(right, 0.001)\n\ndef analysis2():\n    return get_full_analysis(\"minute2\")\n\ndef analysis3():\n    return get_full_analysis(\"minute3\")\n\ndef analysis4():\n    return get_full_analysis(\"minute4\")\n\ndef analysis5():\n    return get_full_analysis(\"minute5\")\n\ndef analysis6():\n    return get_full_analysis(\"minute6\")\n\ndef analysis7():\n    return get_full_analysis(\"minute7\")\n\ndef analysis8():\n    return get_full_analysis(\"minute8\")\n\ndef analysis9():\n    return get_full_analysis(\"minute9\")\n\nclass TestSimpleBreathingHumpIsIt:\n    # min0:54.3500s -57.7805dB | max1:54.4312s -45.5440dB | min2:54.7208s -77.6351dB | max3:54.7224s -76.9973dB | min4:54.7724s -87.6577dB\n    # really is just 3 critical points... two are local tiny minimas that slipped past my gate threshold...\n    # but it is easy to see min3-min2 = 0.0016  that is too small to matter  \n    #   plus dB values diff -76.9973 - -77.6351dB = <|fim_middle|>\n    pass\n\nclass TestDoubleHumpBreathing:\n\n    def test_minute7(self):\n\n        # * minute7 @ gap 2.24s-2.69s\n        win = analysis7().window_at_seconds(2.5)\n        assert len(win.gap.crossovers) == 5\n        # min0:2.2563s -45.4338dB | max1:2.2922s -37.2346dB | min2:2.3318s -60.0556dB | max3:2.4484s -36.8458dB | min4:2.6505s -57.7990dB\n        # * first hump (~90ms) speech => right side marked via left_taper_end\n        only_has_taper(win, 2.3318, 2.65)\n        # * last hump (~320ms) breathing => mark breathing\n        # assert win.breathing # TODO! this plus taper means second hump is breathing\n        #\n        # * minute7 @ end\n        # min0:57.1823s -50.2647dB | max1:57.2250s -37.2680dB | min2:57.2734s -60.6908dB | max3:57.3516s -43.6907dB | min4:57.5021s -84.7101dB\n        win = analysis7().window_at_seconds(57.4)\n        assert len(win.gap.crossovers) == 5\n        # * first hump => thru 57.2734\n        only_has_taper(win, 57.2734, 57.5021)\n        # * second hump (228.7ms wide)\n        # TODO! assert win.breathing\n\n    def test_minute4(self):\n        # * minute4 @ 7sec\n        win = analysis4().window_at_seconds(7)\n        assert win\n        assert len(win.gap.crossovers) == 5\n        # taper speech: min0:6.7313s -39.1357dB | max1:6.7646s -34.6303dB |\n        # breathing: min2:6.8302s -75.8738dB | max3:6.9896s -38.2408dB | min4:7.2562s -73.8155dB\n        assert win.gap.left_taper_end.time.seconds == pytest.approx(6.8302, 0.001)\n        assert win.gap.right_taper_start.time.seconds == pytest.approx(7.2562, 0.001)\n        # TODO! assert win.breathing\n\n    def test_minute4_41sec_type_plus_breath_is_NOT_taper_speech_plus_breathe(self):\n        # FYI middle dip (min2) is higher than min0 thus not taper, so, GOOD TO GO!\n        # * minute4 @ 41sec\n        # taper speech: min0:40.4917s -66.5900dB | max1:40.5344s -53.3388dB\n        # breathing: min2:40.5620s -61.4494dB | max3:40.7120s -47.2397dB | min4:41.0526s -93.7939dB       #\n        win = analysis4().window_at_seconds(41)\n        only_has_taper(win, 40.4917, 41.0526)  # FYI middle hump higher b/c it is typing + breathing... SO, GOOD TO GO SO FAR\n        # TODO assert this is going to be muted? should I move tests of that here?\n        assert not win.breathing  # TODO is this the right test?\n\n    def test_minute3_30s_is_not_taper_plus_breathe(self):\n        # has 5 crossovers, but middle hump rises up and that's not a breath+taper scenario\n        #    *** middle dip being higher should eliminate this one rule wise\n        #    and they are really short (duration) - first part of 2nd hump is 30ms wide... last part is really wide but it is b/c it is bottomed out and no more mins then\n        win = analysis3().window_at_seconds(30)\n        #\n        # * first hump not detected as taper\n        # min0:29.8078s -56.8553dB | max1:29.8615s -42.0888dB | min2:29.9016s -48.1808dB | max3:29.9323s -41.7483dB | min4:30.0953s -93.1029dB\n        # min0 is left taper, min4 is right:\n        only_has_taper(win, 29.8078, 30.0953)\n        #\n        assert not win.breathing\n\n    def test_minute5_at_1s__click_plus_breathe(self):\n        # this is fine to be identified as taper but\n        #  if I wanna reject it as taper, for left \"box\"... the hump is a square like shape!\n        #   then use the square like shape to do so!\n        #   spike in diff on both sides + nearly zero w/o even needing gating b/w sies...\n        #    this would be easy to identify and ignore\n        #    min0:1.0510s -69.0196dB | max1:1.0557s -61.5602dB | min2:1.1151s -75.2651dB | max3:1.3271s -53.4800dB | min4:1.5109s -78.3788dB\n        #     btw massive negative spike in the diff is probably unique here... that alone + spike on way up might be enough... ?\n        pass\n        # TODO identify and exclude taper on left?\n        # woa this is one of those clicks I hate! what caused this?\n        #   IDENTIFY THIS AND NUKE IT!\n\nclass TestTaperSearch:\n\n    def test_double_hump_NOT_detected_as_taper_nor_breathing(self):\n        # ~43.7 seconds\n        #  use duration and/OR middle min is higher than first min (left) ... use that! too?\n        #  min0:43.6906s -49.73dB | max1:43.7328s -34.39dB | min2:43.7630s -41.11dB | max3:43.7896s -36.46dB | min4:43.8312s -47.59dB\n        #    btw each CP is numberd 0+ ... I am not numbering min/max separately\n        win = analysis7().window_at_seconds(43.7)\n        assert len(win.gap.crossovers) == 5\n        min0 = pytest.approx(43.6906, 0.001)\n        assert win.gap.left_taper_end  # thru min0 (not min1)\n        assert win.gap.left_taper_end.time.seconds == min0\n        # assert not win.breathing\n\n    def test_taper_then_typing__in_wide_gap__DOES_DETECT_TAPER_at_start(self):\n        # observations:\n        #     - this bottoms out (literally) at -94dB (basically zero, is zero on my mixpre6 w/ noisegate)\n        #     - so far the taper always continues while subsequent mins are lower than before (no increase in mins so far)\n        #        - stop when mins bottom/level out then?\n        #        - here you can see 5th min is -92.2 so that is higher/same\n        #           rest of critical points:\n        #               | max3:47.1578s -75.21dB | min4:47.2547s -92.15dB\n        #               | max5:47.2995s -64.94dB | min6:47.3948s -86.97dB\n        #               | max7:47.4391s -70.06dB | min8:47.4510s -73.06dB\n        #               | max9:47.4568s -71.34dB | min10:47.5854s -92.47dB\n        #               | max11:47.6906s -69.59dB | min12:47.9583s -94.30dB\n        #               | max13:48.0708s -60.13dB | min14:48.0849s -65.05dB\n        #               | max15:48.1755s -43.56dB | min16:48.5620s -78.97dB\n        # #     - Ideally I'd like to see cut off at cp3 (min) at -94dB\n        #       * in this case doesn't matter how I round the frame!\n        #     - ? will taper's always stop at a 3rd minimum?\n        #     -   do I have any examples of tapers that go beyond that?\n        #     -   PRN add logging to detect if it happens and flag it?\n        #          basically I could be adding _minimal_ logging of assumptions (or potential assumptions)\n        #\n        #     rest of critical points are from typing, not that important:\n        win = analysis7().window_at_seconds(46.32)\n        # min0:46.3167s -47.29dB | max1:46.3505s -39.15dB | min2:46.6266s -94.30dB\n        min0 = pytest.approx(46.3167, 0.001)\n        max1 = pytest.approx(46.3505, 0.001)\n```\n\n## Reminders about the cursor line:\nText before cursor: `    #   plus dB values diff -76.9973 - -77.6351dB = `",
        "role":"user"
      }],
    "model":"gpt-oss:120b",
    "max_tokens":4096
  },
  "last_sse":{
    "created":1769078528,
    "timings":{
      "predicted_per_second":213.26349265738,
      "predicted_n":57,
      "prompt_per_second":5649.5985098902,
      "prompt_n":3755,
      "prompt_ms":664.649,
      "prompt_per_token_ms":0.17700372836218,
      "predicted_ms":267.275,
      "predicted_per_token_ms":4.6890350877193,
      "cache_n":939
    },
    "system_fingerprint":"b7785-1c7cf94b2",
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-tlInzZejjpaBM5J3LhaKXUUTwnBOloEq"
  }
}