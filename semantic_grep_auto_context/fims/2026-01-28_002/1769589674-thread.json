{
  "last_sse":{
    "choices":[{
        "delta":[],
        "finish_reason":"stop",
        "index":0
      }],
    "id":"chatcmpl-kk4VcId3LeFCN4gCHmx46hmDY5epiZ6R",
    "created":1769589674,
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7785-1c7cf94b2",
    "timings":{
      "predicted_per_second":212.22206144793,
      "predicted_n":374,
      "prompt_per_second":4433.5587271355,
      "prompt_ms":627.938,
      "prompt_per_token_ms":0.22555244252874,
      "predicted_ms":1762.305,
      "predicted_per_token_ms":4.7120454545455,
      "cache_n":1001,
      "prompt_n":2784
    }
  },
  "request_body":{
    "stream":true,
    "raw":false,
    "options":[],
    "model":"gpt-oss:120b",
    "top_p":1,
    "temperature":1,
    "messages":[{
        "content":"You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position: <|fim_middle|>\n\nThe surrounding code is limited, it may not be the full file. Focus on the code near <|fim_middle|>\nDo NOT explain your decisions. Do NOT return markdown blocks ```\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace. Especially on the cursor line!\nYOU ARE ONLY INSERTING CODE. DO NOT REPEAT PREFIX. DO NOT REPEAT SUFFIX.\nComplete as little or as much code as is necessary to help the user. That means part of a line, a full line or even multiple lines! Goal is to help the user as much as is possible and reasonable.\n\nHere are a few examples of tricky completions:\n\n## Example: suggest middle of line (cursor has existing code before and after it)\n\n```python\ndef area(width, height):\n    return <|fim_middle|> * height\n```\n\nSay this is your desired result:\n```python\ndef area(width, height):\n    return width * height\n```\n\n1. thent he CORRECT completion is (do not include backticks, those are just to delimit included whitespace):\n`width`\n\n2. WRONG (because repeats the suffix):\n`width * height`\nresults in:\n`    return width * height * height`\n\n3. WRONG (because repeats both suffix and prefix):\n`    return width * height`\nresults in:\n`    return     return width * height * height`\n\n\n## Example: cursor is indented\n\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    <|fim_middle|>\n    end\nend\n```\n\n*Keep in mind, the indent will be there before the suggested code too.*\n\nSay this is your desired result:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n1. then the CORRECT completion is:\n```lua\nelse\n        print(\"Non‑positive\")\n```\n\n2. WRONG (`else` ends up double indented when it should be single):\n```lua\n    else\n        print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n        else\n        print(\"Non‑positive\")\n    end\nend\n```\n\n3. WRONG (`print` ends up single indented when it should be double):\n```lua\nelse\n    print(\"Non‑positive\")\n```\nresults in:\n```lua\nfunction print_sign(number)\n    if number > 0 then\n        print(\"Positive\")\n    else\n    print(\"Non‑positive\")\n    end\nend\n```\n\n\n",
        "role":"developer"
      },{
        "content":"Here is context that's automatically provided, that MAY be relevant.\nrepo: auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n\n## Recent yanks (copy to clipboard):\n```auto_edit/new_silence/detects/breathing.py\nhops_wide\n```\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:38-40\n    @staticmethod\n    def minute(num):\n        return gptoss_fim_examples / \"minutes\" / f\"minute{num}\" / f\"minute{num}.mp4\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:0-19\nimport os\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom types import SimpleNamespace\n\ndropbox_sync_dir = Path(os.getenv('HOME') or '') / 'dbox/'\ntest_videos_dir = dropbox_sync_dir / 'auto-edit-videos' / 'pytest_samples'\n\ngptoss_fim_examples = test_videos_dir / '01-gpt-oss-fim'\n\nclass gptoss_fim_video:\n    full = gptoss_fim_examples / \"full.mp4\"\n\n    #  TODO fix issues w/ PTS on minute1 and throw if start in ffprobe output != 0 anywhere\n    #      minute1=gptoss_fim_examples / \"minutes\" / \"minute1\" / \"minute1.mp4\",\n    # TODO then add check to shell out to ffprobe and look for start = NON zero value and fail if so\n    #  TODO! worse case just trim first 0.080 off of combined.shifted.mp4 and minute1.mp4 videos\n    #   that s/b fine on most recordings\n    #   ffprobe -select_streams a:0 -show_packets -read_intervals %+1  foo.mp4/mkv\n    #   ffprobe -select_streams a:0 -of csv -show_packets -read_intervals %+1  foo.mp4/mkv\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:10-46\nclass gptoss_fim_video:\n    full = gptoss_fim_examples / \"full.mp4\"\n\n    #  TODO fix issues w/ PTS on minute1 and throw if start in ffprobe output != 0 anywhere\n    #      minute1=gptoss_fim_examples / \"minutes\" / \"minute1\" / \"minute1.mp4\",\n    # TODO then add check to shell out to ffprobe and look for start = NON zero value and fail if so\n    #  TODO! worse case just trim first 0.080 off of combined.shifted.mp4 and minute1.mp4 videos\n    #   that s/b fine on most recordings\n    #   ffprobe -select_streams a:0 -show_packets -read_intervals %+1  foo.mp4/mkv\n    #   ffprobe -select_streams a:0 -of csv -show_packets -read_intervals %+1  foo.mp4/mkv\n    #\n    #  !!! FOR now you can test with minute2+ b/c they're already re-encoded and there are no non-zero starts\n    #  !!! that means for auto-edit purposes what you generate will line up with what FCPX shows\n    first_10mins = gptoss_fim_examples / \"minutes/first_10mins/first_10mins.mp4\"\n\n    minute2 = gptoss_fim_examples / \"minutes\" / \"minute2\" / \"minute2.mp4\"\n    minute3 = gptoss_fim_examples / \"minutes\" / \"minute3\" / \"minute3.mp4\"\n    minute4 = gptoss_fim_examples / \"minutes\" / \"minute4\" / \"minute4.mp4\"\n    minute5 = gptoss_fim_examples / \"minutes\" / \"minute5\" / \"minute5.mp4\"\n    minute6 = gptoss_fim_examples / \"minutes\" / \"minute6\" / \"minute6.mp4\"\n    minute7 = gptoss_fim_examples / \"minutes\" / \"minute7\" / \"minute7.mp4\"\n    minute8 = gptoss_fim_examples / \"minutes\" / \"minute8\" / \"minute8.mp4\"\n    minute9 = gptoss_fim_examples / \"minutes\" / \"minute9\" / \"minute9.mp4\"\n    minute10 = gptoss_fim_examples / \"minutes\" / \"minute10\" / \"minute10.mp4\"\n    minute11 = gptoss_fim_examples / \"minutes\" / \"minute11\" / \"minute11.mp4\"\n    minute12 = gptoss_fim_examples / \"minutes\" / \"minute12\" / \"minute12.mp4\"\n    minute13 = gptoss_fim_examples / \"minutes\" / \"minute13\" / \"minute13.mp4\"\n\n    @staticmethod\n    def minute(num):\n        return gptoss_fim_examples / \"minutes\" / f\"minute{num}\" / f\"minute{num}.mp4\"\n\n    split_breathing = gptoss_fim_examples / \"breathing-split-silence.mp4\"\n    split_breathing_wav = gptoss_fim_examples / \"breathing-split-silence.wav\"\n\n    # FYI for testing non-zero start to a video\n    non_zero_start = gptoss_fim_examples / \"minutes/non_zero_start/non_zero_start_from_minute1_44.mp4\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:75-77\ndef analysis7():\n    from auto_edit.new_silence.tests.analysis_loader import get_full_analysis\n    return get_full_analysis(gptoss_fim_video.minute7)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/tests/test_files.py:91-93\ndef analysis11():\n    from auto_edit.new_silence.tests.analysis_loader import get_full_analysis\n    return get_full_analysis(gptoss_fim_video.minute11)\n",
        "role":"user"
      },{
        "content":"Please suggest text to replace <|fim_middle|>:\n\n```auto_edit/new_silence/detects/breathing.py\n\n                if cross.is_upward():\n                    if plotting:\n                        minima_line = {\"linewidth\": 1, \"alpha\": 0.4, \"zorder\": 0}\n                        plotter.ax.axvline(cross.before.seconds, color=\"teal\", **minima_line).pps = PPS.HOPS_USEFUL\n                        plotter.ax.axvline(cross.middle.seconds, color=\"crimson\", **minima_line)\n                        plotter.ax.axvline(cross.after.seconds, color=\"orangered\", **minima_line).pps = PPS.HOPS_USEFUL\n            # rich.print(table)  # Disabled zero‑crossover table output\n\n            crossovers__0_2 = build_crossovers(diff_stride2.gate(lower=-0.2, upper=0.2).sign(), analysis)\n            if plotting:\n                for cross in crossovers__0_2:\n                    plot_cross_box(cross, offset_gated_experimental__0_2)\n\n            class VirtualGapSegment(DetectedSegment):\n                left_cross: CrossoverData | None\n                right_cross: CrossoverData | None\n\n            crossovers = get_material_crossovers(crossovers)\n            win.gap.crossovers = Crossovers(crossovers)\n\n            # TODO listify\n            locator = LeftSpeechTaper_WithOptionalBreathe_Locator()\n            c = GapContext(win, gap_rms, analysis, plotting)\n            locator.locate(c)\n            a = ApplyNotesAsLabelSegments(plotter)\n            a.apply(c)\n\n            if plotting:\n                # * arrows at taper bounds\n\n                if win.gap.left_taper_end:\n                    seconds = win.gap.left_taper_end.time.seconds\n                    rms = analysis.rms_db[analysis.to_hops(seconds)]\n\n                    x_offset = 2 / analysis.fps  # 2 frames\n                    y_offset = 4\n                    plotter.ax.annotate(\n                        # arrow?\n                        \"\",\n                        xy=(seconds, rms),\n                        xytext=(seconds - x_offset, rms - y_offset),\n                        arrowprops=dict(arrowstyle=\"->\", color=\"lime\", lw=1.5),\n                    )\n                    plotter.ax.axvspan(\n                        # or, background?\n                        xmin=win.gap.start_seconds(),\n                        xmax=seconds,\n                        alpha=0.2,\n                    )\n                if win.gap.right_taper_start:\n                    seconds = win.gap.right_taper_start.time.seconds\n                    rms = analysis.rms_db[analysis.to_hops(seconds)]\n                    plotter.ax.annotate(\n                        \"\",\n                        xy=(seconds, rms),\n                        xytext=(seconds + x_offset, rms - y_offset),\n                        arrowprops=dict(arrowstyle=\"->\", color=\"magenta\", lw=1.5),\n                    )\n                    plotter.ax.axvspan(\n                        xmin=seconds,\n                        xmax=win.gap.end_seconds(),\n                        alpha=0.2,\n                    )\n\n            detectors: list[BreathingDetector] = [\n                # TODO keep just for labels? no real use beyond that now that I have taper analysis??\n                TreatOneMinimaAsSpeech(),\n                InnerSlopeHasSpike(),\n            ]\n\n            context = c\n            for detector in detectors:\n                if detector.not_breathing(context):\n                    # If the detector determines this is not breathing, skip further processing\n                    return NOT_BREATHING\n\n            # * THEN classify virtual gap sub-segments\n            prev_crossover = None\n            for crossover in crossovers:\n                # * look at slope of curve to determine if likely breathing hump\n                #   duration matters, start with > 120ms and < 500ms\n                #   ALSO keep in mind you should keep existing breathing detection logic in place\n                #   this is only for exceptional cases like multi hump (i.e. taper after left_speech)\n                #    if < 2 crossovers => ignore gap\n                prev_crossover = crossover\n\n        if analyze_rms_stride2() == NOT_BREATHING:\n            continue\n\n        win.breathing = True\n        if plotting:\n            gap_rms.plot(color=\"dodgerblue\", linewidth=3)\n\n    if plotting:\n        plotter.toggle_zoom_level_elements()\n\ndef get_material_crossovers(crossovers):\n\n    def is_moot(current, next) -> bool:\n\n        # thresholds:\n        # - only adjust if you add real test cases to integration tests first\n        max_moot_hops = 7\n        max_moot_db = 5\n\n        hops_wide = next.cp.time.hops - current.cp.time.hops\n        if hops_wide > max_moot_hops:\n            # wider than moot can be\n            return False\n\n        rms_db_tall = abs(next.cp.rms - current.cp.rms)\n        is_moot = rms_db_tall < max_moot_db\n        if is_moot:\n            rich.print(\"[#000000 bold on yellow]  Found moot back-to-back crossovers:[/] \"\n                       f\"<|fim_middle|>\"\n                       f\"([bold]{current.cp.time.seconds:.3f}s {current.cp.rms:.2f}dB[/bold] → \"\n                       f\"[bold]{next.cp.time.seconds:.3f}s {next.cp.rms:.2f}dB[/bold])\")\n\n        return is_moot\n\n    # FYI this might be a better solution than using gated diff...\n    #\n    #   TODO after you have good test coverage of all gap scenarios, drop gated and see if this removes noise and keeps tests passing\n    #      WHY? b/c gated sometimes results in missing critical points that are big dB moves!\n    #      also, judging moot might not work well if only one of the pair come through!\n    #        could easily miss detecting 1+ moots this way!\n    #        thus leaving an inconsequential min/max, which would then screw up detecting key scenarios\n    #\n    #   `gate()` was only added for cases where `diff` is close to zero\n    #     and `diff` wiggles back and forth over x-axis (y=0)\n    #     most of the time the wiggle was not violent, thus gated diff nuked it\n    #   stop using gated crossovers\n    #   instead take all crossovers, then remove moot ones!\n\n    # this is inherently about removing items\n    # - hence start w/ a copy of the list\n    # - adding would be a nightmare cuz of 3+ back to back moots\n    filtered = crossovers.copy()\n\n    for current, next in pairwise(crossovers):\n        if not is_moot(current, next):\n            # nothing to do, leave in filtered\n            continue\n\n        if current in filtered:\n            filtered.remove(current)\n        if next in filtered:\n            filtered.remove(next)\n        # FYI must still visit `next` next b/c it may be moot w.r.t. its next too\n        #   i.e. 3 back-to-back moots\n        #   also why don't have to visit the last item! it has no \"next\" to compare\n        #     whereas its previous would remove it already if it prev was moot w.r.t.\n\n    if len(filtered) != len(crossovers):\n        rich.print(f\"[bold yellow]  Resulting crossovers[/]\")\n        for cross in filtered:\n            rich.print(f\"    [bold]{cross.cp.time.seconds:.3f}s {cross.cp.rms:.2f}dB[/bold]\")\n\n    return filtered\n```\n\n## Reminders about the cursor line:\nText before cursor: `                       f\"`\nText after cursor: `\"`",
        "role":"user"
      }],
    "max_tokens":4096,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    }
  },
  "response_message":{
    "reasoning_content":"We need to fill the placeholder inside rich.print line. The cursor is inside f-string: `f\"` then cursor then `\"`.\n\nWe want to print something about current cp maybe. Likely want to include something like f\"{current.cp.time.seconds:.3f}s {current.cp.rms:.2f}dB\". But already later prints both. This part probably prints something like f\"{current.cp.time.seconds:.3f}s {current.cp.rms:.2f}dB → {next...\". Actually earlier they already include that after. So this middle might be something like f\"{current.cp.time.seconds:.3f}s {current.cp.rms:.2f}dB\". Wait the full line:\n\nrich.print(\"[#000000 bold on yellow]  Found moot back-to-back crossovers:[/] \"\n                       f\"<|fim_middle|>\"\n                       f\"([bold]{current.cp.time.seconds:.3f}s {current.cp.rms:.2f}dB[/bold] → \"\n                       f\"[bold]{next.cp.time.seconds:.3f}s {next.cp.rms:.2f}dB[/bold])\")\n\nSo they want something before the parentheses, maybe a description or label. Could be empty string. Probably want a space. Might be something like f\"{current.cp.time.seconds:.3f}s\". But parentheses already contain that. So maybe they want to show the hops difference: f\"{hops_wide} hops\". So fill with something like f\"{hops_wide} hops, \". But variable hops_wide defined earlier in is_moot. So include that. I'd suggest: f\"{hops_wide} hops, \". So code: f\"{hops_wide} hops, \".",
    "role":"assistant",
    "finish_reason":"stop",
    "content":"f\"{hops_wide} hops, \""
  }
}