{
  "request_body":{
    "temperature":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "messages":[{
        "role":"system",
        "content":"## Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- If changing existing code, preserve unrelated code and comments. \n- Never add comments to the end of a line. \n- Never add stupid comments.\n- Be considerate with indentation. \n- Prefer readable code over of comments. \n- Prefer meaningful names for variables, functions, etc. Avoid ambiguous names."
      },{
        "role":"user",
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
      },{
        "role":"user",
        "content":"## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:29-110\n@dataclass\nclass CrossoverData:\n    crossover: Crossover\n\n    before: AVTime\n    middle: AVTime\n    after: AVTime\n\n    min: RmsPoint\n    max: RmsPoint\n\n    after_diff_value: float\n\n    def __init__(self, crossover: Crossover, diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = AVTime(diff_stride2_gated.times[crossover.after_index], analysis)\n        self.before = AVTime(diff_stride2_gated.times[crossover.before_index], analysis)\n        self.after_diff_value = diff_stride2_gated.values[crossover.after_index]\n\n        self.middle = AVTime(\n            (self.before.seconds + self.after.seconds) / 2,\n            analysis,\n        )\n\n        # get rms values (not stride 2 btw, so make sure to map via time/hops, not array offsets)\n        rms_segment = analysis.rms_slice(\n            analysis.to_hops(self.before.seconds),\n            analysis.to_hops(self.after.seconds),\n        )\n\n        # min makes most sense for upward crossover (rampup)\n        min_idx = np.argmin(rms_segment.values)\n        self.min = RmsPoint(\n            AVTime(rms_segment.times[min_idx], analysis),\n            rms_segment.values[min_idx],\n        )\n\n        # max makes most sense for downward crossover (taper)\n        max_idx = np.argmax(rms_segment.values)\n        self.max = RmsPoint(\n            AVTime(rms_segment.times[max_idx], analysis),\n            rms_segment.values[max_idx],\n        )\n\n    @property\n    def cp(self) -> RmsPoint:\n        \"\"\"\n        aliases critical_point\n        - for cases where code gets absurdly long\n        - thus use this for readability (avoids super long lines)\n        \"\"\"\n        return self.critical_point\n\n    @property\n    def critical_point(self) -> RmsPoint:\n        \"\"\"\n        critical RMS value of the crossover.\n        1. for upward crossovers (ramp‑up) the minimum RMS is the critical point\n        2. for downward crossovers (taper) the maximum RMS is the critical point\n        \"\"\"\n        return self.min if self.is_upward() else self.max\n\n    def is_local_min(self) -> bool:\n        return self.is_upward()\n\n    def is_upward(self) -> bool:\n        return self.after_diff_value > 0\n\n    def is_local_max(self) -> bool:\n        return self.is_downward()\n\n    def is_downward(self) -> bool:\n        return self.after_diff_value < 0\n\n    def min_max_label(self) -> str:\n        return \"min\" if self.is_local_min() else \"max\"\n\n    def label(self) -> str:\n        label = self.min_max_label()\n        cp = self.critical_point\n        return f\"{label}{cp.time.seconds:.4f}s {cp.rms:.2f}dB\"\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:0-19\nfrom pathlib import Path\nimport numpy as np\nfrom rich.text import Text\nfrom rich.console import Console\nfrom numpy.typing import NDArray\nfrom io import StringIO\nfrom enum import Enum\nfrom dataclasses import dataclass, field\nfrom auto_edit.new_silence.detects.time_series import TimeSeries\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from auto_edit.new_silence.detects.crossings import CrossoverData\n\nMonoAudioSamplesArray = NDArray[np.float32]\nRMSValues = NDArray[np.float32]\nFloat32Array = NDArray[np.float32]\nSampleRate = int | float\n\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings.py:42-61\n    def __init__(self, crossover: Crossover, diff_stride2_gated: TimeSeries, analysis: \"AudioAnalysisResult\"):\n        self.crossover = crossover\n\n        self.after = AVTime(diff_stride2_gated.times[crossover.after_index], analysis)\n        self.before = AVTime(diff_stride2_gated.times[crossover.before_index], analysis)\n        self.after_diff_value = diff_stride2_gated.values[crossover.after_index]\n\n        self.middle = AVTime(\n            (self.before.seconds + self.after.seconds) / 2,\n            analysis,\n        )\n\n        # get rms values (not stride 2 btw, so make sure to map via time/hops, not array offsets)\n        rms_segment = analysis.rms_slice(\n            analysis.to_hops(self.before.seconds),\n            analysis.to_hops(self.after.seconds),\n        )\n\n        # min makes most sense for upward crossover (rampup)\n        min_idx = np.argmin(rms_segment.values)\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/segments.py:60-82\nclass Crossovers(list[\"CrossoverData\"]):\n    \"\"\"Thin ``list`` subclass for :class:`CrossoverData` objects.\n\n    Keeps the full list interface while providing convenience helpers.\n    \"\"\"\n\n    def __init__(self, iterable: list[\"CrossoverData\"] | None = None):\n        super().__init__(iterable or [])\n\n    def critical_points(self) -> list[\"RmsPoint\"]:\n        \"\"\"Return the ``critical_point`` of each stored crossover.\"\"\"\n        return [c.critical_point for c in self]\n\n    def as_label_string(self) -> str:\n        \"\"\"Return a formatted string of labels and critical points:\n              min0:0.12s -3.4dB | max1:0.45s 2.1dB\n        \"\"\"\n        rows = []\n        for idx, c in enumerate(self):\n            cp = c.critical_point\n            label = c.min_max_label()\n            rows.append(f\"{label}{idx}:{cp.time.seconds:.4f}s {cp.rms:.4f}dB\")\n        return \" | \".join(rows)\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:270-277\ndef not_breathing(self, context: GapContext) -> bool:\n        if not len(context.win.gap.crossovers) == 1:\n            return False\n\n        rich.print(f'reject, one dip == speech')\n        if context.plotting:\n            context.gap_rms.mark_rejected(\"one dip == speech\")\n        return True\n"
      },{
        "role":"user",
        "content":"only show me time point's time in seconds and rms values roudned to 1 decimal, keep it compact\n\nHere is the code I selected:\n```auto_edit/new_silence/detects/breathing.py\n        rich.print(\n            \"[#000000 bold on yellow]Found moot back-to-back crossovers:[/] \"\n           f\"[bold]{current.cp}[/bold] → [bold]{next.cp}[/bold]\"\n        )\n\n```\n\nThis is not necessarily a complete selection of nearby code, this is just the part I want help with. Preserve indentation!"
      }],
    "stream":true,
    "max_tokens":4096,
    "top_p":1,
    "model":""
  },
  "last_sse":{
    "id":"chatcmpl-CpHT9ZkU91Mf1O3oc00326te3IWoJxjJ",
    "timings":{
      "predicted_per_second":246.2608462045,
      "predicted_n":132,
      "prompt_per_second":6882.693868503,
      "prompt_per_token_ms":0.14529194805195,
      "predicted_ms":536.017,
      "predicted_per_token_ms":4.0607348484848,
      "prompt_n":1925,
      "cache_n":0,
      "prompt_ms":279.687
    },
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }],
    "created":1769212160,
    "system_fingerprint":"b7785-1c7cf94b2",
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF"
  },
  "response_message":{
    "role":"assistant",
    "finish_reason":"stop",
    "content":"```python\nrich.print(\n    \"[#000000 bold on yellow]Found moot back-to-back crossovers:[/] \"\n    f\"[bold]{current.cp.time.seconds:.1f}s {current.cp.rms:.1f}dB[/bold] → \"\n    f\"[bold]{next.cp.time.seconds:.1f}s {next.cp.rms:.1f}dB[/bold]\"\n)\n```",
    "reasoning_content":"Need to modify print to show only time seconds and rms rounded 1 decimal. current.cp is RmsPoint with .time.seconds and .rms. So format accordingly. Provide code snippet."
  }
}