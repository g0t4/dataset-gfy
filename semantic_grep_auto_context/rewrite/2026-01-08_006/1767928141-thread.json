{
  "last_sse":{
    "created":1767928141,
    "timings":{
      "prompt_per_token_ms":0.20745953971789,
      "predicted_ms":396.724,
      "prompt_n":2694,
      "predicted_per_second":226.85796674766,
      "cache_n":349,
      "predicted_n":90,
      "prompt_per_second":4820.216999227,
      "predicted_per_token_ms":4.4080444444444,
      "prompt_ms":558.896
    },
    "choices":[{
        "index":0,
        "delta":[],
        "finish_reason":"stop"
      }],
    "object":"chat.completion.chunk",
    "system_fingerprint":"b7616-18ddaea2a",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-NQzziMk3vBweW2y31Gt9fuYIoD8eC6fa"
  },
  "response_message":{
    "reasoning_content":"We need to flip condition to early return? Already returns early on too_short. Probably invert logic: if not too_short return False else mark and return True. Provide rewritten snippet.",
    "role":"assistant",
    "content":"        if duration_seconds > 0.120:\n            return False\n        # if plotting: # TODO add back plotting check\n        context.gap_rms.mark_rejected(\"reject, too short\")\n        return True",
    "finish_reason":"stop"
  },
  "request_body":{
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "stream":true,
    "max_tokens":4096,
    "messages":[{
        "content":"You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. ",
        "role":"system"
      },{
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n",
        "role":"user"
      },{
        "content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detect.py:0-19\nfrom io import StringIO\nfrom rich.console import Console\nfrom rich.text import Text\nfrom traitlets.config.configurable import SingletonConfigurable\nfrom auto_edit.new_silence.gaps import build_gap_decisions\nfrom auto_edit.new_silence.prober import raise_if_video_has_nonzero_start\nfrom auto_edit.new_silence.timer import DurationPrinter\nfrom auto_edit.tests.test_files import gptoss_fim_video\n\nfrom auto_edit.new_silence.detects.segments import (\n    MAX_POSSIBLE_VALUE_NORMALIZED_AUDIO,\n    LoadedAudio,\n    SegmentLabel,\n    MonoAudioSamplesArray,\n    SampleRate,\n    RMSValues,\n    Float32Array,\n    DetectThresholds,\n    AudioAnalysisResult,\n    DetectedSegment,\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:232-251\n            gap_rms.plot(color=\"dodgerblue\", linewidth=3)\n\n    if plotting:\n        plotter.toggle_zoom_level_elements()\n\n# NOTES\n# weighted scoring + threshold:\n#   duration score\n#     300-400ms (ideal) => highest score for duration\n#     250-300ms medium score\n#     <200ms => REJECT or score very low\n#     <100ms => 100% reject, never happens (usually typing)\n#\n#  EASIEST WAY:\n#  * 1) 300-400ms w/ first/last_min only and nothing below them => speech\n#    this alone will likely do it\n#   2) Validate the hump between them\n#       For each (min₁, min₂) pair:\n#         Let hump_max = max(envelope[min₁ : min₂])\n#       Require:\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/silences/align.py:0-5\nimport math\nimport rich\n\nfrom auto_edit.silences.detect_raw import RawSilencePeriod\nfrom auto_edit.ranges import SilenceRange\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/tests/aligned-tests.py:93-95\ndef test_zero_length_duration_frames(self):\n        aligned = AlignedSilencePeriod(100, 100)\n        assert aligned.duration_frames() == 0\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/tests/integration_tests.py:46-197\nclass TestsMinute7:\n\n    @classmethod\n    def setup_class(cls):\n        # FYI use notebook/generate_fcpxml for plotting\n        cls.analysis = full_analysis(gptoss_fim_video.minute7)\n        mark_breathing(cls.analysis)\n\n    def test_split_first_gap_into_taper_and_breath(self):\n        # assert len(self.analysis.merged_segments) == 5\n        # rich.print(self.analysis.merged_segments)\n        assert len(self.analysis.windows) == 20\n        #\n\n        # TODO taper + breathe => double bounce rule\n        #  first bounce ~75ms\n        #  second is 320ms (breathing)\n        win2s = self.analysis.windows[0]\n        # assert win2s.breathing # TODO sub asserts on taper + breathing\n        assert win2s.first_min.seconds == pytest.approx(2.26, 0.1)\n        # TODO!!! middle minima assertion! ~ 2.33s\n        assert win2s.last_min.seconds == pytest.approx(2.65, 0.1)\n        assert len(win2s.gap.crossings) == 5\n        # assert len(win2s.gap.subsegs) == 5\n        #\n        # * breathing\n        win6s = self.analysis.windows[1]\n        assert win6s.breathing\n        assert win6s.first_min.seconds == pytest.approx(6.91, 0.1)\n        assert win6s.last_min.seconds == pytest.approx(7.16, 0.1)\n        #\n        # * breathing\n        win11s = self.analysis.windows[2]\n        assert win11s.breathing\n        assert win11s.first_min.seconds == pytest.approx(11.03, 0.1)\n        assert win11s.last_min.seconds == pytest.approx(11.33, 0.1)\n        #\n        # * one dip only:\n        win11_2s = self.analysis.windows[3]\n        assert len(win11_2s.gap.crossings) == 1\n        # assert len(win11_2s.gap.subsegs) == 2\n        assert not win11_2s.breathing # TODO classify as speech (glue together windows or just mark this as speech)\n        assert win11_2s.first_min.seconds == pytest.approx(11.96, 0.1)\n        assert win11_2s.first_min.seconds == win11_2s.last_min.seconds\n        #\n        # * breathing\n        win13s = self.analysis.windows[4]\n        assert win13s.breathing\n        assert win13s.first_min.seconds == pytest.approx(13.61, 0.1)\n        assert win13s.last_min.seconds == pytest.approx(13.93, 0.1)\n        #\n        # * breathing\n        win15s = self.analysis.windows[5]\n        assert win15s.breathing\n        assert win15s.first_min.seconds == pytest.approx(15.18, 0.1)\n        assert win15s.last_min.seconds == pytest.approx(15.40, 0.1)\n        #\n        win18s = self.analysis.windows[6]\n        assert win18s.breathing\n        assert win18s.first_min.seconds == pytest.approx(18.49, 0.1)\n        assert win18s.last_min.seconds == pytest.approx(18.63, 0.1)\n        # TODO! switch to new minima reporting?\n        # TODO categorized subsets of gap identified\n        #\n        win21s = self.analysis.windows[7]\n        assert win21s.breathing\n        assert win21s.first_min.seconds == pytest.approx(21.09, 0.1)\n        assert win21s.last_min.seconds == pytest.approx(21.33, 0.1)\n        #\n        win23s = self.analysis.windows[8]\n        assert win23s.breathing\n        assert win23s.first_min.seconds == pytest.approx(23.70, 0.1)\n        assert win23s.last_min.seconds == pytest.approx(23.86, 0.1)\n        #\n        win27s = self.analysis.windows[9]\n        assert win27s.breathing\n        assert win27s.first_min.seconds == pytest.approx(27.05, 0.1)\n        assert win27s.last_min.seconds == pytest.approx(27.32, 0.1)\n        #\n        win29s = self.analysis.windows[10]\n        assert win29s.breathing\n        assert win29s.first_min.seconds == pytest.approx(29.22, 0.1)\n        assert win29s.last_min.seconds == pytest.approx(29.51, 0.1)\n        # FYI this one has blue vertical lines at top of hump, if use those lines, then use this test to eliminate when slope == 0\n        #\n        win32s = self.analysis.windows[11]\n        assert win32s.breathing\n        assert win32s.first_min.seconds == pytest.approx(32.58, 0.1)\n        assert win32s.last_min.seconds == pytest.approx(32.83, 0.1)\n        #\n        win34s = self.analysis.windows[12]\n        assert win34s.breathing\n        assert win34s.first_min.seconds == pytest.approx(34.43, 0.1)\n        assert win34s.last_min.seconds == pytest.approx(34.65, 0.1)\n        #\n        win37s = self.analysis.windows[13]\n        assert win37s.breathing\n        assert win37s.first_min.seconds == pytest.approx(37.98, 0.1)\n        assert win37s.last_min.seconds == pytest.approx(38.35, 0.1)  # ?? TODO might not match exactly, low area for a while\n        #\n        # * breathing\n        win41s = self.analysis.windows[14]\n        assert win41s.breathing\n        assert win41s.first_min.seconds == pytest.approx(41.91, 0.1)\n        assert win41s.last_min.seconds == pytest.approx(42.24, 0.1)\n        #\n        # * not breathing => word is \"at\"\n        # # TODO TALKING => word is \"at\" ... \"where the cursor is [gap]at[/gap] and so then it can make suggestions ...\"\n        win43s = self.analysis.windows[15]\n        # assert not win43s.breathing # TODO GET WORKING BY REJECTING 3 MINIMA with this little duration within a given subset (between minima)\n        assert win43s.first_min.seconds == pytest.approx(43.69, 0.1)\n        assert win43s.last_min.seconds == pytest.approx(43.83, 0.1)\n        #\n        # * typing, etc\n        # TODO this is a CLUSTER F! reject this one! (already rejected but I should add logic for this to flag it as no way)\n        win46s = self.analysis.windows[16]\n        assert not win46s.breathing\n        # TODO the first/last minima are not really important here though...\n        assert win46s.first_min.seconds == pytest.approx(46.32, 0.1)\n        assert win46s.last_min.seconds == pytest.approx(48.56, 0.1)\n        #\n        # * breathing again\n        win52s = self.analysis.windows[17]\n        assert win52s.breathing\n        assert win52s.first_min.seconds == pytest.approx(52.99, 0.1)\n        assert win52s.last_min.seconds == pytest.approx(53.33, 0.1)\n        #\n        # * breathing again\n        win55s = self.analysis.windows[18]\n        assert win55s.breathing\n        assert win55s.first_min.seconds == pytest.approx(55.20, 0.1)\n        assert win55s.last_min.seconds == pytest.approx(55.44, 0.1)\n        #\n        # * taper speech then breathing\n        win57s = self.analysis.windows[19]\n        assert win57s.breathing\n        assert win57s.first_min.seconds == pytest.approx(57.18, 0.1)\n        # TODO assert taper is part of speech at start...\n        #    * PROPOSED RULE => double bounce == ASSUME taper + breathing\n        #    SO, if I find double bounce w/in maybe some limits on duration too, then treat as taper+breathing until otherwise detected\n        #    57.28-57.18 == ~100ms (is this w/in my threshold for taper?\n        #\n        # TODO middle minima + last_min == breathing?\n        #   * APPROX 57.28s (~8.4 frames into 57seconds)\n        #   if my criteria works... keep in mind there will be times when your criteria doesn't work, NBD if rare!\n        #   rare enough as in not a PITA to edit! EASY EDITS is all that matters\n        assert win57s.last_min.seconds == pytest.approx(57.50, 0.1)\n        #\n        # FYI END has part of gap at end with breathing (NOT FULL)\n        # 59s27.01frames (first_min)\n        # last min is past end of video and w/o the bounce back up won't be picked up...\n        #  can add heurisitc at end of videos if I want to cut breathing / noise at end... for now NO need to assert\n",
        "role":"user"
      },{
        "content":"flip conditions (return early)\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/detects/detectors/ideas.py:\n        too_short = duration_seconds <= 0.120\n        if too_short:\n            # if plotting: # TODO add back plotting check\n            context.gap_rms.mark_rejected(\"reject, too short\")\n            return True\n        return False",
        "role":"user"
      }],
    "top_p":1,
    "model":"",
    "temperature":1
  }
}