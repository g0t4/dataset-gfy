{
  "request_body":{
    "max_tokens":4096,
    "top_p":1,
    "chat_template_kwargs":{
      "reasoning_effort":"low"
    },
    "temperature":1,
    "model":"",
    "stream":true,
    "messages":[{
        "role":"system",
        "content":"You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "
      },{
        "role":"user",
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
      },{
        "role":"user",
        "content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:246-249\ndef window_at_seconds(self, seconds: float) -> GapWindow | None:\n        for window in self.windows:\n            if window.start_seconds() <= seconds <= window.end_seconds():\n                return window\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:100-134\n@dataclass\nclass NonSpeechGap:\n    segments: list[DetectedSegment]\n    crossovers: list[CrossoverData] = field(default_factory=list)\n\n    def __len__(self) -> int:\n        return len(self.segments)\n\n    def __iter__(self):\n        return iter(self.segments)\n\n    # TODO unify interface for segments\n    #   (add @property to start/end_seconds and change usages...\n    #   duration_seconds could be a property too, OR maybe a method to indicate read only\n    #     if go method route, update other property based duration_seconds to be methods\n    #      the same properties/method should exist on all my segement types... i.e. NonSpeechGap, DetectedSegment (left/right_speech), CombinedSegments, etc... maybe even GapWindow\n    #      that way I always know where to go to get the value regardless what segment it is\n    def start_seconds(self) -> float:\n        return self.segments[0].start_seconds\n\n    def end_seconds(self) -> float:\n        return self.segments[-1].end_seconds\n\n    def middle_seconds(self) -> float:\n        return (self.start_seconds() + self.end_seconds()) / 2\n\n    def duration_seconds(self) -> float:\n        return self.end_seconds() - self.start_seconds()\n\n    def contains(self, seconds) -> bool:\n        return self.start_seconds() <= seconds < self.end_seconds()\n\n    def __repr__(self) -> str:\n        segs = \", \".join(str(s.id) for s in self.segments)\n        return f\"NonSpeechGap(segments=[{segs}])\"\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:146-178\n@dataclass\nclass GapWindow:\n    left_speech: DetectedSegment | None\n    gap: NonSpeechGap\n    right_speech: DetectedSegment | None\n\n    # ?? remove these and/or repurpose them for left_speech taper_end, right_speech rampup_begin?\n    first_min: MinMeasures | None = None\n    last_min: MinMeasures | None = None\n\n    # might want breathing_ranges at some point... use bool for now\n    #  this will decide when muting (or not) in FCPXML generation\n    #  FYI this might not belong here too...\n    breathing: bool | None = None\n\n    def all_segments(self) -> list[DetectedSegment]:\n        segments: list[DetectedSegment] = []\n        if self.left_speech:\n            segments.append(self.left_speech)\n        segments.extend(self.gap.segments)\n        if self.right_speech:\n            segments.append(self.right_speech)\n        return segments\n\n    def start_seconds(self) -> float:\n        if self.left_speech:\n            return self.left_speech.start_seconds\n        return self.gap.segments[0].start_seconds\n\n    def end_seconds(self) -> float:\n        if self.right_speech:\n            return self.right_speech.end_seconds\n        return self.gap.segments[-1].end_seconds\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:181-183\nclass VirtualGapSegment(DetectedSegment):\n                left_cross: CrossoverData | None\n                right_cross: CrossoverData | None\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:98-105\n\n\n@dataclass\nclass NonSpeechGap:\n    segments: list[DetectedSegment]\n    crossovers: list[CrossoverData] = field(default_factory=list)\n\n    \n"
      },{
        "role":"user",
        "content":"redo this to first get list of critical points (with gap.start_seconds/end_seconds at start/end of list of points)... then find both critical points with that list\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/segment_plotter.py:\n            prior_cx = None\n            next_cx = None\n            for cx in gap.crossovers:\n                # assumes sorted crossovers\n                if cx.critical_point.seconds <= clicked_at_seconds:\n                    prior_cx = cx\n                elif cx.critical_point.seconds > clicked_at_seconds and next_cx is None:\n                    next_cx = cx\n                    break\n            # fallback to gap boundaries when missing\n            start_sec = prior_cx.critical_point.seconds if prior_cx else gap.start_seconds()\n            end_sec = next_cx.critical_point.seconds if next_cx else gap.end_seconds()"
      }]
  },
  "last_sse":{
    "created":1767980268,
    "timings":{
      "cache_n":354,
      "prompt_n":1060,
      "predicted_per_second":231.00945427581,
      "predicted_n":162,
      "prompt_per_token_ms":0.30522264150943,
      "predicted_ms":701.27,
      "predicted_per_token_ms":4.3288271604938,
      "prompt_per_second":3276.2969190446,
      "prompt_ms":323.536
    },
    "choices":[{
        "finish_reason":"stop",
        "index":0,
        "delta":[]
      }],
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "system_fingerprint":"b7616-18ddaea2a",
    "id":"chatcmpl-3LxwDvFHnGeXPhWloPbBhyd29pDkD8YR"
  },
  "response_message":{
    "finish_reason":"stop",
    "reasoning_content":"Need to rewrite to first get list of critical points then find prior and next. Provide code without markdown.",
    "role":"assistant",
    "content":"            critical_secs = [cp.seconds for cp in (c.critical_point for c in gap.crossovers)]\n            critical_secs.insert(0, gap.start_seconds())\n            critical_secs.append(gap.end_seconds())\n            prior_sec = None\n            next_sec = None\n            for sec in critical_secs:\n                if sec <= clicked_at_seconds:\n                    prior_sec = sec\n                elif sec > clicked_at_seconds and next_sec is None:\n                    next_sec = sec\n                    break\n            start_sec = prior_sec if prior_sec is not None else gap.start_seconds()\n            end_sec = next_sec if next_sec is not None else gap.end_seconds()\n"
  }
}