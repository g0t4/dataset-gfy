{"top_p":1,"model":"","temperature":1,"chat_template_kwargs":{"reasoning_effort":"low"},"stream":true,"messages":[{"role":"system","content":"You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "},{"role":"user","content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"},{"role":"user","content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"},{"role":"user","content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:329-331\ndef get_y_limits(self) -> YLimits:\n        bottom, top = self.ax.get_ylim()\n        return YLimits(bottom=bottom, top=top)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:333-338\ndef set_y_limits(self, bottom, top):\n        if bottom >= top:\n            rich.print(f\"Invalid y limits: bottom ({bottom}) >= top ({top})\")\n            return\n        self.ax.set_ylim(bottom, top)\n        self.toggle_zoom_level_elements()\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:40-55\n@dataclass(frozen=True)\nclass YLimits:\n    bottom: float\n    top: float\n\n    @property\n    def height(self) -> float:\n        return self.top - self.bottom\n\n    @property\n    def middle(self) -> float:\n        return (self.bottom + self.top) / 2\n\n    @property\n    def half(self) -> float:\n        return self.height / 2\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:23-38\n@dataclass(frozen=True)\nclass XLimits:\n    start: float\n    end: float\n\n    @property\n    def width(self) -> float:\n        return self.end - self.start\n\n    @property\n    def middle(self) -> float:\n        return (self.start + self.end) / 2\n\n    @property\n    def half(self) -> float:\n        return self.width / 2\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:57-461\nclass SegmentPlotter:\n\n    aligned_markers: list[AlignedMarker]\n    arrows: list[Annotation]\n    fig: Figure\n    ax: Axes\n    analysis: AudioAnalysisResult\n    segments: list[DetectedSegment]\n    windows: list[GapWindow]\n\n    @staticmethod\n    def for_window(analysis: AudioAnalysisResult, window: GapWindow):\n        segments = window.all_segments()\n        return SegmentPlotter(analysis, segments, windows_subset=[window])\n\n    @staticmethod\n    def for_entire(analysis: AudioAnalysisResult):\n        return SegmentPlotter(analysis, analysis.merged_segments, windows_subset=analysis.windows)\n\n    def __init__(\n        self,\n        analysis: AudioAnalysisResult,\n        segments_subset: list[DetectedSegment] | None = None,\n        windows_subset: list[GapWindow] | None = None,\n    ):\n        self.analysis = analysis\n        # simple idea => pass a subset of either OR just use all available on the analysis\n\n        self.aligned_markers = []\n        self.arrows = []\n\n        self.segments = segments_subset or []\n        self.windows = windows_subset or []\n\n        self.fig, self.ax = plt.subplots(figsize=(20, 10))\n\n        self._setup_plot()\n        setup_events(self)\n\n    def _play_segment(self, start: float, end: float) -> None:\n        sr = self.analysis.sample_rate\n        audio = self.analysis.audio.samples\n        start_idx = int(start * sr)\n        end_idx = int(end * sr)\n        segment = audio[start_idx:end_idx]\n        sd.play(segment, sr)\n\n    def setup_ticks(self) -> None:\n\n        # keep in mind we don't necessarily plot all segments in the analysis\n        start_seconds = min(seg.start_seconds for seg in self.segments)\n        end_seconds = max(seg.end_seconds for seg in self.segments)\n        max_width = 30.0\n        current_width = end_seconds - start_seconds\n        if current_width > max_width:\n            end_seconds = start_seconds + max_width\n        self.ax.set_xlim(start_seconds, end_seconds)\n\n        # major ticks: every second\n        major_interval = 1.0\n        major_start = np.ceil(start_seconds / major_interval) * major_interval\n        major_ticks = np.arange(major_start, end_seconds + major_interval, major_interval)\n        self.ax.set_xticks(major_ticks)\n\n        # labels show frame number for each major tick\n        major_labels = [f\"{int(t)}\" for t in major_ticks]\n        self.ax.set_xticklabels(major_labels)\n\n        # minor ticks: every frame\n        fps = self.analysis.fps\n        frame_interval = 1.0 / fps\n        minor_start = np.ceil(start_seconds / frame_interval) * frame_interval\n        minor_ticks = np.arange(minor_start, end_seconds + frame_interval, frame_interval)\n        self.ax.set_xticks(minor_ticks, minor=True)\n        frame_numbers = [round(t * fps % fps) for t in minor_ticks]\n\n        self.minor_labels_every5 = [str(f) if f % 5 == 0 else \"\" for f in frame_numbers]\n        self.minor_labels_all = [str(f) for f in frame_numbers]\n        self.ax.set_xticklabels(self.minor_labels_every5, minor=True)\n\n        self.ax.tick_params(axis=\"x\", which=\"minor\", length=4, colors=\"gray\")\n        self.ax.tick_params(axis=\"x\", which=\"major\", length=8, colors=\"black\")\n\n    def _setup_plot(self) -> None:\n\n        self.setup_ticks()\n\n        for seg in self.segments:\n            times = np.linspace(seg.start_seconds, seg.end_seconds, len(seg.rms_values))\n            if len(seg.rms_values) == 1:\n                self.ax.scatter(\n                    times,\n                    seg.rms_values,\n                    color=seg.plot_color(),\n                    label=seg.get_plot_message(self.analysis.fps),\n                    s=10,\n                )\n            else:\n                self.ax.plot(\n                    times,\n                    seg.rms_values,\n                    color=seg.plot_color(),\n                    label=seg.get_plot_message(self.analysis.fps),\n                    linewidth=0.5,\n                )\n\n        if self.windows:\n            for win in self.windows:\n                start_seconds = win.start_seconds()\n                end_seconds = win.end_seconds()\n                if start_seconds is None or end_seconds is None:\n                    continue\n                self.ax.axvspan(\n                    start_seconds,\n                    end_seconds,\n                    color=\"orange\",\n                    alpha=0.3,\n                    label=\"Window Gap\" if \"Window Gap\" not in self.ax.get_legend_handles_labels()[1] else None,\n                )\n\n                # * show detected minima inside the window as vertical lines\n                if win.first_min:\n                    self.add_annotation_arrow(win.first_min.seconds, win.first_min.rms)\n                    self.mark_aligned_frame(win.first_min.frame_aligned_at_seconds, win.first_min.rms)\n                    # rms is for _min.seconds, not min.frame_aligned_at_seconds, but, use it for both\n                if win.last_min:\n                    self.add_annotation_arrow(win.last_min.seconds, win.last_min.rms)\n                    self.mark_aligned_frame(win.last_min.frame_aligned_at_seconds, win.last_min.rms)\n\n        self.ax.set_xlabel(\"Time (s)\")\n        self.ax.set_ylabel(\"RMS dB\")\n        self.ax.set_title(f\"RMS Segments {self.analysis.title_addon()}\")\n\n        # initial limits\n        self.ax.set_ylim(bottom=-100, top=40)\n\n    _cursor: ToggleableCursor | None = None\n\n    def toggle_crosshair(self) -> None:\n        if self._cursor is not None:\n            self._cursor.toggle()\n        else:\n            # first toggle on == create\n            self._cursor = ToggleableCursor(self.ax, color=\"black\", linewidth=0.5, linestyle='--')\n\n    def _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n            # save mp4 clip\n            clip_path = clip_full_window(\n                explain,\n                self.analysis,\n                window,\n            )\n            if clip_path:\n                print(f\"Saved clip to {clip_path}\")\n\n        else:\n            # * play a single segment (under cursor)\n            for seg in self.segments:\n                if seg.start_seconds <= clicked_at_seconds <= seg.end_seconds:\n                    self._play_segment(seg.start_seconds, seg.end_seconds)\n\n    def show(self) -> None:\n        self.fig.tight_layout(pad=0.5)  # thin margins around the axes (plot)... less wasted whitespace margins!\n        plt.ion()  # else won't show new plots after initial call to plt.show()\n        plt.show()\n\n    def add_segments(self, new_segments: list[DetectedSegment]) -> None:\n        self.segments.extend(new_segments)\n        for seg in new_segments:\n            times = np.linspace(seg.start_seconds, seg.end_seconds, len(seg.rms_values))\n            self.ax.plot(\n                times,\n                seg.rms_values,\n                color=seg.plot_color(),\n                linewidth=0.5,\n            )\n        # self.fig.canvas.draw()\n        # self.fig.canvas.flush_events()\n\n    def mark_aligned_frame(self, time_point: float, arrow_y: float) -> None:\n\n        # * vertical line (hopefully cross through the RMS plot... but not guarnateed right now)\n        line_height = 6\n        color = \"deeppink\"\n        lines = self.ax.plot(\n            [time_point, time_point],\n            [arrow_y, arrow_y + line_height],\n            color=color,\n            linewidth=1,\n        )\n\n        frames = time_point * self.analysis.fps\n        frames_text = f\"{int(frames)}f\"\n\n        # * time label\n        label = f\"{time_point:.2f}s\\n{frames_text}\"\n        text = self.ax.text(\n            time_point,\n            arrow_y + line_height + 2,\n            label,\n            ha=\"center\",\n            va=\"bottom\",\n            color=color,\n        )\n\n        self.aligned_markers.append(AlignedMarker(lines, text=text))\n\n        self.fig.canvas.draw_idle()\n\n    def add_annotation_arrow(self, time_point: float, arrow_y: float) -> None:\n\n        self.ax = plt.gca()\n\n        annotation = self.ax.annotate(\n            \"\",\n            xy=(time_point, arrow_y),\n            xytext=(time_point, arrow_y - 6),\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n            arrowprops=dict(\n                arrowstyle=\"->\",\n                color=\"red\",\n                linewidth=1.5,\n            ),\n        )\n        self.arrows.append(annotation)\n\n        self.fig.canvas.draw_idle()\n\n    def get_x_limits(self) -> XLimits:\n        start, end = self.ax.get_xlim()\n        return XLimits(start=start, end=end)\n\n    def set_x_limits(self, start_seconds: float, end_seconds: float) -> None:\n        if start_seconds >= end_seconds:\n            rich.print(f\"Invalid x limits: start_seconds ({start_seconds}) >= end_seconds ({end_seconds})\")\n            return\n        self.ax.set_xlim(start_seconds, end_seconds)\n        self.toggle_zoom_level_elements()\n\n    def get_y_limits(self) -> YLimits:\n        bottom, top = self.ax.get_ylim()\n        return YLimits(bottom=bottom, top=top)\n\n    def set_y_limits(self, bottom, top):\n        if bottom >= top:\n            rich.print(f\"Invalid y limits: bottom ({bottom}) >= top ({top})\")\n            return\n        self.ax.set_ylim(bottom, top)\n        self.toggle_zoom_level_elements()\n\n    def zoom_to_gap(self, window: GapWindow | None) -> None:\n        if window is None:\n            return\n        # fixed zoom level with gap centered (not full window, just the gap of silence)...\n        middle = (window.gap.start_seconds() + window.gap.end_seconds()) / 2\n        width_seconds = 2  # fixed width in seconds\n        self.set_x_limits(middle - width_seconds / 2, middle + width_seconds / 2)\n\n    def zoom_to_gap_at_seconds(self, seconds: float) -> None:\n        window = self.analysis.window_at_seconds(seconds)\n        self.zoom_to_gap(window)\n\n    def zoom_to_window(self, window: GapWindow) -> None:\n        self.set_x_limits(window.start_seconds(), window.end_seconds())\n\n    def zoom_and_center_to(self, new_width_seconds: float) -> None:\n        \"\"\"Zoom the plot to a fixed width centered on the current view.\"\"\"\n        cur = self.get_x_limits()\n        half = new_width_seconds / 2\n        self.set_x_limits(cur.middle - half, cur.middle + half)\n\n    def shift_center_to(self, middle_seconds: float):\n        cur = self.get_x_limits()\n        self.set_x_limits(middle_seconds - cur.half, middle_seconds + cur.half)\n\n    def shift_center_to_gap(self, win: GapWindow | None):\n        if not win:\n            return\n        middle = win.gap.middle_seconds()\n        self.shift_center_to(middle)\n\n    def toggle_zoom_level_elements(self):\n        # PRN call this when window is resized (i.e. full screen => split screen)\n\n        # compute density of time\n        cur = self.get_x_limits()\n        visible_seconds = cur.width\n        pixels_per_second = self.ax.bbox.width / visible_seconds\n\n        # hide text labels when zoomed out\n        for txt in self.ax.texts:\n            txt.set_visible(pixels_per_second > 325)\n\n        for marker in self.aligned_markers:\n            for line in marker.lines:\n                line.set_visible(pixels_per_second > 150)\n            marker.text.set_visible(pixels_per_second > 250)\n\n        for annotation in self.arrows:\n            if pixels_per_second > 250:\n                label = f\"{annotation.xy[0]:.2f}s\"\n                annotation.set_text(label)\n            else:\n                annotation.set_text(\"\")\n\n        show_hop_items = visible_seconds < 0.2\n\n        # rich.inspect(ax.xaxis.get_tick_params())\n        self.ax.xaxis.set_tick_params(\n            which='minor',\n            labelbottom=pixels_per_second > 500,  # not really useful b/4 this point (in my testing)\n            bottom=pixels_per_second > 150 and not show_hop_items,\n        )\n        # print(f'{pixels_per_second=}')  # FYI USE THIS WHEN PICKING A LEVEL (pixels_per_second)\n        if pixels_per_second > 1000:\n            self.ax.set_xticklabels(self.minor_labels_all, minor=True)\n        else:\n            self.ax.set_xticklabels(self.minor_labels_every5, minor=True)\n\n        # * hop indicator lines (axvline) - based on zoom level only\n        clear_hop_items()\n        if show_hop_items:\n            # find first hop line that is visble\n            visible_start_seconds = cur.start\n            visible_end_seconds = cur.end\n            hop_interval = 1 / self.analysis.hops_per_second()\n\n            def show_all_visible_hops():\n                # * show all visible hops (not just gaps)\n                first_hop = math.ceil(visible_start_seconds * self.analysis.hops_per_second())\n                hop = first_hop\n                while True:\n                    hop_sec = hop * hop_interval\n                    if hop_sec > cur.end:\n                        break\n                    line = self.ax.axvline(hop_sec, color=\"olive\", linewidth=0.5)  #, alpha=0.5)\n                    hop_items.append(line)\n                    hop += 1\n                    # PRN add tick numbers too? integer? and how about offset based on start, not overall?\n\n            # show_all_visible_hops()\n\n            def gap_is_visible(win: GapWindow):\n                if win.gap.end_seconds() < visible_start_seconds:\n                    return False\n                if visible_end_seconds < win.gap.start_seconds():\n                    return False\n                return True\n\n            def show_hops_from_window(win: GapWindow):\n                if not gap_is_visible(win):\n                    return\n\n                # limit hops to the visible xâ€‘axis range\n                effective_start = max(win.gap.start_seconds(), visible_start_seconds)\n                effective_end = min(win.gap.end_seconds(), visible_end_seconds)\n                hops_per_second = self.analysis.hops_per_second()\n                first_hop = math.ceil(effective_start * hops_per_second)\n                last_hop = math.floor(effective_end * hops_per_second)\n\n                for hop in range(first_hop, last_hop + 1):\n                    hop_sec = hop * hop_interval\n                    line = self.ax.axvline(hop_sec, color=\"olive\", linewidth=0.5)\n                    hop_items.append(line)\n\n            def show_hops_in_visible_gaps():\n                for win in self.windows:\n                    show_hops_from_window(win)\n\n            show_hops_in_visible_gaps()\n\n        self.fig.canvas.draw_idle()\n"},{"role":"user","content":"use new get_y_limits with its YLimits result type that returns bottom/top etc\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/plot_helpers.py:\n        cur_ylim = plotter.ax.get_ylim()\n        new_height = (cur_ylim[1] - cur_ylim[0]) * zoom_factor\n        half = new_height / 2\n        # zoom in on the middle (middle stays in the middle) ...\n        # PRN zoom in on mouse position?\n        # - cursor => ratio => scale that ratio so the cursor's y-position points at the same thing before/after\n        # - DO NOT move the cursor's position to the middle?\n        middle = (cur_ylim[0] + cur_ylim[1]) / 2\n        plotter.set_y_limits(middle - half, middle + half)\n"}],"max_tokens":4096}