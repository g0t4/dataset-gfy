{"temperature":1,"model":"","stream":true,"messages":[{"role":"system","content":"You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. "},{"role":"user","content":"## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nget_xlim\n\n"},{"role":"user","content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"},{"role":"user","content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"},{"role":"user","content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:219-233\n        # * capture current plot state\n        old_xlim = plotter.ax.get_xlim()\n        old_ylim = plotter.ax.get_ylim()\n\n        # * clear actual plot elements\n        plotter.ax.cla()\n        # * draw new elements\n        plotter._setup_plot()\n\n        # * restore zoom/pan\n        plotter.ax.set_xlim(old_xlim)\n        plotter.ax.set_ylim(old_ylim)\n        plotter.toggle_zoom_level_elements()\n\n    \n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:261-276\ndef zoom_x_axis(event: KeyEvent):\n        # FYI shift variant of keys is for faster zoom (hence 0.5)\n        match event.key:\n            case \"=\":\n                zoom_factor = 0.8\n            case \"+\":\n                zoom_factor = 0.5\n            case \"-\":\n                zoom_factor = 1 / 0.8\n            case \"_\":\n                zoom_factor = 1 / 0.5\n            case _:\n                return\n        cur = plotter.get_x_limits()\n        new_width_seconds = cur.width * zoom_factor\n        plotter.zoom_and_center_to(new_width_seconds)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:385-404\n    # initial setup of dynamic aspects:\n    plotter.toggle_zoom_level_elements()\n\n    def copy_gap_timing_for_notes(event: KeyEvent):\n        # Bail if mouse is not over the axes\n        if event.inaxes != plotter.ax or event.xdata is None:\n            return\n\n        toolbar = plotter.fig.canvas.manager.toolbar\n        x = event.xdata\n\n        for win in plotter.windows:\n            start = win.gap.start_seconds()\n            end = win.gap.end_seconds()\n            if start <= x <= end:\n                path: Path = plotter.analysis.path\n                filename = path.stem\n\n                txt = f\"{filename}@gap{start:.2f}s-{end:.2f}s\"\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:245-259\ndef cycle_fixed_zoom(event: KeyEvent, up: bool = True):\n        FIXED_ZOOM_LEVELS_SECONDS = [2, 10, 60]\n        cur = plotter.get_x_limits()\n        try:\n            current_index = next( \\\n                i\n                for i, lvl in enumerate(FIXED_ZOOM_LEVELS_SECONDS)\n                if abs(lvl - cur.width) < 0.1 * lvl\n            )\n        except StopIteration:\n            current_index = -1\n        step = 1 if up else -1\n        next_index = (current_index + step) % len(FIXED_ZOOM_LEVELS_SECONDS)\n        new_width = FIXED_ZOOM_LEVELS_SECONDS[next_index]\n        plotter.zoom_and_center_to(new_width)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:178-192\ndef on_scroll(event: MouseEvent):\n        if event.inaxes != plotter.ax:\n            return\n        base_scale = 0.9\n        cur = plotter.get_x_limits()\n        xdata = event.xdata\n        if event.button == 'up':\n            scale_factor = base_scale\n        elif event.button == 'down':\n            scale_factor = 1 / base_scale\n        else:\n            scale_factor = 1\n        new_width = cur.width * scale_factor\n        relx = (xdata - cur.start) / cur.width\n        plotter.set_x_limits(xdata - new_width * relx, xdata + new_width * (1 - relx))\n"},{"role":"user","content":"use new XLimits and get_x_limits()\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/segment_plotter.py:\n\n    def toggle_zoom_level_elements(self):\n        # PRN call this when window is resized (i.e. full screen => split screen)\n\n        # compute density of time\n        xlim = self.ax.get_xlim()\n        visible_seconds = xlim[1] - xlim[0]\n        pixels_per_second = self.ax.bbox.width / visible_seconds\n\n        # hide text labels when zoomed out\n        for txt in self.ax.texts:\n            txt.set_visible(pixels_per_second > 325)\n\n        for marker in self.aligned_markers:\n            for line in marker.lines:\n                line.set_visible(pixels_per_second > 150)\n            marker.text.set_visible(pixels_per_second > 250)\n\n        for annotation in self.arrows:\n            if pixels_per_second > 250:\n                label = f\"{annotation.xy[0]:.2f}s\"\n                annotation.set_text(label)\n            else:\n                annotation.set_text(\"\")\n\n        show_hop_items = visible_seconds < 0.2\n\n        # rich.inspect(ax.xaxis.get_tick_params())\n        self.ax.xaxis.set_tick_params(\n            which='minor',\n            labelbottom=pixels_per_second > 500,  # not really useful b/4 this point (in my testing)\n            bottom=pixels_per_second > 150 and not show_hop_items,\n        )\n        # print(f'{pixels_per_second=}')  # FYI USE THIS WHEN PICKING A LEVEL (pixels_per_second)\n        if pixels_per_second > 1000:\n            self.ax.set_xticklabels(self.minor_labels_all, minor=True)\n        else:\n            self.ax.set_xticklabels(self.minor_labels_every5, minor=True)\n\n        # * hop indicator lines (axvline) - based on zoom level only\n        clear_hop_items()\n        if show_hop_items:\n            # find first hop line that is visble\n            visible_start_seconds = xlim[0]\n            visible_end_seconds = xlim[1]\n            hop_interval = 1 / self.analysis.hops_per_second()\n\n            def show_all_visible_hops():\n                # * show all visible hops (not just gaps)\n                first_hop = math.ceil(visible_start_seconds * self.analysis.hops_per_second())\n                hop = first_hop\n                while True:\n                    hop_sec = hop * hop_interval\n                    if hop_sec > xlim[1]:\n                        break\n                    line = self.ax.axvline(hop_sec, color=\"olive\", linewidth=0.5)  #, alpha=0.5)\n                    hop_items.append(line)\n                    hop += 1\n                    # PRN add tick numbers too? integer? and how about offset based on start, not overall?\n\n            # show_all_visible_hops()\n"}],"chat_template_kwargs":{"reasoning_effort":"low"},"top_p":1,"max_tokens":4096}