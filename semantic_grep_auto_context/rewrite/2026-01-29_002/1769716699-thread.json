{
  "last_sse":{
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "id":"chatcmpl-vU9xi0Mwps3dnXgyl5mRFxOWkUUtNkFG",
    "created":1769716699,
    "choices":[{
        "delta":[],
        "index":0,
        "finish_reason":"stop"
      }],
    "timings":{
      "predicted_n":260,
      "prompt_per_second":7650.7694474255,
      "cache_n":0,
      "prompt_ms":411.854,
      "prompt_per_token_ms":0.1307058076801,
      "predicted_ms":1697.779,
      "predicted_per_token_ms":6.5299192307692,
      "prompt_n":3151,
      "predicted_per_second":153.14125101088
    },
    "system_fingerprint":"b7785-1c7cf94b2"
  },
  "response_message":{
    "content":"for win in analysis6().windows:\n    if len(win.gap.crossovers) != len(win.gap.secondary_crossovers):\n        rich.print(\n            f\"Mismatch: {len(win.gap.crossovers)} crossovers vs {len(win.gap.secondary_crossovers)} secondary\"\n        )\n    rich.print(f\"\")",
    "finish_reason":"stop",
    "reasoning_content":"User asks: \"print if count of crossovers doesnt match count of secondary\". Provide code modification. Need to locate where crossovers count comparison should be added. The snippet shown is from integration_tests.py loop, but likely need to add a check printing something when win.gap.crossovers length != win.gap.secondary_crossovers length. The code snippet is minimal. Provide insertion inside loop. Preserve indentation. No markdown. Provide just code. Should use snake_case. Use type hints? Not needed. Provide a print statement using rich.print maybe. So modify loop:\n\nfor win in analysis6().windows:\n    if len(win.gap.crossovers) != len(win.gap.secondary_crossovers):\n        rich.print(f\"Mismatch: {len(win.gap.crossovers)} crossovers vs {len(win.gap.secondary_crossovers)} secondary\")\n    rich.print(f\"\")\n\nReturn only the changed part? Probably give full snippet.",
    "role":"assistant"
  },
  "request_body":{
    "messages":[{
        "content":"## Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- If changing existing code, preserve unrelated code and comments. \n- Never add comments to the end of a line. \n- Never add stupid comments.\n- Be considerate with indentation. \n- Prefer readable code over of comments. \n- Prefer meaningful names for variables, functions, etc. Avoid ambiguous names.",
        "role":"system"
      },{
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n",
        "role":"user"
      },{
        "content":"## Python Code Preferences\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer `list[]` over `List[]` to mimimize imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/detectors/ideas.py:29-31\n    @property\n    def crosses(self):\n        return self.win.gap.crossovers\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:0-3\nimport pytest\nimport numpy as np\nfrom auto_edit.new_silence.detects.crossings import zero_crossings, Crossover\n\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/breathing.py:209-228\n\n        gap_rms = analysis.rms_slice_for_gap(win)\n\n        win.gap.crossovers, win.gap.secondary_crossovers = compute_and_plot_crossovers(gap_rms, win, analysis, plotter)\n        c = GapContext(win, gap_rms, analysis, plotter)\n        taper_locate(c)\n        if plotter:\n            apply_manual_notes(plotter, c)\n            highlight_taper_with_spans(win, analysis, plotter)\n\n        # If there is exactly one crossover, treat as speech (not breathing)\n        if len(win.gap.crossovers) == 1:\n            continue\n\n        # If more than three crossovers, consider it a nonâ€‘breathing spike\n        if len(win.gap.crossovers) > 3:\n            # TODO is this even needed? this sounds like a double hump right?\n            #  if so, I shouldn't need this, in fact, do I handle this before this point and that's why this doesn't matter?\n            #  I would think this might cause me trouble to say > 3 CPs => not breathing... when half might be breathing!\n            continue\n\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/detects/crossings_tests.py:38-40\ndef test_back_to_back():\n    indices = zero_crossings([0.01, -0.01, 0.02, -0.02, 0.03, -0.03, 0.04])\n    np.testing.assert_array_equal(indices, [Crossover(0, 1), Crossover(1, 2), Crossover(2, 3), Crossover(3, 4), Crossover(4, 5), Crossover(5, 6)])\n\n## ~/repos/github/g0t4/auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:66-274\nclass TestNewSilenceToRanges:\n\n    # TODO what if only partial gap_window? (i.e. leading silence at start of video, or end, plus then at start you have speech after, or at end speech is only before)\n\n    def test_one_window(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n        )\n\n        # FYI only need time.frames, so that's all I am stubbing\n        win.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=45))\n        win.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=63))\n\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # assert len(ranges) == 3\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 45\n        assert type(ranges[0]) == ContentRange\n\n        assert ranges[1].start_frame == 45\n        assert ranges[1].end_frame == 63\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 63\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == ContentRange\n\n    def test_two_back_to_back_windows_with_frame_alignment_shifts(self):\n        # TODO do another test like this but with fraction of frames for all start/end times that way I can test out rounding\n        #   might need different cases to round up/down\n        #   and especially need more cases if I go the route of looking at RMS values to decide how to round\n        #       but only do this when real videos you're editing show the need for it\n        win1 = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n        )\n        win1.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=46))\n        win1.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=64))\n        win2 = GapWindow(\n            # remember gaps overlap => sliding by two at a time basically\n            left_speech=win1.right_speech,  # same as prior right_speech\n            gap=NonSpeechGap(segments=[silence_seg(3, 5.1)]),\n            right_speech=speech_seg(5.1, 6),\n        )\n        win2.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=91))\n        win2.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=152))\n        analysis = fake_analysis_for([win1, win2])\n\n        ranges = get_ranges(analysis)\n\n        # first window\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 46\n        assert type(ranges[0]) == ContentRange\n        assert ranges[1].start_frame == 46\n        assert ranges[1].end_frame == 64\n        assert type(ranges[1]) == SilenceRange\n\n        assert ranges[2].start_frame == 64\n        assert ranges[2].end_frame == 91\n        assert type(ranges[2]) == ContentRange\n        assert ranges[3].start_frame == 91\n        assert ranges[3].end_frame == 152\n        assert type(ranges[3]) == SilenceRange\n\n        # this is the edge case at the end (if no silence after, then need to take this from last window)\n        assert ranges[4].start_frame == 152\n        assert ranges[4].end_frame == 180\n        assert type(ranges[4]) == ContentRange\n\n    def test_taper_out_and_in(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n        )\n        win.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=48))\n        win.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=60))\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 48\n\n        assert ranges[1].start_frame == 48\n        assert ranges[1].end_frame == 60\n\n        assert ranges[2].start_frame == 60\n        assert ranges[2].end_frame == 90\n\n    def test_window_without_left_speech(self):\n        win = GapWindow(\n            left_speech=None,\n            gap=NonSpeechGap(segments=[silence_seg(0, 1)]),\n            right_speech=speech_seg(1, 2),\n        )\n        win.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=0))\n        win.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=30))\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # silence at the start\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 30\n        assert type(ranges[0]) == SilenceRange\n        # following speech segment\n        assert ranges[1].start_frame == 30\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == ContentRange\n\n    def test_window_without_right_speech(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1),\n            gap=NonSpeechGap(segments=[silence_seg(1, 2)]),\n            right_speech=None,\n        )\n        win.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=30))\n        win.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=60))\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        # speech at the start\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 30\n        assert type(ranges[0]) == ContentRange\n        # following silence segment\n        assert ranges[1].start_frame == 30\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == SilenceRange\n\n    def test_window_with_no_speech(self):\n        # this is not really that useful...\n        # why would I have a recording with no speaking? and then want to edit it?\n        # certainly I wouldn't need careful silence gap analysis and segmenting...\n        # if anything, I'd want segmenting based on visual changes (visual equivalent of silence splitting)\n        # nonetheless, good edge case to consider (doesn't pressure anything not already covered in other tests)\n\n        win = GapWindow(\n            left_speech=None,\n            gap=NonSpeechGap(segments=[silence_seg(1, 2)]),\n            right_speech=None,\n        )\n        analysis = fake_analysis_for([win])\n\n        ranges = get_ranges(analysis)\n\n        assert ranges[0].start_frame == 30\n        assert ranges[0].end_frame == 60\n\n    def test_multiple_windows_with_silence_at_start_and_end(self):\n        # this is 99% of all recordings (always a quiet start/end)\n\n        win1 = GapWindow(\n            left_speech=None,\n            gap=NonSpeechGap(segments=[silence_seg(0, 1)]),\n            right_speech=speech_seg(1, 2),\n        )\n        win1.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=0))\n        win1.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=30))\n\n        win2 = GapWindow(\n            left_speech=win1.right_speech,\n            gap=NonSpeechGap(segments=[silence_seg(2, 3)]),\n            right_speech=speech_seg(3, 4),\n        )\n        win2.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=60))\n        win2.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=90))\n\n        win3 = GapWindow(\n            left_speech=win2.right_speech,\n            gap=NonSpeechGap(segments=[silence_seg(4, 5)]),\n            right_speech=None,\n        )\n        win3.gap.left_taper_end = SimpleNamespace(time=SimpleNamespace(frames=120))\n        win3.gap.right_taper_start = SimpleNamespace(time=SimpleNamespace(frames=150))\n        analysis = fake_analysis_for([win1, win2, win3])\n\n        ranges = get_ranges(analysis)\n\n        assert len(ranges) == 5\n\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 30\n        assert type(ranges[0]) == SilenceRange\n\n        assert ranges[1].start_frame == 30\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == ContentRange\n\n        assert ranges[2].start_frame == 60\n        assert ranges[2].end_frame == 90\n        assert type(ranges[2]) == SilenceRange\n\n        assert ranges[3].start_frame == 90\n        assert ranges[3].end_frame == 120\n        assert type(ranges[3]) == ContentRange\n\n        assert ranges[4].start_frame == 120\n        assert ranges[4].end_frame == 150\n        assert type(ranges[4]) == SilenceRange\n",
        "role":"user"
      },{
        "content":"print if count of crossovers doesnt match count of sedondary\n\nHere is the code I selected:\n```auto_edit/new_silence/tests/integration_tests.py\n        for win in analysis6().windows:\n            rich.print(f\"\")\n```\n\nThis is not necessarily a complete selection of nearby code, this is just the part I want help with. Preserve indentation!",
        "role":"user"
      }],
    "model":"",
    "stream":true,
    "chat_template_kwargs":{
      "reasoning_effort":"medium"
    },
    "top_p":1,
    "temperature":1,
    "max_tokens":8192
  }
}