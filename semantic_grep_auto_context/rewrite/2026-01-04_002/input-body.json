{"top_p":1,"max_tokens":4096,"temperature":1,"model":"","messages":[{"content":"You are an expert coder. Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- Never add comments to the end of a line. \n- Never add comments.\n- Preserve indentation. \n- If rewriting code, preserve unrelated code. \n- Prefer readable code over of comments. ","role":"system"},{"content":"## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n@dataclass(frozen=True)\nclass XLimits:\n    start: float\n    end: float\n    width: float\n\nclass SegmentPlotter:\n    # existing methods ...\n\n    def get_x_limits(self) -> XLimits:\n        start, end = self.ax.get_xlim()\n        return XLimits(start=start, end=end, width=end - start)\n\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        cur = self.get_x_limits()\n        half = cur.width / 2\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        cur = self.get_x_limits()\n        middle = (cur.start + cur.end) / 2\n        half = width_seconds / 2\n        self.set_x_limits(middle - half, middle + half)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nget_x_limits\n\n","role":"user"},{"content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n","role":"user"},{"content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n","role":"user"},{"content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:101-134\n@dataclass\nclass NonSpeechGap:\n    segments: list[DetectedSegment]\n\n    def __len__(self) -> int:\n        return len(self.segments)\n\n    def __iter__(self):\n        return iter(self.segments)\n\n    # TODO unify interface for segments\n    #   (add @property to start/end_seconds and change usages...\n    #   duration_seconds could be a property too, OR maybe a method to indicate read only\n    #     if go method route, update other property based duration_seconds to be methods\n    #      the same properties/method should exist on all my segement types... i.e. NonSpeechGap, DetectedSegment (left/right_speech), CombinedSegments, etc... maybe even GapWindow\n    #      that way I always know where to go to get the value regardless what segment it is\n    def start_seconds(self) -> float:\n        return self.segments[0].start_seconds\n\n    def end_seconds(self) -> float:\n        return self.segments[-1].end_seconds\n\n    def middle_seconds(self) -> float:\n        return (self.start_seconds() + self.end_seconds()) / 2\n\n    def duration_seconds(self) -> float:\n        return self.end_seconds() - self.start_seconds()\n\n    def contains(self, seconds) -> bool:\n        return self.start_seconds() <= seconds < self.end_seconds()\n\n    def __repr__(self) -> str:\n        segs = \", \".join(str(s.id) for s in self.segments)\n        return f\"NonSpeechGap(segments=[{segs}])\"\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/silences/detect_raw.py:5-7\ndef __init__(self, start_seconds: float, end_seconds: float):\n        self.start_seconds = start_seconds\n        self.end_seconds = end_seconds\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:40-50\n\n\n@dataclass(frozen=True)\nclass DetectedSegment:\n    id: int\n    start_seconds: float\n    end_seconds: float\n    label: SegmentLabel\n    rms_values: RMSValues\n\n    \n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/ranges.py:72-88\nclass SilenceRange(FrameRange):\n\n    dampen: bool = True  # reduce audio level of entire clip, defaults to True for legacy silence detect approach\n\n    def __str__(self):\n        result = f\"Silence[{self.start_frame}âžœ{self.end_frame})\"\n        if self.dampen:\n            result += f\" dampen\"\n        return result\n\n    def __copy__(self):\n        return self.__deepcopy__()\n\n    def __deepcopy__(self, memo=None):\n        new = SilenceRange(self.start_frame, self.end_frame)\n        new.dampen = self.dampen\n        return new\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/spectral_analysis.py:15-32\n\nimport numpy as np\nimport librosa\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom rich.console import Console\n\nconsole = Console()\n\nimport rich\nfrom auto_edit.new_silence.detects.segments import (\n    AudioAnalysisResult,\n    DetectedSegment,\n    GapWindow,\n    SegmentLabel,\n)\n\n\n","role":"user"},{"content":"make width a property, then add middle proeprty too and half property\nHere is code I selected (with carefully preserved indentation) from auto_edit/new_silence/player/segment_plotter.py:\n@dataclass(frozen=True)\nclass XLimits:\n    start: float\n    end: float\n    width: float","role":"user"}],"stream":true,"chat_template_kwargs":{"reasoning_effort":"low"}}