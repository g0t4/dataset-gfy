{"content":"def _pan_by_width_factor(factor: float, direction: int) -> None:\n    cur = plotter.get_x_limits()\n    delta = direction * cur.width * factor\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\ndef _pan_by_half(direction: int) -> None:\n    cur = plotter.get_x_limits()\n    delta = direction * cur.half\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\ndef pan_left(event: KeyEvent):\n    _pan_by_width_factor(0.1, -1)\n\ndef pan_right(event: KeyEvent):\n    _pan_by_width_factor(0.1, 1)\n\ndef pan_page_left(event: KeyEvent):\n    _pan_by_width_factor(1.0, -1)\n\ndef pan_page_right(event: KeyEvent):\n    _pan_by_width_factor(1.0, 1)\n\ndef pan_half_page_left(event: KeyEvent):\n    _pan_by_half(-1)\n\ndef pan_half_page_right(event: KeyEvent):\n    _pan_by_half(1)","finish_reason":"stop","reasoning_content":"We need to extract a shared function to eliminate duplicate code between these functions. Probably create a helper that takes a shift factor (relative or absolute) and direction. For pan_left/right use shift = cur.width * 0.1, for page left/right shift = cur.width, half page shift = cur.half. Could define a generic pan(event, factor: float, direction: int) where direction = -1 left, 1 right. Or a function apply_pan(delta: float) that sets x limits with start+delta, end+delta.\n\nWe need to modify code in plot_helpers.py to use this shared function, while preserving unrelated code. Provide only code (no markdown). Must follow Python preferences: snake_case, type hints, no comments. No docstrings. So produce the updated snippet: define helper function _pan(delta: float) -> None, then rewrite each pan_* to call it.\n\nWe need to preserve indentation as originally. Likely code resides at top-level in file. Provide function definition with type hints, using plotter variable from outer scope? In original functions, they reference plotter from closure (maybe imported). Keep same.\n\nImplementation:\n\ndef _apply_pan(delta: float) -> None:\n    cur = plotter.get_x_limits()\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\nThen pan_left: _apply_pan(-cur.width * 0.1) but need cur. Actually we can compute delta inside each function using factor, but we can also pass a factor and direction to helper that computes delta.\n\nBetter: def _pan_by_factor(factor: float, direction: int) -> None: cur = plotter.get_x_limits(); delta = direction * factor * cur.width if factor not None else direction * cur.half etc. But half page uses cur.half not cur.width * factor.\n\nSimplify: define generic _pan(delta: float) and each function compute delta accordingly.\n\nImplement pan_left: delta = -cur.width * 0.1; _pan(delta). But need cur. Could compute inside each function: cur = plotter.get_x_limits(); delta = -cur.width * 0.1; _apply_pan(delta). That's still duplicate but less.\n\nAlternatively: define helper that takes a shift amount (absolute) and direction sign.\n\nLet's create:\n\ndef _pan_shift(shift: float, left: bool) -> None:\n    cur = plotter.get_x_limits()\n    delta = -shift if left else shift\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\nThen pan_left: _pan_shift(cur.width * 0.1, True). But still need cur. Could compute shift inside each: shift = cur.width * 0.1; _pan_shift(shift, True). That's fine.\n\nWe can also make functions one-liners calling _pan_shift with computed shift.\n\nImplement as:\n\ndef _pan_shift(shift: float, left: bool) -> None:\n    cur = plotter.get_x_limits()\n    delta = -shift if left else shift\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\nThen:\n\ndef pan_left(event: KeyEvent):\n    cur = plotter.get_x_limits()\n    _pan_shift(cur.width * 0.1, True)\n\nBut still duplicate cur retrieval. Could change to:\n\ndef pan_left(event: KeyEvent):\n    _pan_by_factor(0.1, -1)\n\nDefine:\n\ndef _pan_by_factor(factor: float, direction: int) -> None:\n    cur = plotter.get_x_limits()\n    delta = direction * cur.width * factor\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\nThen pan_left: _pan_by_factor(0.1, -1); pan_right: _pan_by_factor(0.1, 1); pan_page_left: _pan_by_factor(1, -1); pan_page_right: _pan_by_factor(1, 1); pan_half_page_left: _pan_by_half(-1); define separate helper for half using cur.half.\n\nAlternatively extend _pan_by_factor to accept optional use_half flag.\n\nSimplify: create two helpers: _pan_by_width_factor and _pan_by_half.\n\nImplement:\n\ndef _pan_by_width_factor(factor: float, direction: int) -> None:\n    cur = plotter.get_x_limits()\n    delta = direction * cur.width * factor\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\ndef _pan_by_half(direction: int) -> None:\n    cur = plotter.get_x_limits()\n    delta = direction * cur.half\n    plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\nThen functions call these.\n\nLet's produce updated code block.","role":"assistant"}