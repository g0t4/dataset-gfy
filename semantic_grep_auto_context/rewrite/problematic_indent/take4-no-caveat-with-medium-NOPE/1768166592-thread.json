{
  "request_body":{
    "stream":true,
    "messages":[{
        "role":"system",
        "content":"## Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- If changing existing code, preserve unrelated code and comments. \n- Never add comments to the end of a line. \n- Never add stupid comments.\n- Be considerate with indentation. \n- Prefer readable code over of comments. \n- Prefer meaningful names for variables, functions, etc. Avoid ambiguous names."
      },{
        "role":"user",
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n"
      },{
        "role":"user",
        "content":"## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n"
      },{
        "role":"user",
        "content":"# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:29-373\ndef setup_events(plotter: \"SegmentPlotter\"):\n\n    def on_close(event: CloseEvent):\n        pass\n        #     subprocess.run([\n        #         \"osascript\",\n        #         \"-e\",\n        #         'tell application \"iTerm\" to activate',\n        #     ])\n\n    def on_key(event: KeyEvent):\n        # rich.inspect(event) # cool way to see all the event details!\n        # existing navigation\n        if event.key == \"left\":\n            pan_left(event)\n        elif event.key == \"right\":\n            pan_right(event)\n        elif event.key == \"ctrl+left\":\n            pan_to_previous_gap(event)\n        elif event.key == \"ctrl+right\":\n            pan_to_next_gap(event)\n        elif event.key == \"up\":\n            pan_up(event)\n        elif event.key == \"down\":\n            pan_down(event)\n        elif event.key in (\"ctrl+up\", \"ctrl+down\"):\n            zoom_y_axis(event)\n        elif event.key == \"home\":\n            pan_to_start(event)\n        elif event.key == \"end\":\n            pan_to_end(event)\n        elif event.key in (\"ctrl+u\", \"ctrl+d\", \"ctrl+b\", \"ctrl+f\", \"pageup\", \"pagedown\"):\n            # paging left/right\n            # vim style: ctrl+b/f = left/right full page, ctrl+u/d = half page, pageup/pagedown = full page left/right\n            if event.key in (\"ctrl+b\", \"pageup\"):\n                pan_page_left(event)\n            elif event.key in (\"ctrl+f\", \"pagedown\"):\n                pan_page_right(event)\n            elif event.key == \"ctrl+u\":\n                pan_half_page_left(event)\n            elif event.key == \"ctrl+d\":\n                pan_half_page_right(event)\n        if event.key == \"escape\":\n            sd.stop()\n        elif event.key == \"ctrl+shift+up\":\n            increase_frame_len(event)\n        elif event.key == \"ctrl+shift+down\":\n            decrease_frame_len(event)\n        elif event.key == \"cmd+=\":\n            # match FCPX zoom keymap (albeit that one is not fixed)\n            cycle_fixed_zoom(event, up=True)\n        elif event.key == \"cmd+-\":\n            # match FCPX zoom keymap (albeit that one is not fixed)\n            cycle_fixed_zoom(event, up=False)\n        elif event.key == \"t\":\n            # DO NOT USE a key that is already mapped.. it will trigger it still!\n            #   NOT: f, g, l\n            toggle_gridlines(event)\n        elif event.key == \"y\":\n            # copy start/end of the gap under the cursor to clipboard\n            copy_gap_timing_for_notes(event)\n        elif event.key == \"h\":\n            plotter.toggle_crosshair()\n        elif event.key in (\"+\", \"=\", \"-\", \"_\"):\n            zoom_x_axis(event)\n\n    def pan_to_start(event: KeyEvent):\n        cur = plotter.get_x_limits()\n        start_time = plotter.segments[0].start_seconds\n        plotter.set_x_limits(start_time, start_time + cur.width)\n\n    def pan_to_end(event: KeyEvent):\n        cur = plotter.get_x_limits()\n        end_time = plotter.segments[-1].end_seconds\n        plotter.set_x_limits(end_time - cur.width, end_time)\n\n    def toggle_gridlines(event: KeyEvent):\n        # FYI gridlines are initially OFF...\n        # toggle them ON when I need to see nearest frame (minor ticks)\n        # btw gridlines are associated with ticks, thus need to check tick params\n        #   every other API above axis.get/set_tick_params is just a wrapper around this lower level set_tick_params function\n\n        # * check if on/off... PITA with separate values per major/minor, so I will assume it is off and turnit on first time using visible_grid\n        # x_minor_grid_on = ax.xaxis.get_tick_params(which=\"minor\")[\"gridOn\"]\n        # x_major_grid_on = ax.xaxis.get_tick_params(which=\"major\")[\"gridOn\"]\n        # print(f'{x_major_grid_on=} {x_minor_grid_on=}')\n\n        # * set style first\n        plotter.ax.xaxis.grid(which='minor', linewidth=1)\n        plotter.ax.xaxis.grid(which='major', linewidth=1, color='black')\n        # arguably, I could set this once w/ ax.tick_params (or otherwise)\n        #   but, I want to keep all of this self-contained in this function\n        # kwargs: linewidth, linestyle, color, alpha (see ax.tick_params docs)\n        #   FYI grid(linewidth=X) == set_tick_params(grid_linewidth=X)\n        #   the same kwarg is named different based on function ðŸ¤¦\u200dâ™‚ï¸\n        #\n        # * set on/off\n        global visible_grid\n        visible_grid = not visible_grid\n        plotter.ax.xaxis.grid(visible=visible_grid, which='both')  # then, set visibility\n        # FTR which='both' == both 'major' and 'minor'\n        # !!! DO NOT PASS both visible and kwargs\n        # !!! ... unless you like SURPRISE, RAWDOG, BUTT SECKS in your penis hole\n        #   so, NOT THIS:\n        #     ax.xaxis.grid(visible_grid, which='both', linewidth=2)\n        # passing any `kwargs` => sets `visible=True` (always)\n        #   just F12 into .grid() and you'll see!\n        #   kwargs are where you pass characteristics like linewidth\n        # btw... `which` is a positional arg so you can pass it (and should)\n\n        plotter.fig.canvas.draw_idle()\n\n    def pan_to_previous_gap(event):\n        cur = plotter.get_x_limits()\n        gaps_before_center = (win for win in reversed(plotter.windows) if win.gap.end_seconds() < cur.middle)\n        prev_window = next(gaps_before_center, None)\n        plotter.shift_center_to_gap(prev_window)\n\n    def pan_to_next_gap(event):\n        cur = plotter.get_x_limits()\n        gaps_after_center = (win for win in plotter.windows if win.gap.start_seconds() > cur.middle)\n        next_window = next(gaps_after_center, None)\n        plotter.shift_center_to_gap(next_window)\n\n    def _pan_x_by_factor(factor: float) -> None:\n        cur = plotter.get_x_limits()\n        delta = cur.width * factor\n        plotter.set_x_limits(cur.start + delta, cur.end + delta)\n\n    def pan_left(event: KeyEvent):\n        _pan_x_by_factor(-0.1)\n\n    def pan_right(event: KeyEvent):\n        _pan_x_by_factor(0.1)\n\n    def pan_page_left(event: KeyEvent):\n        _pan_x_by_factor(-1.0)\n\n    def pan_page_right(event: KeyEvent):\n        _pan_x_by_factor(1.0)\n\n    def pan_half_page_left(event: KeyEvent):\n        _pan_x_by_factor(-0.5)\n\n    def pan_half_page_right(event: KeyEvent):\n        _pan_x_by_factor(0.5)\n\n    def on_scroll(event: MouseEvent):\n        if event.inaxes != plotter.ax:\n            return\n        base_scale = 0.9\n        cur = plotter.get_x_limits()\n        xdata = event.xdata\n        if event.button == 'up':\n            scale_factor = base_scale\n        elif event.button == 'down':\n            scale_factor = 1 / base_scale\n        else:\n            scale_factor = 1\n        new_width = cur.width * scale_factor\n        relx = (xdata - cur.start) / cur.width\n        plotter.set_x_limits(xdata - new_width * relx, xdata + new_width * (1 - relx))\n\n    def decrease_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length // 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def increase_frame_len(event: KeyEvent):\n        params = AnalysisParams()\n        params.frame_length = plotter.analysis.frame_length * 2\n        params.hop_length = plotter.analysis.hop_length\n        redo_analysis_with(params)\n\n    def redo_analysis_with(params: AnalysisParams):\n        old_analysis = plotter.analysis\n        new_analysis = create_analysis(old_analysis.audio, params)\n        new_analysis.path = old_analysis.path\n\n        # * setup data for new plot (as if call SegmentPlotter() again)\n        # PRN look at ctor for overlap to refactor?\n        plotter.analysis = new_analysis\n        plotter.segments = new_analysis.merged_segments\n        plotter.windows = new_analysis.windows\n        plotter.aligned_markers = []\n        plotter.arrows = []\n\n        # * capture current plot state\n        old_xlim = plotter.ax.get_xlim()\n        old_ylim = plotter.ax.get_ylim()\n\n        # * clear actual plot elements\n        plotter.ax.cla()\n        # * draw new elements\n        plotter._setup_plot()\n\n        # * restore zoom/pan\n        plotter.ax.set_xlim(old_xlim)\n        plotter.ax.set_ylim(old_ylim)\n        plotter.toggle_zoom_level_elements()\n\n    def _pan_y_by_factor(factor: float) -> None:\n        cur = plotter.get_y_limits()\n        delta = cur.height * factor\n        plotter.set_y_limits(cur.bottom + delta, cur.top + delta)\n\n    def pan_up(event: KeyEvent):\n        _pan_y_by_factor(0.1)\n\n    def pan_down(event: KeyEvent):\n        _pan_y_by_factor(-0.1)\n\n    def cycle_fixed_zoom(event: KeyEvent, up: bool = True):\n        FIXED_ZOOM_LEVELS_SECONDS = [0.2, 2, 10, 60]\n        cur = plotter.get_x_limits()\n        try:\n            current_index = next( \\\n                i\n                for i, lvl in enumerate(FIXED_ZOOM_LEVELS_SECONDS)\n                if abs(lvl - cur.width) < 0.1 * lvl\n            )\n        except StopIteration:\n            current_index = -1\n        step = 1 if up else -1\n        next_index = (current_index + step) % len(FIXED_ZOOM_LEVELS_SECONDS)\n        new_width = FIXED_ZOOM_LEVELS_SECONDS[next_index]\n        plotter.zoom_and_center_to(new_width)\n\n    def zoom_x_axis(event: KeyEvent):\n        # FYI shift variant of keys is for faster zoom (hence 0.5)\n        match event.key:\n            case \"=\":\n                zoom_factor = 0.8\n            case \"+\":\n                zoom_factor = 0.5\n            case \"-\":\n                zoom_factor = 1 / 0.8\n            case \"_\":\n                zoom_factor = 1 / 0.5\n            case _:\n                return\n        cur = plotter.get_x_limits()\n        new_width_seconds = cur.width * zoom_factor\n        plotter.zoom_and_center_to(new_width_seconds)\n\n    def zoom_y_axis(event: KeyEvent):\n        # FYI unlike x-axis, no need for fast y-axis zooming\n        match event.key:\n            case \"ctrl+up\":\n                zoom_factor = 0.8\n            case \"ctrl+down\":\n                zoom_factor = 1 / 0.8\n            case _:\n                return\n        cur = plotter.get_y_limits()\n        new_height = cur.height * zoom_factor\n        new_half = new_height / 2\n        # zoom in on the middle (middle stays in the middle) ...\n        # PRN zoom in on mouse position?\n        # - cursor => ratio => scale that ratio so the cursor's y-position points at the same thing before/after\n        # - DO NOT move the cursor's position to the middle?\n        plotter.set_y_limits(cur.middle - new_half, cur.middle + new_half)\n\n    def on_motion_notify_event(event: MouseEvent):\n        # PRN throttle this and cancel previous, would that help with timing?\n        messages = []\n        if event.inaxes is not None:\n            if event.xdata is not None and event.ydata is not None:\n\n                # * mouse coords\n                cursor_seconds = event.xdata\n                cursor_timecode = seconds_to_timecode(cursor_seconds, plotter.analysis.fps)\n                cursor_hops = plotter.analysis.to_hops(cursor_seconds)\n                cursor_db = event.ydata\n                cursor_frames = cursor_seconds * plotter.analysis.fps\n                x_width_seconds = plotter.get_x_limits().width\n                messages += [\n                    f\"x-axis width: {x_width_seconds:.4f}s\",  # ideally this would go elsewhere... fine for now\n                    # FYI try to put almost/always present messages at bottom\n                    f\"cursor: {cursor_timecode} | {cursor_seconds:.2f}s | {cursor_hops:,} hops | {cursor_frames:,.2f} frames\",\n                    f\"              {cursor_db:.1f}dB\",\n                ]\n\n                # * primary window segment\n                window = plotter.analysis.window_at_seconds(cursor_seconds)\n                if window:\n                    l = window.left_speech\n                    r = window.right_speech\n                    g = window.gap\n\n                    def show_relative(seg_start_sec, seg_end_sec):\n                        # show offset relative to primary window segment (i.e. to start/end of gap)\n                        from_sec = cursor_seconds - seg_start_sec\n                        to_sec = cursor_seconds - seg_end_sec\n                        from_hops = from_sec * plotter.analysis.hops_per_second()\n                        to_hops = to_sec * plotter.analysis.hops_per_second()\n                        messages.append(f\"     from start: {from_sec:.4f}s | {from_hops:,.1f} hops\")\n                        messages.append(f\"          to end: {to_sec:.4f}s | {to_hops:,.1f} hops\")\n\n                    if l and l.contains(cursor_seconds):\n                        # TODO standardize on function/property for start_seconds()/end_seconds()/duration_seconds() and cleanup duplication\n                        messages.append(f\"  [speech dur={l.duration_seconds:.2f}s ({l.start_seconds:.2f}sâžœ{l.end_seconds:.2f}s)]\")\n                        show_relative(l.start_seconds, l.end_seconds)\n                    elif r and r.contains(cursor_seconds):\n                        messages.append(f\"  [speech dur={r.duration_seconds:.2f}s ({r.start_seconds:.2f}sâžœ{r.end_seconds:.2f}s)]\")\n                        show_relative(r.start_seconds, r.end_seconds)\n                    elif g and g.contains(cursor_seconds):\n                        messages.append(f\"  [gap dur={g.duration_seconds():.2f}s ({g.start_seconds():.2f}sâžœ{g.end_seconds():.2f}s)]\")\n                        show_relative(g.start_seconds(), g.end_seconds())\n\n        plotter.set_message(messages)\n        event.canvas.draw_idle()\n\n    plotter.fig.canvas.mpl_connect('scroll_event', on_scroll)\n    plotter.fig.canvas.mpl_connect(\"motion_notify_event\", on_motion_notify_event)\n    plotter.fig.canvas.mpl_connect(\"key_press_event\", on_key)\n    plotter.fig.canvas.mpl_connect(\"button_press_event\", plotter._on_click)\n    plotter.fig.canvas.mpl_connect(\"close_event\", on_close)\n\n    plotter.toggle_zoom_level_elements()\n\n    def copy_gap_timing_for_notes(event: KeyEvent):\n        # Bail if mouse is not over the axes\n        if event.inaxes != plotter.ax or event.xdata is None:\n            return\n\n        x = event.xdata\n\n        for win in plotter.windows:\n            start = win.gap.start_seconds()\n            end = win.gap.end_seconds()\n            if start <= x <= end:\n                path: Path = plotter.analysis.path\n                filename = path.stem\n\n                txt = f\"{filename}@gap{start:.2f}s-{end:.2f}s\"\n\n                # I have pbcopy aliased on all platforms to a local copy method\n                subprocess.run(['pbcopy'], input=txt.encode())\n\n                plotter.set_message(f\"Copied: {txt}\")\n                return\n\n        plotter.set_message(\"mouse is not over a NonSpeechGap, nothing to copy\")\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:0-17\nfrom pathlib import Path\nimport subprocess\nimport rich\nimport sounddevice as sd\nfrom matplotlib.axes import Axes\nfrom matplotlib.backend_bases import CloseEvent, KeyEvent, MouseEvent\nfrom matplotlib.collections import PathCollection\nfrom matplotlib.figure import Figure\nfrom matplotlib.lines import Line2D\n\nfrom auto_edit.new_silence.detect import AnalysisParams, create_analysis\nfrom auto_edit.new_silence.detects.humanize import seconds_to_timecode\nfrom auto_edit.new_silence.detects.segments import GapWindow\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from .segment_plotter import SegmentPlotter\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/breathing_state.py:27-30\ndef set_plotter(plotter: \"SegmentPlotter\"):\n    # pass this instead of using plt.gca()... that helps avoid creating a new axes if called in wrong order\n    global _plotter\n    _plotter = plotter\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:80-137\n@dataclass\nclass DetectedSegment:\n    id: int\n    start_seconds: float  # PRN start: AVTime\n    end_seconds: float  # PRN end: AVTime\n    label: SegmentLabel\n    rms_values: RMSValues\n\n    @property\n    def duration_seconds(self) -> float:\n        return self.end_seconds - self.start_seconds\n\n    @property\n    def rms_summary(self) -> str:\n        rms = self.rms_values\n        min_val = float(rms.min())\n        mean_val = float(rms.mean())\n        max_val = float(rms.max())\n        # 5.1 ==> b/c one digit for - sign, two for tens/ones before decimal, one for decimal and one after decimal == 5 chars padding (notably to left pad single digit dB values so columns line up across segments when list is printed)\n        return f\"min={round(min_val, 1):5.1f} mean={round(mean_val, 1):5.1f} max={round(max_val, 1):5.1f} len={len(rms)}\"\n\n    def contains(self, seconds) -> bool:\n        return self.start_seconds <= seconds < self.end_seconds\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def __str__(self, no_color=False) -> str:\n\n        label = self.label.value.lower()\n        if not no_color:\n            label = colorize(self.label.value.lower(), self.plot_color())\n\n        # 4 for left padding id\n        return f\"{self.id:4} {label}: [{self.start_seconds:.3f}->{self.end_seconds:.3f}) {self.duration_seconds:.3f}s {self.rms_summary}\"\n\n    def get_plot_message(self, fps: int) -> str:\n\n        start = seconds_to_timecode(self.start_seconds, fps)\n        end = seconds_to_timecode(self.end_seconds, fps)\n\n        rms = self.rms_values\n        min_val = float(rms.min())\n        mean_val = float(rms.mean())\n        max_val = float(rms.max())\n        rms_repr = f\"min={round(min_val, 1):5.1f} mean={round(mean_val, 1):5.1f} max={round(max_val, 1):5.1f}\"\n\n        return f\"{self.id:4} \" \\\n                f\"[{start}âžœ{end}) \" \\\n                f\"{self.label.value.lower():6} {self.duration_seconds:.3f}s \" \\\n                + rms_repr\n\n    def plot_color(self) -> str:\n        return {\n            SegmentLabel.SILENCE: \"cornflowerblue\",\n            SegmentLabel.BREATH: \"magenta\",\n            SegmentLabel.SPEECH: \"red\",\n        }.get(self.label, \"green\")\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/plot_helpers.py:25-31\n\n\nvisible_grid = False\n\ndef setup_events(plotter: \"SegmentPlotter\"):\n\n    \n"
      },{
        "role":"user",
        "content":"only join if it is a list, not if string\n\nHere is the code I selected:\n```auto_edit/new_silence/player/segment_plotter.py\n    def set_message(self, lines):\n        text = \"\\n\".join(lines)\n        self.message_text.set_text(text)\n        self.fig.canvas.draw_idle()\n```"
      }],
    "max_tokens":8192,
    "top_p":1,
    "model":"",
    "temperature":1,
    "chat_template_kwargs":{
      "reasoning_effort":"medium"
    }
  },
  "last_sse":{
    "system_fingerprint":"b7616-18ddaea2a",
    "timings":{
      "predicted_per_second":210.57575694846,
      "predicted_n":295,
      "prompt_per_token_ms":4.6995,
      "prompt_n":4,
      "cache_n":4794,
      "prompt_ms":18.798,
      "prompt_per_second":212.78859453133,
      "predicted_ms":1400.921,
      "predicted_per_token_ms":4.7488847457627
    },
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "object":"chat.completion.chunk",
    "created":1768166592,
    "id":"chatcmpl-l38ej2W8DkliinLbucNPV8FTIv50bU35",
    "choices":[{
        "finish_reason":"stop",
        "index":0,
        "delta":[]
      }]
  },
  "response_message":{
    "content":"from typing import Union, List\n\ndef set_message(self, lines: Union[str, List[str]]) -> None:\n    if isinstance(lines, str):\n        text = lines\n    else:\n        text = \"\\n\".join(lines)\n    self.message_text.set_text(text)\n    self.fig.canvas.draw_idle()",
    "reasoning_content":"The user says: \"only join if it is a list, not if string\". They show code snippet:\n\n```auto_edit/new_silence/player/segment_plotter.py\n    def set_message(self, lines):\n        text = \"\\n\".join(lines)\n        self.message_text.set_text(text)\n        self.fig.canvas.draw_idle()\n```\n\nSo they want to modify set_message to only join if lines is a list, not if string. Probably lines could be a string; joining a string would join characters. Should detect type. Use isinstance(lines, list) or (list, tuple). If string, treat as is.\n\nAdd type hint: lines: list[str] | str? And code:\n\ndef set_message(self, lines):\n    if isinstance(lines, str):\n        text = lines\n    else:\n        text = \"\\n\".join(lines)\n    self.message_text.set_text(text)\n    self.fig.canvas.draw_idle()\n\nMake sure import typing? Not needed.\n\nImplement change. Ensure we preserve unrelated code/comments.\n\nThus edit file auto_edit/new_silence/player/segment_plotter.py accordingly.",
    "role":"assistant",
    "finish_reason":"stop"
  }
}