{
  "request_body":{
    "max_tokens":2048,
    "top_p":1,
    "stream":true,
    "messages":[{
        "content":"## Ground rules:\n- Follow the user's instructions. \n- DO NOT wrap answers in markdown code blocks, which means no triple backticks like ``` nor single backtick like ` .\n- Do not explain answers, just give me code. \n- If changing existing code, preserve unrelated code and comments. \n- Never add comments to the end of a line. \n- Never add stupid comments.\n- Be considerate with indentation. \n- Prefer readable code over of comments. \n- Prefer meaningful names for variables, functions, etc. Avoid ambiguous names.",
        "role":"system"
      },{
        "content":"## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n",
        "role":"user"
      },{
        "content":"## Fish Shell Code Preferences\n\n- Use snake_case for functions and variables.\n- When a condition is ambiguous, assign it to a well‑named variable before the `if`.\n- Prefer long options, i.e. `--quiet` over `-q`, `--regex` over `-r`\n- Fish shell does not do word splitting like bash, no need to wrap everything in quotes!\n\n## Fish syntax examples\n\n```fish\n# exploit fish-isms!\n\n# use `not`, avoid `!`\nif not test -f spoon\n    echo There is no spoon\n    exit 1\nend\n\n# if + set\nif set -l message (some_command)\n    echo \"ok: $message\"\nelse\n    echo \"fail: $message\"\nend\n\n# prefer named arguments\nfunction show_variable -a name value\n    echo \"$name = $value\"\nend\n\n# fish doesn't have heredocs, use begin/end\nbegin\n    echo $header\n    echo $table\nend > out.html\n# or multi-line strings\necho \"\nfoo\nbar\n\" > test\n\n# every variable is an array\nset names wes john bob jane\nfor name in $names\n    echo $name\nend\n\nfor i in *.tmp\n    if grep DONE $i\n        break\n    end\n    if grep SKIP $i\n        continue\n    end\n    ...\nend\n\n# combine conditions\nwhile test -f foo.txt; or test -f bar.txt\n    ...\nend\n\n# conditional execution\nmake; and make install; or make clean\n```\n\n### builtin fish commands\n\nNow that we have more than 2KB of system RAM, we can fix most of what sucks about bash...\n\n```fish\n# *** string command\n\n# match: test, filter, extract\nstring match --quiet '*.lua' $file\nset lua_files (string match '*.lua' $files)\nset version (string match --regex 'v([0-9.]+)' $tag)\nstring match --index --regex 'ERROR' $line\n\n# replace: transform text\nset fixed (string replace foo bar $text)\nset cleaned (string replace --regex '\\s+' ' ' $line)\nset base (string replace --regex '\\.[^.]+$' '' $file)\nset normalized (string replace --filter --regex '^./' '' $paths)\n\n# split: tokenize\nset parts (string split ':' $PATH)\nset lines (string split '\\n' $text)\nset ext (string split --right --max 1 . $file)[2]\n\n# trim: clean edges\nset clean (string trim $line)\nset unquoted (string trim --chars '\"' $s)\n\n# join: build strings\nstring join ' ' $argv\nstring join --no-empty ':' $PATH\n\n# length and slicing\nstring length $name\nstring sub --start 2 --length 4 $word\nstring sub --start -5 $word\n\n# case conversion\nset key (string lower $key)\nset name (string upper $name)\n\n# shell-safe encoding\nset escaped (string escape $path)\nstring unescape $escaped\n\n# normalize piped output\nset text (some_command | string collect)\n\n\n# path command\npath basename foo/bar.txt # bar.txt\npath basename --no-extension foo/bar.txt # bar\npath dirname foo/bar.txt # foo\npath extension ./foo.mp4 # .mp4\npath change-extension mov ./foo.mp4 # ./foo.mov\n\npath normalize path/to//hello.txt # path/to/hello.txt\npath normalize path/to/../hello.txt # path/hello.txt\n# resolve = normalize + absolute path and follow symlinks\npath resolve foo  # ~/foo\n\npath sort 10-foo 2-bar\n# 2-bar\n# 10-foo\n\n\n# math command\nmath [(-s | --scale) N] [(-b | --base) BASE] [(-m | --scale-mode) MODE] EXPRESSION ...\nmath 10 / 6\nmath $status - 128\nmath \"5 * 2\"\nmath \"sin(pi)\"\nmath max 5,2,3,1\n\n\n# count STRING1 STRING2 ...\n# COMMAND | count\n# count [...] < FILE\ncount $PATH\ncount *.txt\ngit ls-files --others --exclude-standard | count\nprintf '%s\\n' foo bar | count baz # Returns 3 (2 lines from stdin plus 1 argument)\ncount < /etc/hosts # number of entries in hosts file\n\n\n# contains [OPTIONS] KEY [VALUES ...]\nif contains -- -q $argv\n    echo '$argv contains a -q option'\nend\n\n# scripts\nstatus filename # current running script\nstatus basename\nstatus dirname\nstatus function # current function name\nstatus line-number\nstatus stack-trace\n\n```\n",
        "role":"user"
      },{
        "content":"# Semantic Grep matches: 5\n\nThis is automatic context based on my request. These may or may not be relevant.\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-search-specific.fish:105-124\n        set ctrl_f_finder (string replace 'ctrl-space' 'ctrl-f' -- $ctrl_space_reveal)\n        set ctrl_c_cd --bind 'ctrl-c:print(cd)+accept' # print leading cd and then the accepted item's path (across two lines btw... but they both get aggregated into same array variable and so are effectively word split w/o the new line)\n        set all_binds $ctrl_c_cd $ctrl_f_finder $ctrl_space_reveal\n        set picked (printf '%s\\n' $results | fzf --height 50% --border $all_binds)\n        if string match -q --regex '^cd' \"$picked\"\n            # user picked to cd to the dir of the item (using ctrl+c)\n            # strip cd from front... so we have just the path\n            set cd_path (string replace -r '^cd\\s+' '' \"$picked\")\n            cd \"$cd_path\"\n            return\n        end\n        if test -n \"$picked\"\n            open \"$picked\"\n            return\n        end\n        echo NOTHING PICKED...\n    end\n\n    abbr mdcd mdfind_cd_dir\n    function mdfind_cd_dir\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-search-specific.fish:135-154\n        set -l picked (printf '%s\\n' $results | fzf --height 50% --border --query \"$argv\")\n        if test -n \"$picked\"\n            cd \"$picked\"\n            return\n        end\n        echo NOTHING PICKED...\n    end\n\nend\n\n# *** find\n#  sometimes, AFAIK, fd doesn't support a few cases that find/gfind does...\n\nset -l find_cmd find\nif $IS_MACOS\n    # * gfind on macOS\n    set find_cmd gfind\n    abbr find gfind\n    # gfind == GNU find, has -exeuctable arg (among other differences)\n    # make sure to run fish_update_completions after installing for completions\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-search-specific.fish:92-121\n    function md_open\n        # TODO find better format for search... cannot do \"*foo*bar*\" ... seems like asterisk is start/end only\n        # TODO can I use regex MATCHES operator?\n\n        set results (mdfind \"kMDItemFSName == \\\"*$argv*\\\"c\")\n        if test (count $results) -eq 1\n            open \"$results\"\n            return\n        else if test (count $results) -lt 1\n            echo NO mdfind matches...\n            return\n        end\n        set ctrl_space_reveal --bind 'ctrl-space:execute-silent(open -R {})'\n        set ctrl_f_finder (string replace 'ctrl-space' 'ctrl-f' -- $ctrl_space_reveal)\n        set ctrl_c_cd --bind 'ctrl-c:print(cd)+accept' # print leading cd and then the accepted item's path (across two lines btw... but they both get aggregated into same array variable and so are effectively word split w/o the new line)\n        set all_binds $ctrl_c_cd $ctrl_f_finder $ctrl_space_reveal\n        set picked (printf '%s\\n' $results | fzf --height 50% --border $all_binds)\n        if string match -q --regex '^cd' \"$picked\"\n            # user picked to cd to the dir of the item (using ctrl+c)\n            # strip cd from front... so we have just the path\n            set cd_path (string replace -r '^cd\\s+' '' \"$picked\")\n            cd \"$cd_path\"\n            return\n        end\n        if test -n \"$picked\"\n            open \"$picked\"\n            return\n        end\n        echo NOTHING PICKED...\n    end\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-search-specific.fish:90-109\n\n    abbr mdo md_open\n    function md_open\n        # TODO find better format for search... cannot do \"*foo*bar*\" ... seems like asterisk is start/end only\n        # TODO can I use regex MATCHES operator?\n\n        set results (mdfind \"kMDItemFSName == \\\"*$argv*\\\"c\")\n        if test (count $results) -eq 1\n            open \"$results\"\n            return\n        else if test (count $results) -lt 1\n            echo NO mdfind matches...\n            return\n        end\n        set ctrl_space_reveal --bind 'ctrl-space:execute-silent(open -R {})'\n        set ctrl_f_finder (string replace 'ctrl-space' 'ctrl-f' -- $ctrl_space_reveal)\n        set ctrl_c_cd --bind 'ctrl-c:print(cd)+accept' # print leading cd and then the accepted item's path (across two lines btw... but they both get aggregated into same array variable and so are effectively word split w/o the new line)\n        set all_binds $ctrl_c_cd $ctrl_f_finder $ctrl_space_reveal\n        set picked (printf '%s\\n' $results | fzf --height 50% --border $all_binds)\n        if string match -q --regex '^cd' \"$picked\"\n\n\n## ~/repos/github/g0t4/dotfiles/fish/load_last_interactive_only/files-search-specific.fish:180-199\nabbr --command fd --position anywhere -- and --and # expand and, mostly a reminder\nabbr --command fd --position anywhere -- abs --absolute-path\nabbr fdabs 'fd --absolute-path'\nabbr fdls 'fd --list-details' # think => fd + ls -al\nabbr fdfp 'fd --full-path' # default matches on basename only, this matches full path\nabbr --set-cursor _fdX --regex 'fd\\d+' --function _abbr_expand_fdX\nfunction _abbr_expand_fdX\n    string replace --regex 'fd(\\d+)' 'fd --max-depth=\\1' $argv\nend\n\n# *** by modification time\nabbr --set-cursor fd_changed_within 'fd --changed-within \"%\"'\nabbr --set-cursor fd_changed_within_hours 'fd --changed-within \"% h\"'\nabbr --set-cursor fd_changed_within_days 'fd --changed-within \"% d\"'\nabbr --set-cursor fd_changed_within_weeks 'fd --changed-within \"% weeks\"'\nabbr --set-cursor fd_changed_within_months 'fd --changed-within \"% months\"'\nabbr --set-cursor fd_changed_within_years 'fd --changed-within \"% years\"'\nabbr --set-cursor fd_changed_before 'fd --changed-before \"%\"'\n# PRN do more with fd_changed_before if I use it\n\n\n",
        "role":"user"
      },{
        "content":"can you read the command line and if the cursor is currently on a word (i.e. user typed cd foo<alt-shift-d> to pick a nested foo dir) then use that word as the initial query to fzf so they can keep whatever they already typed\n\nHere is the code I selected:\n```fish/load_last_interactive_only/files-specific.fish:826-842\n\nfunction __fzf_widget --argument-names picker fd_command\n    set -l file (\n        begin\n            set -l mru_file (__fzf_mru_file $picker)\n            __fzf_mru_read $picker\n            eval $fd_command | grep -Fxv -f $mru_file\n        end | fzf --height 50% --border --header \"MRU ↑  |  Fresh ↓\"\n    )\n\n    if test -n \"$file\"\n        __fzf_mru_write $picker \"$file\"\n        commandline -i -- (string escape -- \"$file\")\n    end\n\n    commandline -f repaint\nend\n```\n\nThis is not necessarily a complete selection of nearby code, this is just the part I want help with. Preserve indentation!",
        "role":"user"
      }],
    "chat_template_kwargs":{
      "reasoning_effort":"off"
    },
    "model":"",
    "temperature":1
  },
  "last_sse":{
    "id":"chatcmpl-YBmEGUTIU5vQt6E3EUntGJxklivCBw2X",
    "system_fingerprint":"b7785-1c7cf94b2",
    "timings":{
      "prompt_n":3030,
      "prompt_ms":386.579,
      "prompt_per_token_ms":0.12758382838284,
      "predicted_ms":2682.9,
      "predicted_per_token_ms":4.731746031746,
      "predicted_n":567,
      "cache_n":0,
      "predicted_per_second":211.33847702113,
      "prompt_per_second":7837.9839567074
    },
    "created":1770793859,
    "object":"chat.completion.chunk",
    "model":"ggml-org/gpt-oss-120b-GGUF",
    "choices":[{
        "index":0,
        "finish_reason":"stop",
        "delta":[]
      }]
  },
  "response_message":{
    "content":"function __fzf_widget --argument-names picker fd_command\n    # capture the word under the cursor (if any) to use as initial fzf query\n    set -l initial_query (commandline -t)\n\n    # build fzf options, adding --query when we have a word\n    set -l fzf_opts --height 50% --border --header \"MRU ↑  |  Fresh ↓\"\n    if test -n \"$initial_query\"\n        set fzf_opts $fzf_opts --query $initial_query\n    end\n\n    set -l file (\n        begin\n            set -l mru_file (__fzf_mru_file $picker)\n            __fzf_mru_read $picker\n            eval $fd_command | grep -Fxv -f $mru_file\n        end | fzf $fzf_opts\n    )\n\n    if test -n \"$file\"\n        __fzf_mru_write $picker \"$file\"\n        commandline -i -- (string escape -- \"$file\")\n    end\n\n    commandline -f repaint\nend",
    "finish_reason":"stop",
    "reasoning_content":"We need to modify function to use current word under cursor as initial query for fzf. In fish, we can get current token via commandline -t? Actually commandline -ct returns cursor position? There is commandline -c for current token? Let's recall: fish commandline builtin: commandline -t gives token under cursor? Options: -c replace entire command line, -i insert, -r replace, -t token under cursor, -p previous token? I think commandline -t returns the token under the cursor. So we can capture initial query: set -l initial_query (commandline -t) then pass to fzf --query \"$initial_query\". Also need to preserve existing typed prefix, they want to keep whatever typed. The function currently inserts selected file into command line. For query, we add --query $initial_query to fzf command. Also need to handle empty initial_query. Use conditional variable.\n\nImplement: set -l current_word (commandline -t) then in fzf call: ... | fzf --height 50% --border --header ... (if test -n \"$current_word\"; echo --query \"$current_word\"; end). But fish syntax: fzf ... (test -n \"$current_word\"; and echo --query \"$current_word\")? Better: set -a fzf_opts --height 50% --border --header \"MRU ↑  |  Fresh ↓\" ; if test -n \"$current_word\"; set fzf_opts $fzf_opts --query $current_word; end ; then pipe to fzf $fzf_opts.\n\nImplement inside function.\n\nReturn code only.",
    "role":"assistant"
  }
}