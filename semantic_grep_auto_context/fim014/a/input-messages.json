{
  "raw": false,
  "model": "gpt-oss:120b",
  "options": [],
  "temperature": 1,
  "stream": true,
  "top_p": 1,
  "messages": [
    {
      "role": "developer",
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n"
    },
    {
      "role": "user",
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: ask-openai.nvim\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Lua Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Prefer EmmyLua/LuaLS style annotations\n- Always annotate when type inference would be ambiguous, or for public APIs.\n\nExamples:\n---@param names string[]\n---@param checker fun(name: string): boolean\n---@return table<string, integer>\nfunction process_names(names, checker) end\n\n---@class WindowController\n---@field window hs.axuielement\n---@field title? string\n---@field size { w: number, h: number }\nlocal WindowController = {}\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/client/init.lua:79-118\nfunction M.get_filetypes_for_workspace()\n    -- FYI vim filetypes for enabling the LSP client for RAG purposes\n    local ext_to_filetype = {\n        -- extension = filetype\n        bash = \"sh\", -- *\n        clj = \"clojure\",\n        coffee = \"coffeescript\",\n        conf = \"cfg\",\n        cs = \"csharp\",\n        h = \"c\",\n        hh = \"cpp\",\n        hpp = \"cpp\",\n        hs = \"haskell\",\n        htm = \"html\",\n        jade = \"pug\",\n        js = \"javascript\", -- *\n        julia = \"julia\",\n        kt = \"kotlin\",\n        lhs = \"lhaskell\",\n        m = \"objc\", -- others for objc?\n        mm = \"objc\",\n        md = \"markdown\", -- *\n        pl = \"perl\",\n        pm = \"perl\",\n        py = \"python\", -- *\n        rb = \"ruby\",\n        rs = \"rust\",\n        scm = \"scheme\",\n        shtml = \"html\",\n        swift = \"swift\",\n        ts = \"typescript\",\n        tsx = \"typescriptreact\",\n        vimrc = \"vim\",\n        yml = \"yaml\", -- *\n    }\n\n    return vim.iter(M.rag_extensions or {})\n        :map(function(ext) return ext_to_filetype[ext] or ext end)\n        :totable()\nend\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/client/init.lua:75-94\n    log:info(\"RAG is supported for: \" .. vim.inspect(M.rag_extensions))\nend\ncheck_supported_dirs()\n\nfunction M.get_filetypes_for_workspace()\n    -- FYI vim filetypes for enabling the LSP client for RAG purposes\n    local ext_to_filetype = {\n        -- extension = filetype\n        bash = \"sh\", -- *\n        clj = \"clojure\",\n        coffee = \"coffeescript\",\n        conf = \"cfg\",\n        cs = \"csharp\",\n        h = \"c\",\n        hh = \"cpp\",\n        hpp = \"cpp\",\n        hs = \"haskell\",\n        htm = \"html\",\n        jade = \"pug\",\n        js = \"javascript\", -- *\n\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/init.lua:11-113\nfunction M.setup_lsp()\n    -- TMP disable, i.e. when working on lsp itself :)\n    --  HRMm wont be easy to enable/disable this though, will have to restart if LSP wasn't started and rag is toggled?\n    if not api.is_rag_enabled() then\n        log:trace(\"NOT starting LSP (b/c RAG is toggled off)\")\n        return\n    end\n    local rag_client = require(\"ask-openai.rag.client\")\n    if not rag_client.is_rag_supported() then\n        log:error(\"NOT starting LSP for RAG\")\n        return\n    end\n\n    local lspconfig = require(\"lspconfig\")\n    local configs = require(\"lspconfig.configs\")\n\n    -- TODO detect initial failure to start LSP => stop trying... so when embeddings server is down\n    --  FYI see rag_client.is_rag_supported_in_current_file() for ideas\n    --  maybe even set some failure flag from initial setup here (or in a callback)\n\n    if not configs.ask_language_server then\n        configs.ask_language_server = {\n            default_config = {\n                cmd = {\n                    os.getenv(\"HOME\") .. \"/repos/github/g0t4/ask-openai.nvim/.venv/bin/python\",\n                    \"-m\",\n                    \"lsp.server\",\n                },\n                cmd_cwd = os.getenv(\"HOME\") .. \"/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag\",\n                -- filetypes = rag_client.get_filetypes_for_workspace(),\n                -- filetypes = { '*' }, -- not set == all filetypes\n                --\n                -- FYI .git first means repo root is preferred, fallback is CWD\n                -- this maps to root_uri/root_path in server's on_initialize\n                root_dir = require(\"lspconfig.util\").root_pattern(\".git\", \".\"),\n            },\n        }\n    end\n\n    -- vim.lsp.handlers[\"window/showMessage\"] = function(err, result, ctx, config)\n    --     messages.append(\"global handler window/showMessage\")\n    --     messages.append(vim.inspect(result))\n    -- end\n\n    lspconfig.ask_language_server.setup({\n        on_attach = function(client, bufnr)\n            -- messages.append(client.name .. \" is now attached to buffer: \" .. bufnr)\n            -- messages.ensure_open()\n            -- -- messages.append(vim.inspect(client))\n            client.handlers = {\n                [\"fuu/no_dot_rag__do_the_right_thing_wink\"] = function(err, result, ctx, config)\n                    messages.append(\"client handler fuu/no_dot_rag__do_the_right_thing_wink\")\n                    messages.append(vim.inspect(result))\n                    -- ask server to shutdown, so I don't ask for more stuff it cannot do!\n                    -- WHY THE F does this not request SHUTDOWN!?\n                    -- vim.lsp.stop_client(client)\n                    -- vim.lsp.stop_client(client)\n                end,\n\n\n                -- [\"window/showMessage\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/showMessage\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n                -- [\"window/showMessageRequest\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/showMessageRequest\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n                -- [\"window/logMessage\"] = function(err, result, ctx, config)\n                --     messages.append(\"client handler window/logMessage\")\n                --     messages.append(vim.inspect(result))\n                -- end,\n            }\n\n            -- vim.defer_fn(function()\n            --     local req_id0, cancel0 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { {} }, -- MUST have empty arguments in pygls v2... or set values inside arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     -- vim.defer_fn(cancel0, 0) -- works fine to cancel all immediately and it does so VERY fast\n            --     vim.defer_fn(cancel0, 500)\n            --\n            --     local req_id1, cancel1 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     vim.defer_fn(cancel1, 0)\n            --\n            --     local req_id2, cancel2 = vim.lsp.buf_request(0, \"workspace/executeCommand\", {\n            --         command = \"SLEEPY\",\n            --         arguments = { { seconds = 10 } },\n            --     }, function(err, result)\n            --         log:error(\"DONE error: \" .. vim.inspect(err) .. \" res:\" .. vim.inspect(result))\n            --     end)\n            --     vim.defer_fn(cancel2, 0)\n            -- end, 500)\n        end,\n    })\nend\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/client/init.lua:105-116\n        rs = \"rust\",\n        scm = \"scheme\",\n        shtml = \"html\",\n        swift = \"swift\",\n        ts = \"typescript\",\n        tsx = \"typescriptreact\",\n        vimrc = \"vim\",\n        yml = \"yaml\", -- *\n    }\n\n    return vim.iter(M.rag_extensions or {})\n        :map(\n\n## ~/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/rag/init.lua:9-28\n\n\nfunction M.setup_lsp()\n    -- TMP disable, i.e. when working on lsp itself :)\n    --  HRMm wont be easy to enable/disable this though, will have to restart if LSP wasn't started and rag is toggled?\n    if not api.is_rag_enabled() then\n        log:trace(\"NOT starting LSP (b/c RAG is toggled off)\")\n        return\n    end\n    local rag_client = require(\"ask-openai.rag.client\")\n    if not rag_client.is_rag_supported() then\n        log:error(\"NOT starting LSP for RAG\")\n        return\n    end\n\n    local lspconfig = require(\"lspconfig\")\n    local configs = require(\"lspconfig.configs\")\n\n    -- TODO detect initial failure to start LSP => stop trying... so when embeddings server is down\n    --  FYI see rag_client.is_rag_supported_in_current_file() for ideas\n\n"
    },
    {
      "role": "user",
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n                -- match on file extension\n                and tag.file_name:match(\".\" .. file_extension .. \"$\")\n        end)\n        :totable()\nend\n\n---@param parsed_tag_lines ParsedTagLine[]\n---@param file_name_func? (fun(file_name: string):string)\n---@return string\nfunction M.reassemble_tags(parsed_tag_lines, file_name_func)\n    file_name_func = file_name_func or function(file_name)\n        return file_name\n    end\n\n    return super_iter(parsed_tag_lines)\n        :group_by(function(tag)\n            return tag.file_name\n        end)\n        :map(function(key, items)\n            local lines = { file_name_func(key) }\n            for _, tag in ipairs(items) do\n                -- FYI stripping /^ $/ removed 19% of tokens in a test run\n                -- also strip leading spaces... not sure it would be useful anyways (did not analyze savings from that)\n                local stripped_ex_command = tag.ex_command\n                    :gsub(\"/^%s*\", \"\")\n                    :gsub(\"$/\", \"\")\n                table.insert(lines, \"    \" .. stripped_ex_command)\n            end\n            return table.concat(lines, \"\\n\")\n        end)\n        :join(\"\\n\")\nend\n\n---@param file_path string\n---@param file_extension string\n---@return ParsedTagLine[]\nfunction M.get_parsed_tag_lines(file_path, file_extension)\n    return M.parse_tag_lines(files.read_file_lines(file_path), file_extension)\nend\n\n---@param file_path string\n---@param file_extension string\n---@return string tags_reassembled\nfunction M.get_reassembled_text(file_path, file_extension)\n    return M.reassemble_tags(M.get_parsed_tag_lines(file_path, file_extension))\nend\n\n---@return string file_path\nfunction M.find_devtools_tags_file()\n    return os.getenv(\"HOME\") .. \"/repos/github/g0t4/devtools.nvim/tags\"\nend\n\n-- * reassembled entrypoints:\n---@return string\nfunction M.reassembled_tags_for_lua_devtools()\n    return M.get_reassembled_text(\n        M.find_devtools_tags_file(),\n        \"lua\"\n    )\nend\n\n---@return string\nfunction M.reassembled_tags_for_this_workspace(file_extension)\n    local tags = M.find_tags_file_for_this_workspace()\n    return M.get_reassembled_text(tags, file_extension)\nend\n\n-- TODO fix ctags context to use this new all_reassembled_tags method\n---@return string[]\nfunction M.all_reassembled_tags()\n    local file_extension = M.get_language_for_current_buffer()\n    local reassembeds = {\n        -- TODO how about use ctags for luarc libs?\n        --  load on first use? (if exist)\n        -- todo more than one lib prompts!\n        M.reassembled_tags_for_this_workspace(file_extension),\n    }\n    if file_extension == \"lua\" then\n        table.insert(reassembeds, M.reassembled_tags_for_lua_devtools())\n    end\n    return reassembeds\nend\n\n-- * parsed_tag_lines (only) entrypoints:\n---@return ParsedTagLine[]\nfunction M.parsed_tag_lines_for_lua_devtools()\n    return M.parse_tag_lines(files.read_file_lines(M.find_devtools_tags_file()), \"lua\")\nend\n\n---@return ParsedTagLine[]\nfunction M.parsed_tag_lines_for_this_workspace(file_extension)\n    return M.parse_tag_lines(files.read_file_lines(M.find_tags_file_for_this_workspace()), file_extension)\nend\n\nfunction M.get_language_for_current_buffer()\n    -- TODO centralize a single lookup between file ext and filetype\n    -- TODO also support multiple extensions per filetype b/c some languages are not limited to a single ext (i.e. header files in c)\n    local filetype = vim.bo.filetype\n    local ft = vim.bo.filetype\n\n    -- local ext_to_filetype = {\n    --     -- extension = filetype\n    --     bash = \"sh\", -- *\n    --     clj = \"clojure\",\n    --     coffee = \"coffeescript\",\n    --     conf = \"cfg\",\n    --     cs = \"csharp\",\n    --     h = \"c\",\n    --     hh = \"cpp\",\n    --     hpp = \"cpp\",\n    --     hs = \"haskell\",\n    --     htm = \"html\",\n    --     jade = \"pug\",\n    --     js = \"javascript\", -- *\n    --     julia = \"julia\",\n    --     kt = \"kotlin\",\n    --     lhs = \"lhaskell\",\n    --     m = \"objc\", -- others for objc?\n    --     mm = \"objc\",\n    --     pl = \"perl\",\n    --     pm = \"perl\",\n    --     rb = \"ruby\",\n    --     rs = \"rust\",\n    --     scm = \"scheme\",\n    --     shtml = \"html\",\n    --     swift = \"swift\",\n    --     ts = \"typescript\",\n    --     tsx = \"typescriptreact\",\n    --     vimrc = \"vim\",\n    --     yml = \"yaml\", -- *\n    -- }\n    --\n\n    -- FYI vim filetypes for enabling the LSP client for RAG purposes\n    local filetype_to_extension = {\n        python = \"py\",\n        csharp = \"cs\",\n        markdown = \"md\",\n        <|fim_middle|>\n    }\n\n    local file_ext = filetype_to_extension[ft] or ft\n    return file_ext\nend\n\nfunction M.dump_this()\n    -- get current file's type\n    local file_extension = M.get_language_for_current_buffer()\n\n    messages.header(\"Parsed lines for `\" .. file_extension .. \"`\")\n    messages.ensure_open()\n    messages.append(M.reassembled_tags_for_this_workspace(file_extension))\n    messages.scroll_back_before_last_append()\nend\n\nfunction M.setup()\n    vim.api.nvim_create_user_command(\"AskDumpCTags\", M.dump_this, {})\nend\n\nreturn M"
    }
  ],
  "max_tokens": 4096,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  }
}
