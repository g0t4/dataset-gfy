{
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: ask-openai.nvim\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n## Recent yanks across all files in the project:\n.. yanked from lua/ask-openai/predictions/prefix_suffix.lua:\ncursor_row_text_cursor_plus\n\n\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Lua Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Prefer EmmyLua/LuaLS style annotations\n- Always annotate when type inference would be ambiguous, or for public APIs.\n\nExamples:\n---@param names string[]\n---@param checker fun(name: string): boolean\n---@return table<string, integer>\nfunction process_names(names, checker) end\n\n---@class WindowController\n---@field window hs.axuielement\n---@field title? string\n---@field size { w: number, h: number }\nlocal WindowController = {}\n\n\n# Semantic Grep matches: 5\n\n## /Users/wesdemos/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix.lua:53-112\n---@param take_num_lines_each_way? integer\n---@return PrefixSuffixChunk ps_chunk\nfunction PrefixSuffixChunk.get_prefix_suffix_chunk(take_num_lines_each_way)\n    take_num_lines_each_way = take_num_lines_each_way or 80\n    -- presently, this only works with current buffer/window:\n    local current_win_id = 0\n    local current_bufnr = 0\n\n    local cursor_line_base1, cursor_col_base0 = unpack(vim.api.nvim_win_get_cursor(current_win_id)) -- (1,0)-indexed\n    local cursor_line_base0 = cursor_line_base1 - 1\n\n\n    -- * READ LINES AROUND CURSOR LINE\n    local line_count = vim.api.nvim_buf_line_count(current_bufnr)\n    local take_start_row_base0, take_end_row_base0 = PrefixSuffixChunk.determine_line_range_base0(cursor_line_base0, take_num_lines_each_way, line_count)\n\n    local cursor_row_text = vim.api.nvim_buf_get_lines(current_bufnr,\n        -- 0indexed, END-EXCLUSIVE\n        cursor_line_base0,\n        cursor_line_base0 + 1, -- end is exclusive, thus + 1\n        IGNORE_BOUNDARIES\n    )[1]\n\n\n    -- * PREFIX\n    -- FYI prefix stops with column before cursor column\n    local col_before_cursor_base1 = cursor_col_base0\n    local cursor_row_text_before_cursor = cursor_row_text:sub(1, col_before_cursor_base1) -- 1-indexed, END-INCLUSIVE (\"foobar\"):sub(2,3) == \"ob\"\n\n    local lines_before_cursor_line = vim.api.nvim_buf_get_lines(current_bufnr, take_start_row_base0, cursor_line_base0, IGNORE_BOUNDARIES) -- 0indexed, END-EXCLUSIVE\n\n    local prefix_text = table.concat(lines_before_cursor_line, \"\\n\") .. \"\\n\" .. cursor_row_text_before_cursor\n    local few_lines_before = vim.list_slice(lines_before_cursor_line, #lines_before_cursor_line - 4)\n\n    -- * SUFFIX\n    -- FYI char under the cursor is in the suffix\n    local cursor_col_base1 = cursor_col_base0 + 1\n    local cursor_row_text_cursor_plus = cursor_row_text:sub(cursor_col_base1) -- 1-indexed, END-INCLUSIVE\n\n    -- TODO edge cases for new line at end of current line? is that a concern\n    local lines_after_cursor_line = vim.api.nvim_buf_get_lines(current_bufnr,\n        -- 0indexed END-EXCLUSIVE\n        cursor_line_base0 + 1, -- start w/ line after cursor line\n        take_end_row_base0 + 1, -- end is exclusive, thus + 1\n        IGNORE_BOUNDARIES\n    )\n\n    local suffix_text = cursor_row_text_cursor_plus\n        .. \"\\n\" -- TODO! doesn't cursor row have a newline already? why am I adding that here?\n        .. table.concat(lines_after_cursor_line, \"\\n\")\n\n    local ps_chunk = PrefixSuffixChunk:new()\n    ps_chunk.prefix = prefix_text\n    ps_chunk.suffix = suffix_text\n    ps_chunk.start_line_base1 = take_start_row_base0 + 1\n    ps_chunk.end_line_base1 = take_end_row_base0 + 1\n    ps_chunk.rag_cursor_line_before_cursor = cursor_row_text_before_cursor\n    ps_chunk.few_lines_before = few_lines_before\n    return ps_chunk\nend\n\n## /Users/wesdemos/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix.lua:19-51\n--- Determine range of lines to take before/after cursor position.\n--- Try taking X lines in both directions.\n--- If one direction doesn't have X lines, try taking the difference from the other side.\nfunction PrefixSuffixChunk.determine_line_range_base0(current_row_b0, take_num_lines_each_way, buffer_line_count)\n    -- separate logic for finding range of lines to use as prefix/suffix\n    -- - the math here can be off by a smidge and won't matter b/c separate code reads the lines\n    -- - assuming cursor line stays in range, you're good to go\n\n    -- FYI I am experimenting here with _b0 for base 0... leave this style for comparison until you feel super compelled to make everything the same\n\n    local take_start_row_b0 = current_row_b0 - take_num_lines_each_way\n    local take_end_row_b0 = current_row_b0 + take_num_lines_each_way\n    if take_start_row_b0 < 0 then\n        -- start row cannot be before first line!\n        local unused_prefix_rows = -take_start_row_b0\n        take_start_row_b0 = 0\n\n        -- unused lines in prefix are added to possible suffix\n        take_end_row_b0 = take_end_row_b0 + unused_prefix_rows\n    end\n\n    local last_row_num_b0 = buffer_line_count - 1\n    if take_end_row_b0 > last_row_num_b0 then\n        -- end row cannot be after last line!\n        local unused_suffix_rows = take_end_row_b0 - buffer_line_count\n        take_end_row_b0 = last_row_num_b0\n\n        -- unused lines in suffix are added to possible prefix\n        take_start_row_b0 = take_start_row_b0 - unused_suffix_rows\n        take_start_row_b0 = math.max(0, take_start_row_b0)\n    end\n    return take_start_row_b0, take_end_row_b0\nend\n\n## /Users/wesdemos/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix.lua:92-111\n    -- TODO edge cases for new line at end of current line? is that a concern\n    local lines_after_cursor_line = vim.api.nvim_buf_get_lines(current_bufnr,\n        -- 0indexed END-EXCLUSIVE\n        cursor_line_base0 + 1, -- start w/ line after cursor line\n        take_end_row_base0 + 1, -- end is exclusive, thus + 1\n        IGNORE_BOUNDARIES\n    )\n\n    local suffix_text = cursor_row_text_cursor_plus\n        .. \"\\n\" -- TODO! doesn't cursor row have a newline already? why am I adding that here?\n        .. table.concat(lines_after_cursor_line, \"\\n\")\n\n    local ps_chunk = PrefixSuffixChunk:new()\n    ps_chunk.prefix = prefix_text\n    ps_chunk.suffix = suffix_text\n    ps_chunk.start_line_base1 = take_start_row_base0 + 1\n    ps_chunk.end_line_base1 = take_end_row_base0 + 1\n    ps_chunk.rag_cursor_line_before_cursor = cursor_row_text_before_cursor\n    ps_chunk.few_lines_before = few_lines_before\n    return ps_chunk\n\n\n## /Users/wesdemos/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix.lua:17-36\n\n\n--- Determine range of lines to take before/after cursor position.\n--- Try taking X lines in both directions.\n--- If one direction doesn't have X lines, try taking the difference from the other side.\nfunction PrefixSuffixChunk.determine_line_range_base0(current_row_b0, take_num_lines_each_way, buffer_line_count)\n    -- separate logic for finding range of lines to use as prefix/suffix\n    -- - the math here can be off by a smidge and won't matter b/c separate code reads the lines\n    -- - assuming cursor line stays in range, you're good to go\n\n    -- FYI I am experimenting here with _b0 for base 0... leave this style for comparison until you feel super compelled to make everything the same\n\n    local take_start_row_b0 = current_row_b0 - take_num_lines_each_way\n    local take_end_row_b0 = current_row_b0 + take_num_lines_each_way\n    if take_start_row_b0 < 0 then\n        -- start row cannot be before first line!\n        local unused_prefix_rows = -take_start_row_b0\n        take_start_row_b0 = 0\n\n        -- unused lines in prefix are added to possible suffix\n\n\n## /Users/wesdemos/repos/github/g0t4/ask-openai.nvim/lua/ask-openai/predictions/prefix_suffix.lua:77-96\n    -- * PREFIX\n    -- FYI prefix stops with column before cursor column\n    local col_before_cursor_base1 = cursor_col_base0\n    local cursor_row_text_before_cursor = cursor_row_text:sub(1, col_before_cursor_base1) -- 1-indexed, END-INCLUSIVE (\"foobar\"):sub(2,3) == \"ob\"\n\n    local lines_before_cursor_line = vim.api.nvim_buf_get_lines(current_bufnr, take_start_row_base0, cursor_line_base0, IGNORE_BOUNDARIES) -- 0indexed, END-EXCLUSIVE\n\n    local prefix_text = table.concat(lines_before_cursor_line, \"\\n\") .. \"\\n\" .. cursor_row_text_before_cursor\n    local few_lines_before = vim.list_slice(lines_before_cursor_line, #lines_before_cursor_line - 4)\n\n    -- * SUFFIX\n    -- FYI char under the cursor is in the suffix\n    local cursor_col_base1 = cursor_col_base0 + 1\n    local cursor_row_text_cursor_plus = cursor_row_text:sub(cursor_col_base1) -- 1-indexed, END-INCLUSIVE\n\n    -- TODO edge cases for new line at end of current line? is that a concern\n    local lines_after_cursor_line = vim.api.nvim_buf_get_lines(current_bufnr,\n        -- 0indexed END-EXCLUSIVE\n        cursor_line_base0 + 1, -- start w/ line after cursor line\n        take_end_row_base0 + 1, -- end is exclusive, thus + 1\n\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n-- testing modules:\nrequire(\"ask-openai.helpers.test_setup\").modify_package_path()\nlocal assert = require 'luassert'\nlocal buffers = require('devtools.tests.buffers')\n-- system under test:\nlocal ps = require(\"ask-openai.predictions.prefix_suffix\")\n\ndescribe(\"get_prefix_suffix\", function()\n    local function create_lines(num_lines)\n        local lines = {}\n        for i = 1, num_lines do\n            lines[i] = \"line \" .. i\n        end\n        return lines\n    end\n\n    local seven_lines = {\n        \"line 1\", \"line 2\", \"line 3\", \"line 4\", \"line 5\",\n        \"line 6\", \"line 7\"\n    }\n\n    it(\"in middle of buffer, returns prefix and suffix\", function()\n        local bufnr = buffers.new_buffer_with_lines(seven_lines)\n        local line_base1 = 4 -- 4th line\n        local col_base0 = 0 -- cursor in first col\n        vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n        local ps_chunk = ps.get_prefix_suffix_chunk()\n\n        assert.are_same({\n            prefix = \"line 1\\nline 2\\nline 3\\n\",\n            suffix = \"line 4\\nline 5\\nline 6\\nline 7\",\n            -- FYI rag_cursor_line_before_cursor is WIP so just nuke this assertion if causing issues (these tests were not designed with this in mind, I just added it to make tests pass again)\n            rag_cursor_line_before_cursor = \"\", -- no text before cursor, since col_base0 = 0\n            few_lines_before = {\n                <|fim_middle|>\n\n            },\n            start_line_base1 = 1,\n            end_line_base1 = 7,\n        }, ps_chunk)\n    end)\n\n    it(\"cursor is at start of buffer, first line, first col\", function()\n        local bufnr = buffers.new_buffer_with_lines(seven_lines)\n        local line_base1 = 1\n        local col_base0 = 0\n        vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n        local take_lines = 2\n        local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n        -- assert.equal(\"\", prefix) -- TODO FIX FOR new line not expected!\n        assert.equal(\"line 1\\nline 2\\nline 3\\nline 4\\nline 5\", suffix)\n    end)\n\n    it(\"cursor is at end of buffer, last line, last col\", function()\n        local bufnr = buffers.new_buffer_with_lines(seven_lines)\n        local line_base1 = 7\n        local col_base0 = 5\n        vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n        local take_lines = 2\n        local ps_chunk = ps.get_prefix_suffix_chunk(2)\n\n        -- to make this consistent I probably should make line range take 3 to 7 here\n        --  like with start of doc, which takes 1 to 5\n        --   right now this takes 4 lines only when it s/b 2 on either side of cursor line\n        --   thus in this case all 4 before cursor line so 3 to 7 (5 lines)\n        assert.same({\n            prefix = \"line 4\\nline 5\\nline 6\\nline \",\n            suffix = \"7\\n\",\n            -- FYI rag_cursor_line_before_cursor can be nuked (see above):\n            rag_cursor_line_before_cursor = \"line \", -- cursor is on the last char of the line, so that would be the number in this case\n            start_line_base1 = 4,\n            end_line_base1 = 7,\n        }, ps_chunk)\n    end)\n\n    describe(\"plenty of lines both ways\", function()\n        describe(\"cursor line is not empty\", function()\n            it(\"cursor is at start of line\", function()\n                local bufnr = buffers.new_buffer_with_lines(seven_lines)\n                local line_base1 = 4 -- 'line 4'\n                local col_base0 = 0 -- 'l' in 'line'\n                vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n                local take_lines = 2 -- mostly focus on cursor line\n                local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n                assert.equal(\"line 2\\nline 3\\n\", prefix)\n                assert.equal(\"line 4\\nline 5\\nline 6\", suffix)\n            end)\n\n            it(\"cursor is in middle of line\", function()\n                local bufnr = buffers.new_buffer_with_lines(seven_lines)\n                local line_base1 = 4 -- 'line 4'\n                local col_base0 = 3 -- 3 is the 'e' in 'line'\n                vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n                local take_lines = 2\n                local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n                assert.equal(\"line 2\\nline 3\\nlin\", prefix)\n                assert.equal(\"e 4\\nline 5\\nline 6\", suffix)\n            end)\n\n            it(\"cursor is on last char of line (means before the last char)\", function()\n                local bufnr = buffers.new_buffer_with_lines(seven_lines)\n                local line_base1 = 4 -- 'line 4'\n                local col_base0 = 5 -- 5 ==> '4'\n                vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n                local take_lines = 2\n                local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n                assert.equal(\"line 2\\nline 3\\nline \", prefix)\n                assert.equal(\"4\\nline 5\\nline 6\", suffix)\n            end)\n\n            it(\"in INSERT mode, after typing 'A' to append, cursor is past the last character ('4') and now prefix will have last char ('4')\", function()\n                -- FYI docs on coroutines and plenary tests:\n                --   https://github.com/nvim-lua/plenary.nvim/blob/master/TESTS_README.md#asynchronous-testing\n\n                local bufnr = buffers.new_buffer_with_lines(seven_lines)\n                -- move to 4th line, and go into insert mode at end of line\n                -- that way the cursor will be PAST the last '4' char and so it will end up in prefix (assuming the splitter code works)\n                vim.api.nvim_command(\":4\")\n                vim.api.nvim_feedkeys(\"A\", \"n\", false)\n\n                -- wait for insert mode... a clock tick\n                local co = coroutine.running()\n                vim.schedule(function()\n                    local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)\n                    -- vim.print(lines)\n                    local mode = vim.api.nvim_get_mode().mode\n                    assert.equal(\"i\", mode) -- ensure in insert mode\n                    local cusror = vim.api.nvim_win_get_cursor(0)\n\n                    local take_lines = 2\n                    local prefix, suffix = ps.get_prefix_suffix(take_lines)\n\n                    assert.equal(\"line 2\\nline 3\\nline 4\", prefix)\n                    assert.equal(\"\\nline 5\\nline 6\", suffix)\n\n                    coroutine.resume(co) -- test is done now\n                end)\n\n                coroutine.yield()\n            end)\n        end)\n\n        describe(\"cursor line is empty\", function()\n            it(\"cursor is at start of the empty line\", function()\n                local bufnr = buffers.new_buffer_with_lines({ \"one\", \"two\", \"\", \"four\", \"five\" })\n                local line_base1 = 3\n                local col_base0 = 0\n                vim.api.nvim_win_set_cursor(0, { line_base1, col_base0 })\n\n                local take_lines = 2\n                local prefix, suffix = ps.get_prefix_suffix(take_lines)",
      "role": "user"
    }
  ],
  "options": [],
  "temperature": 1,
  "stream": true,
  "raw": false,
  "model": "gpt-oss:120b",
  "top_p": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "max_tokens": 4096
}
