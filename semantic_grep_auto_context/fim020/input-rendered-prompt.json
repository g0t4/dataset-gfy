{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "delta": {}
    }
  ],
  "created": 1767074570,
  "id": "chatcmpl-JBeFh9Xy79IgCaLncCrgvT0pg3G7F2Fz",
  "model": "ggml-org/gpt-oss-120b-GGUF",
  "system_fingerprint": "b7453-8faa87db0",
  "object": "chat.completion.chunk",
  "timings": {
    "cache_n": 771,
    "prompt_n": 2782,
    "prompt_ms": 430.401,
    "prompt_per_token_ms": 0.15470920201294033,
    "prompt_per_second": 6463.739628857739,
    "predicted_n": 299,
    "predicted_ms": 1422.709,
    "predicted_per_token_ms": 4.758224080267559,
    "predicted_per_second": 210.1624436198829
  },
  "__verbose": {
    "index": 0,
    "content": "",
    "tokens": [],
    "id_slot": 0,
    "stop": true,
    "model": "ggml-org/gpt-oss-120b-GGUF",
    "tokens_predicted": 299,
    "tokens_evaluated": 3553,
    "generation_settings": {
      "seed": 4294967295,
      "temperature": 1.0,
      "dynatemp_range": 0.0,
      "dynatemp_exponent": 1.0,
      "top_k": 40,
      "top_p": 1.0,
      "min_p": 0.05000000074505806,
      "top_n_sigma": -1.0,
      "xtc_probability": 0.0,
      "xtc_threshold": 0.10000000149011612,
      "typical_p": 1.0,
      "repeat_last_n": 64,
      "repeat_penalty": 1.0,
      "presence_penalty": 0.0,
      "frequency_penalty": 0.0,
      "dry_multiplier": 0.0,
      "dry_base": 1.75,
      "dry_allowed_length": 2,
      "dry_penalty_last_n": 131072,
      "dry_sequence_breakers": [
        "\n",
        ":",
        "\"",
        "*"
      ],
      "mirostat": 0,
      "mirostat_tau": 5.0,
      "mirostat_eta": 0.10000000149011612,
      "stop": [],
      "max_tokens": 4096,
      "n_predict": 4096,
      "n_keep": 0,
      "n_discard": 0,
      "ignore_eos": false,
      "stream": true,
      "logit_bias": [],
      "n_probs": 0,
      "min_keep": 0,
      "grammar": "",
      "grammar_lazy": false,
      "grammar_triggers": [],
      "preserved_tokens": [
        200003,
        200005,
        200006,
        200007,
        200008
      ],
      "chat_format": "GPT-OSS",
      "reasoning_format": "deepseek",
      "reasoning_in_content": false,
      "thinking_forced_open": false,
      "samplers": [
        "penalties",
        "dry",
        "top_n_sigma",
        "top_k",
        "typ_p",
        "top_p",
        "min_p",
        "xtc",
        "temperature"
      ],
      "speculative.n_max": 16,
      "speculative.n_min": 0,
      "speculative.p_min": 0.75,
      "timings_per_token": false,
      "post_sampling_probs": false,
      "lora": []
    },
    "prompt": "<|start|>system<|message|>You are ChatGPT, a large language model trained by OpenAI.\nKnowledge cutoff: 2024-06\nCurrent date: 2025-12-30\n\nReasoning: low\n\n# Valid channels: analysis, commentary, final. Channel must be included for every message.<|end|><|start|>developer<|message|># Instructions\n\nYou are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n\n\n<|end|><|start|>user<|message|>Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\n## General project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n\n## General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n\n## Python Code Preferences\n\nNaming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\nType Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        if event.key == \"left\":\n            key_left(event)\n        elif event.key == \"right\":\n            key_right(event)\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nkey_ctrl_left\n\n.. yanked from auto_edit/new_silence/detects/segments.py:\n    def end_seconds(self) -> float:\n        return self.segments[-1].end_seconds\n\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n        xlim = plotter.ax.get_xlim()\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\n    def center_on_gap_of(win: GapWindow):\n\n.. yanked from auto_edit/new_silence/player/segment_plotter.py:\n        cur_xlim = self.ax.get_xlim()\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\ncenter_on_gap_of\n\n.. yanked from auto_edit/new_silence/player/segment_plotter.py:\nshift_center_to_gap\n\n.. yanked from auto_edit/new_silence/player/plot_helpers.py:\nshift_center_to_gap\n\n\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:158-177\n\n\n    def _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:160-206\ndef _on_click(self, event) -> None:\n        if event.inaxes != self.ax:\n            return\n\n        clicked_at_seconds = event.xdata\n        if is_ctrl(event):\n            # scroll to segment\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            self.zoom_to_gap(window)\n        elif is_shift(event):\n            # * play GapWindow (under cursor)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            rich.inspect(event)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n            # save mp4 clip\n            clip_path = clip_full_window(\n                explain,\n                self.analysis,\n                window,\n            )\n            if clip_path:\n                print(f\"Saved clip to {clip_path}\")\n\n        else:\n            # * play a single segment (under cursor)\n            for seg in self.segments:\n                if seg.start_seconds <= clicked_at_seconds <= seg.end_seconds:\n                    self._play_segment(seg.start_seconds, seg.end_seconds)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:173-192\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n\n            if window.gap.start_seconds() <= clicked_at_seconds <= window.gap.end_seconds():\n                # play gap (silence)\n                self._play_segment(window.gap.start_seconds(), window.gap.end_seconds())\n            else:\n                # play full window\n                self._play_segment(window.start_seconds(), window.end_seconds())\n\n        elif is_alt(event):\n            rich.inspect(event)\n            window = self.analysis.window_at_seconds(clicked_at_seconds)\n            if not window:\n                return\n            explain = applescript_prompt(f\"Enter description for the selected silence/gap at {clicked_at_seconds:.2f}s\")\n            if explain is None:\n                print(\"no explanation, canceling\")\n                return\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detects/segments.py:257-260\ndef window_at_seconds(self, seconds: float) -> GapWindow | None:\n        for window in self.windows:\n            if window.start_seconds() <= seconds <= window.end_seconds():\n                return window\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/player/segment_plotter.py:281-289\ndef zoom_to_gap(self, window: GapWindow) -> None:\n        if window is None:\n            return\n        # fixed zoom level with gap centered (not full window, just the gap of silence)...\n        middle = (window.gap.start_seconds() + window.gap.end_seconds()) / 2\n        width_seconds = 2  # fixed width in seconds\n        self.ax.set_xlim(middle - width_seconds / 2, middle + width_seconds / 2)\n        self.toggle_zoom_level_elements()\n        self.fig.canvas.draw_idle()\n<|end|><|start|>user<|message|>Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n            #   NOT: f, g, l\n            toggle_gridlines(event)\n        elif event.key == \"y\":\n            # copy start/end of the gap under the cursor to clipboard\n            copy_gap_timing_for_notes(event)\n        elif event.key == \"h\":\n            plotter.toggle_crosshair()\n        elif event.key in (\"+\", \"=\", \"-\", \"_\"):\n            zoom_x_only(event)\n        # paging left/right (full page width)\n        elif event.key in (\"ctrl+u\", \"ctrl+d\", \"ctrl+b\", \"ctrl+f\", \"pageup\", \"pagedown\"):\n            # vim style: ctrl+b/f = left/right full page, ctrl+u/d = half page, pageup/pagedown = full page left/right\n            if event.key in (\"ctrl+b\", \"pageup\"):\n                page_left(event)\n            elif event.key in (\"ctrl+f\", \"pagedown\"):\n                page_right(event)\n            elif event.key == \"ctrl+u\":\n                half_page_left(event)\n            elif event.key == \"ctrl+d\":\n                half_page_right(event)\n\n    def go_to_start(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start_time = plotter.segments[0].start_seconds\n        plotter.ax.set_xlim(start_time, width)\n        plotter.fig.canvas.draw_idle()\n\n    def go_to_end(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        end_time = plotter.segments[-1].end_seconds\n        plotter.ax.set_xlim(end_time - width, end_time)\n        plotter.fig.canvas.draw_idle()\n\n    def toggle_gridlines(event: KeyEvent):\n        # FYI gridlines are initially OFF...\n        # toggle them ON when I need to see nearest frame (minor ticks)\n        # btw gridlines are associated with ticks, thus need to check tick params\n        #   every other API above axis.get/set_tick_params is just a wrapper around this lower level set_tick_params function\n\n        # * check if on/off... PITA with separate values per major/minor, so I will assume it is off and turnit on first time using visible_grid\n        # x_minor_grid_on = ax.xaxis.get_tick_params(which=\"minor\")[\"gridOn\"]\n        # x_major_grid_on = ax.xaxis.get_tick_params(which=\"major\")[\"gridOn\"]\n        # print(f'{x_major_grid_on=} {x_minor_grid_on=}')\n\n        # * set style first\n        plotter.ax.xaxis.grid(which='minor', linewidth=1)\n        plotter.ax.xaxis.grid(which='major', linewidth=1, color='black')\n        # arguably, I could set this once w/ ax.tick_params (or otherwise)\n        #   but, I want to keep all of this self-contained in this function\n        # kwargs: linewidth, linestyle, color, alpha (see ax.tick_params docs)\n        #   FYI grid(linewidth=X) == set_tick_params(grid_linewidth=X)\n        #   the same kwarg is named different based on function ðŸ¤¦â€â™‚ï¸\n        #\n        # * set on/off\n        global visible_grid\n        visible_grid = not visible_grid\n        plotter.ax.xaxis.grid(visible=visible_grid, which='both')  # then, set visibility\n        # FTR which='both' == both 'major' and 'minor'\n        # !!! DO NOT PASS both visible and kwargs\n        # !!! ... unless you like SURPRISE, RAWDOG, BUTT SECKS in your penis hole\n        #   so, NOT THIS:\n        #     ax.xaxis.grid(visible_grid, which='both', linewidth=2)\n        # passing any `kwargs` => sets `visible=True` (always)\n        #   just F12 into .grid() and you'll see!\n        #   kwargs are where you pass characteristics like linewidth\n        # btw... `which` is a positional arg so you can pass it (and should)\n\n        plotter.fig.canvas.draw_idle()\n\n    def _get_current_gap_in_middle_of_screen(plotter) -> int | None:\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        for win in plotter.windows:\n            if win.gap.start_seconds() <= center <= win.gap.end_seconds():\n                return win\n        return None\n\n    def key_ctrl_left(event):\n        <|fim_middle|>\n\n    def key_ctrl_right(event):\n        xlim = plotter.ax.get_xlim()\n        center = (xlim[0] + xlim[1]) / 2\n        gaps_after_center = (win for win in plotter.windows if win.gap.start_seconds() > center)\n        next_window = next(gaps_after_center, None)\n        plotter.shift_center_to_gap(next_window)\n\n    def key_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        shift = (cur_xlim[1] - cur_xlim[0]) * 0.1\n        plotter.ax.set_xlim(cur_xlim[0] - shift, cur_xlim[1] - shift)\n        plotter.fig.canvas.draw_idle()\n\n    def key_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        shift = (cur_xlim[1] - cur_xlim[0]) * 0.1\n        plotter.ax.set_xlim(cur_xlim[0] + shift, cur_xlim[1] + shift)\n        plotter.fig.canvas.draw_idle()\n\n    def clamp_xlim(new_start: float, new_end: float) -> tuple[float, float]:\n        \"\"\"Clamp the new x limits to the data bounds.\n        Returns a tuple (start, end) respecting the overall segment range.\n        \"\"\"\n        data_start = plotter.segments[0].start_seconds\n        data_end = plotter.segments[-1].end_seconds\n        # ensure we don't exceed bounds\n        if new_start < data_start:\n            new_start = data_start\n            new_end = data_start + (new_end - new_start)\n        if new_end > data_end:\n            new_end = data_end\n            new_start = data_end - (new_end - new_start)\n        return new_start, new_end\n\n    def page_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start, end = clamp_xlim(cur_xlim[0] - width, cur_xlim[1] - width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def page_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = cur_xlim[1] - cur_xlim[0]\n        start, end = clamp_xlim(cur_xlim[0] + width, cur_xlim[1] + width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def half_page_left(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = (cur_xlim[1] - cur_xlim[0]) / 2\n        start, end = clamp_xlim(cur_xlim[0] - width, cur_xlim[1] - width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def half_page_right(event: KeyEvent):\n        cur_xlim = plotter.ax.get_xlim()\n        width = (cur_xlim[1] - cur_xlim[0]) / 2\n        start, end = clamp_xlim(cur_xlim[0] + width, cur_xlim[1] + width)\n        plotter.ax.set_xlim(start, end)\n        plotter.fig.canvas.draw_idle()\n\n    def on_scroll(event: MouseEvent):\n        if event.inaxes != plotter.ax:\n            return\n        base_scale = 0.9\n        cur_xlim = plotter.ax.get_xlim()\n        xdata = event.xdata\n        if event.button == 'up':\n            scale_factor = base_scale\n        elif event.button == 'down':\n            scale_factor = 1 / base_scale\n        else:\n            scale_factor = 1\n        new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor\n        relx = (xdata - cur_xlim[0]) / (cur_xlim[1] - cur_xlim[0])\n        plotter.ax.set_xlim(xdata - new_width * relx, xdata + new_width * (1 - relx))\n        plotter.toggle_zoom_level_elements()\n        plotter.fig.canvas.draw_idle()<|end|><|start|>assistant",
    "has_new_line": true,
    "truncated": false,
    "stop_type": "eos",
    "stopping_word": "",
    "tokens_cached": 3851,
    "timings": {
      "cache_n": 771,
      "prompt_n": 2782,
      "prompt_ms": 430.401,
      "prompt_per_token_ms": 0.15470920201294033,
      "prompt_per_second": 6463.739628857739,
      "predicted_n": 299,
      "predicted_ms": 1422.709,
      "predicted_per_token_ms": 4.758224080267559,
      "predicted_per_second": 210.1624436198829
    }
  }
}
