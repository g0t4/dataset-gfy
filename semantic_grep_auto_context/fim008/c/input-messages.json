{
  "model": "gpt-oss:120b",
  "top_p": 1,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "temperature": 1,
  "max_tokens": 4096,
  "options": [],
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n## Recent yanks across all files in the project:\n.. yanked from auto_edit/new_silence/gaps_tests.py:\n                .flat(40).plot(),\n\n\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:223-258\ndef test_first_min_not_on_a_frame__uses_frame_aligned_value(self):\n        # no bounce up for breathing/typing/etc\n        # FYI must be 2 digits w/ 30FPS to get partials\n        win1 = GapWindow(\n            left_speech=speech_seg(0.0, 1.0),\n            # NOTE not using start/end of segments\n            gap=NonSpeechGap(segments=[silence_seg(1.0, 2.0)]),\n            right_speech=None,  # ignored side\n        )\n        win1.first_min_seconds_frame_aligned = 1.2  # or 1.23333333\n        win1.first_min_seconds = 1.22\n        # 0.22@30FPS is between frame numbers: 6 and 7\n        # 6/30 = 0.2\n        # 7/30 = 0.2333\n\n        wins = [win1]\n        ranges = get_ranges(wins, VIDEO_FPS)\n\n        #  TODO! this test is effectively moving to gaps_tests.py on the actual gap analysis there will be frame_before_first_min/frame_after_first_min (same for last_min)\n        #     TODO LEAVE THIS AS A REMINDER TO PATCH the new frame boundaries into the tests above (and/or here)\n        #      I probably don't need examples here that are not on a frame boundary? as long as I have accurate code above to set w/e aligned value is seledcted\n        #      TODO ABOVE tests need calculated frame_before/after_first/last_min added and used\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 36  # or 37\n        # 37 vs 38? (round left/right?)\n        # - my inclination is\n        #   if it truly is NOT breathing\n        #     then I might not even mute the middle segment!\n        #     so it is ok to round right into the silence region\n        #     rounding left is still iffy depending on how fast the taper is from left_speech\n        #     round out/in? (left/right)\n        assert type(ranges[0]) == SilenceRange\n\n        assert ranges[1].start_frame == 36  # or 37\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == ContentRange\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:219-238\n        assert type(ranges[4]) == SilenceRange\n\nclass TestFrameRounding:\n\n    def test_first_min_not_on_a_frame__uses_frame_aligned_value(self):\n        # no bounce up for breathing/typing/etc\n        # FYI must be 2 digits w/ 30FPS to get partials\n        win1 = GapWindow(\n            left_speech=speech_seg(0.0, 1.0),\n            # NOTE not using start/end of segments\n            gap=NonSpeechGap(segments=[silence_seg(1.0, 2.0)]),\n            right_speech=None,  # ignored side\n        )\n        win1.first_min_seconds_frame_aligned = 1.2  # or 1.23333333\n        win1.first_min_seconds = 1.22\n        # 0.22@30FPS is between frame numbers: 6 and 7\n        # 6/30 = 0.2\n        # 7/30 = 0.2333\n\n        wins = [win1]\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:221-278\nclass TestFrameRounding:\n\n    def test_first_min_not_on_a_frame__uses_frame_aligned_value(self):\n        # no bounce up for breathing/typing/etc\n        # FYI must be 2 digits w/ 30FPS to get partials\n        win1 = GapWindow(\n            left_speech=speech_seg(0.0, 1.0),\n            # NOTE not using start/end of segments\n            gap=NonSpeechGap(segments=[silence_seg(1.0, 2.0)]),\n            right_speech=None,  # ignored side\n        )\n        win1.first_min_seconds_frame_aligned = 1.2  # or 1.23333333\n        win1.first_min_seconds = 1.22\n        # 0.22@30FPS is between frame numbers: 6 and 7\n        # 6/30 = 0.2\n        # 7/30 = 0.2333\n\n        wins = [win1]\n        ranges = get_ranges(wins, VIDEO_FPS)\n\n        #  TODO! this test is effectively moving to gaps_tests.py on the actual gap analysis there will be frame_before_first_min/frame_after_first_min (same for last_min)\n        #     TODO LEAVE THIS AS A REMINDER TO PATCH the new frame boundaries into the tests above (and/or here)\n        #      I probably don't need examples here that are not on a frame boundary? as long as I have accurate code above to set w/e aligned value is seledcted\n        #      TODO ABOVE tests need calculated frame_before/after_first/last_min added and used\n        assert ranges[0].start_frame == 0\n        assert ranges[0].end_frame == 36  # or 37\n        # 37 vs 38? (round left/right?)\n        # - my inclination is\n        #   if it truly is NOT breathing\n        #     then I might not even mute the middle segment!\n        #     so it is ok to round right into the silence region\n        #     rounding left is still iffy depending on how fast the taper is from left_speech\n        #     round out/in? (left/right)\n        assert type(ranges[0]) == SilenceRange\n\n        assert ranges[1].start_frame == 36  # or 37\n        assert ranges[1].end_frame == 60\n        assert type(ranges[1]) == ContentRange\n\n    def test_last_min_not_on_a_frame__uses_frame_aligned_value(self):\n        win1 = GapWindow(\n            left_speech=None,  # ignored side\n            gap=NonSpeechGap(segments=[silence_seg(0.0, 1.0)]),\n            # NOTE not using end/start of segments\n            right_speech=speech_seg(1.0, 2.0),\n        )\n        win1.last_min_seconds = 1.75  # 22frames=0.7333... or 23frames=0.7666...\n        win1.last_min_seconds_frame_aligned = 1.73333333  # 1sec + 22/30  == 1.733333\n\n        wins = [win1]\n        ranges = get_ranges(wins, VIDEO_FPS)\n\n        # TODO same as I did for test_left_speech_into_silent_gap\n\n    # FYI not adding a test of multiple segments in the window.gap.segments\n    #  b/c right now that would be handled the same as one gap\n    #  all of gap is merged as SilenceRange\n    #  if I change this later, and map one or more sub-segments then I should add tests for that here (and/or in gaps_tests.py where my analysis happens to find first_min/last_min and decides on a nearby frame to use)\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/gaps.py:62-81\n    # * mark times\n    hops_per_second = analysis.sample_rate / RMS_HOP_LENGTH\n    gap_start_seconds = window.gap.segments[0].start_seconds\n    #\n    window.first_min_seconds = gap_start_seconds + first_min_idx / hops_per_second\n    window.first_min_rms = all_rms_values[first_min_idx]\n    #\n    last_min_idx_forwards = len(all_rms_values) - 1 - last_min_idx_backwards\n    window.last_min_seconds = gap_start_seconds + last_min_idx_forwards / hops_per_second\n    window.last_min_rms = all_rms_values[last_min_idx_forwards]\n\n    # TODO wire up frame detection around first_min/last_min\n    # given I am already doing analysis of all_rms_values (for gap)... seems like a good idea to put this here too\n    #   if anything I could break this out into its own method\n    #   PRN edge case where first_min is so close to start of gap that frame_before is in left_speech\n    #      PRN same for last_min and right_speech\n    # * mark frame_before_first_min\n    # * mark frame_after_first_min\n    #\n    # * mark frame_before_last_min\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/ranges_tests.py:97-116\n\n        # this is the edge case at the end (if no silence after, then need to take this from last window)\n        assert ranges[4].start_frame == 153\n        assert ranges[4].end_frame == 180\n        assert type(ranges[4]) == ContentRange\n\n    def test_taper_out_and_in(self):\n        win = GapWindow(\n            left_speech=speech_seg(0, 1.5),\n            gap=NonSpeechGap(segments=[silence_seg(1.5, 2.1)]),\n            right_speech=speech_seg(2.1, 3),\n        )\n        win.first_min_seconds = 1.6\n        win.first_min_rms = 0.5  # PRN tests of different levels (if it plays a part with say range type)\n        win.last_min_seconds = 2.0\n        win.last_min_rms = 0.5\n        wins = [win]\n        ranges = get_ranges(wins, VIDEO_FPS)\n\n        assert ranges[0].start_frame == 0\n\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n        right_speech=None,\n    )\n    return win, analysis\n\ndef compute_speech_boundaries(rms_values, up_db=3):\n    window, analysis = win(rms_values)\n    mark_safe_speech_boundaries(window, analysis, up_db=up_db)\n    return window\n\nclass TestLabelingGaps:\n\n    def test_segment_builder_with_breathing_curve(self):\n        # FYI if I want to simulate curves better (not just linear)...\n        #   i.e. simulate breathing bounce/curve (rise somewhat quick, level off and stay high a few frames, then drop off )\n        count = 10\n        half = int(count / 2)\n        speaking_taper = -np.arange(0, 5)**2\n        breathing = -(np.arange(-half, half + 1, 1) / 2)**(2) + 6.25  # formula: -(x/2)^2 for x in [-half, half]\n\n        # test = start(-15, debug_me=True).down(5).add(np.array(breathing))\n        test = start(-10, debug_me=True).add(speaking_taper).add(np.array(breathing))\n        # test.plot() # FYI! plot segment\n        # assert test.values == [-15, -16, -17, -18, -19, -20, \\\n        assert test.values == [-10, \\\n                               # speaking taper:\n                               -10, -11, -14, -19, -26, \\\n                               # breathing rise\n                               -26.0, -23.75, -22.0, -20.75, -20.0, \\\n                               # peak:\n                               -19.75, \\\n                               # breathing taper\n                               -20.0, -20.75, -22.0, -23.75, -26.0\\\n                               # PRN add speaking rampup:\n                               ]\n\n    def test_segment_builder(self):\n        # FYI \\ plus () is placed to allow for multi line chaining... and comments to explain each part's purpose... the \\ blocks the formatter from messing with this (at all)\n        #  lolz yapf dies if \\ is after wards, on its own line right before closing )\n        items = ( \\\n            start(-20)\n                .down(5) # speech taper\n                .up(3).down(3) # breathing bounce\n                .up(4) # speech rampup\n        )\n\n        assert items.values == [ \\\n            -20,\n            -21, -22, -23, -24, -25, # speech taper\n            -24, -23, -22, # breathing starts\n            -23, -24, -25, # breathing tapers\n            -24, -23, -22, -21 # speech rampup\n        ]\n        # FYI \\ again is for splitting across lines, to stop formatter from putting shit back on one line\n\n    def test_double_dip_breath_finds__first_min__and__last_min(self):\n        # so far all breathing looks like this double dip pattern\n        # and that makes sense given when I edit the waveform, I always see the bounce w/ empty dips on each side\n        # and I always move boundary between clips so its over the dip time... and then mute the breathing gap\n        # so this all checks out intuitively\n        # only real variation is going to be the degree of bounce and how well I can detect the dips (timing wise)\n        #    and then positioning frame rounding over this region (using rms_values if needed to pick a winning frame to round up/down)\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(10).down(8) # breathing bounce\n                .up(10) # speech rampup\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n        # start == 1.0s\n        # 22050 samples/sec\n        # hop_len == 25  (take 25 at a time)\n        # (22050 samples/sec) / (25 samples) = 882 hops/sec\n        # hop_duration = 1/882 ~= 0.0011337868480725624\n        # 0.0011337868480725624 * 25 (samples) == 0.02834467\n        assert window.last_min_rms == -43\n        assert window.last_min_seconds == pytest.approx(1.0 + 43 / 882)  # 1.0 sec + 43 hops/ 882 hops (note just coincidence -43 is value, they are not the same thing here)\n\n    # PRN flat segment?\n    # PRN first_min == last_min (but when re-run using up_db=2 then it finds breathing bounce with different last_min)... accept in this case?\n    #    ONLY if breathing bounce is obviously in-between?\n\n    # TODO some integration tests too with real video files\n\n    def test_breathing_bounce_with_2dB_on_last_min(self):\n        # FYI edge case of (drop == up_db)\n        #    FYI convention of saying \"drop\" for this test case is by virtue of left to right (time based) reading of segment behavior\n\n        # minute1 example at end, 2dB breathing jump (decline technically into last_min)\n        # I might make a special use case for this or just generally speaking lower my threshold from 3 to 2\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(10).down(2) # breathing bounce\n                .up(10), # speech rampup\n            up_db=2\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min_rms == -37\n        assert window.last_min_seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n        #\n        # OR not use 2dB? and instead this will match first_min?\n        # assert window.last_min_rms == window.first_min_rms\n        # assert window.last_min_seconds == window.first_min_seconds\n\n    def test_breathing_bounce_with_2dB_on_first_min(self):\n        # FYI edge case of (jump == up_db)\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(2).down(10) # breathing bounce\n                .up(10), # speech rampup\n            up_db=2\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min_rms == -53\n        assert window.last_min_seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n\n    def test_mark_all_nearest_frames(self):\n        # FYI you might be able to drop marking the four frames later, if so that's fine\n        #  this is just a first step to computing the nearest and best choice per side (one for first_min/last_min)\n        #  but before I get to that, I want to just mark the frames\n        #  and handle any edge cases there... i.e. when gap.start_seconds is not on a frame boundary\n        #    vs when it is on a frame boundary\n        #\n        # TODO might need to pull apart compute_speech_boundaries to inject my own segment so I can mark its start?\n        # BTW 30FPS + 25 hop len => 29.4 hops per frame\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .flat(40)\n                .down(1) # frame_min => 41 hops / 29.4 hops per frame =  1.39455782 frames (past start of segment which is @1sec/30frames)\n                .up(5).down(10) # breathing bounce\n                .up(1) # last_min\n                .flat(40)\n                # .plot()\n           , up_db=2\n        )\n        assert window.first_min_seconds = <|fim_middle|>\n        # TODO assertions\n        assert window._frame_before_first_min is not None\n        assert window._frame_after_first_min is not None\n        assert window._frame_before_last_min is not None\n        assert window._frame_after_last_min is not None\n\n    # TODO scenarios to consider covering for frame_before/after_first/last_min:\n    # FYI re-evaluate the need for these after I get other tests done above...\n    # - not sure I need these specifically unless they trigger a diff algorithm for picking nearest frame\n    # - TODO def test_left_speech_into_breathing_bounce_gap(self):\n    #   TODO def test_breathing_bounce_gap_into_right_speech(self):\n",
      "role": "user"
    }
  ],
  "stream": true,
  "raw": false
}
