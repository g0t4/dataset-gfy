{
  "raw": false,
  "model": "gpt-oss:120b",
  "messages": [
    {
      "content": "You are completing code from a Neovim plugin.\nAs the user types, the plugin suggests code completions based on their cursor position marked with: <|fim_middle|>\nThe surrounding code is limited to X lines above/below the cursor, so it may not be the full file. Focus on the code near <|fim_middle|>Do NOT explain your decisions. Do NOT return markdown blocks ```\nDo NOT repeat surrounding code (suffix/prefix)\nONLY return valid code at the <|fim_middle|> position\nPAY attention to existing whitespace.\nYOU ARE ONLY INSERTING CODE, DO NOT REPEAT PREFIX/SUFFIX. Think about overlap before finishing your thoughts.\n\nFor example, if you see this in a python file:\ndef adder(a, b):\n    return <|fim_middle|> + b\n\nThe correct completion is:\na\n\nNOT:\na + b\n\nand NOT:\n    return a + b\n\nMake sure to practice the code change before you return a suggestion. Take the cursor line (at least) and type it out with the new code and make sure it is valid, correct code.\n",
      "role": "developer"
    },
    {
      "content": "Here is context that's automatically provided, that MAY be relevant.\nrepo: private-auto-edit-suggests\n\nGeneral project code rules:\n- Never add comments to the end of a line.\n- NEVER add TODO comments for me.\n# General Code Preferences\n\n- When rewriting code, leave unrelated code and unrelated comments as is.\n- When an if statement has an AMBIGUOUS condition, extract a variable to meaningfully name it, for example:\n```lua\nlocal is_blank_line = line:match(\"^%s*$\")\nif is_blank_line then\n    -- ...\nend\n```\n\n# Python Code Preferences\n\n## Naming\n- Use snake_case for functions and variables.\n- Use PascalCase for classes.\n\n## Type Hints\n- Use type hints to clear up ambiguity and improve code completion.\n- prefer list[] over List[] to mimimizes imports\n- Avoid docstrings, ABSOLUTELY NO trivial comments.\n\n# Semantic Grep matches: 5\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detector_notebook.py:60-79\n#    *UNIQUE for sure... has typing RIGHT before speech resumes... could be a good test case of finding last_min to make sure it truly is last! \n#    BUT I should say this still fits the pattern of the last_min is the safe place for cut right before speaking resumes!\n#    TYPING wise lots of good examples nearby:\n#      next gaps: around 54seconds, 56 seconds (this one is medium length if I need any tests of that)\n# 147: ***! 58:28.16 => PROBLEMO!\n#    there is breathing in between first_min and what could be considered last_min \n#    RIGHT NOW breathing will be kept b/c of how local min search happens! ... might need to adjust 3dB jump to lower value?! will that cause issues?\n#       or in this case, can I factor in the jump on the left side into the breathing bounce? clearly looks like breathing\n#       worse case I have breathing here, NBD\n#       this does illustrate why I might want to keep cut points (maybe lower threshold for local min for cut points)... \n#        so I can easily mute the gap? add extra cut points even if I am considering some of the gap as speaking (to first_min/last_min)... still add cut point at original gap start/end?\n#           MIGHT find this helpful with other merges in gaps into speaking (the < 0.10s merge from earlier - before I work with gaps/windowing)\n#       but for some reason last_min wasn't triggered? it might be like 2.9dB jump ...\n#       one possible fix is less smoothing in RMS... try to elicit the dip a bit better...\n#       or maybe just adjust criteria for a climb... so you can do smth like, if there was a climb on the left side... then consider a smaller decline on the right side as still a breath\n#\n#    there is almost a last_min close to right side of gap... but it wasn't after a rise so it doesn't count\n#    instead, the last_min == first_min... they share the same b/c there was no rise up between\n#\n# %% \n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detector_notebook.py:75-86\n#\n#    there is almost a last_min close to right side of gap... but it wasn't after a rise so it doesn't count\n#    instead, the last_min == first_min... they share the same b/c there was no rise up between\n#\n# %% \n\n# image_filename = f\"RMS frame_len={RMS_FRAME_LENGTH} hop_len={RMS_HOP_LENGTH}\"\n# if USE_MEDFILT_SMOOTHING:\n#     image_filename += \" medfilt\"\n# image_filename += \".png\"\n# plt.savefig(image_filename, dpi=300, bbox_inches=\"tight\")\n\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detector_notebook.py:45-64\n# 47: speech ending at 25:05.20 => pretty normal breathing section BUT it has a slow decay in left_speech so this is good for testing cut points with my new approach \n#\n\n# * noteworthy stellar breathing test cases (fit my pattern of double dip w/ bounce):\n#   from minute1 video too\n#\n# 59: speech ending at 29:17.82 => ~300ms w/ breathing for 220+ms of it (first_idx/last_idx surround perfectly)\n#      29dB peak of breathing, 39.9dB double dip points (both sides hit about the same)\n#      similar gaps times: ~24s \n#\n\n# * noteworthy for testing last_min\n# 21: speech starting at 05:15.99 => right before this has a blip with a min for like one frame and it qualifies as the lowest point on the way back up to the start of speaking! (right speech)\n# 127: speech starting at 49:25.48  => * POSSIBLE ISSUE => has a drop and new local min on the way up... odd!\n#    after some typing.. so no I do not need the typing right before... but still interesting!\n#    *UNIQUE for sure... has typing RIGHT before speech resumes... could be a good test case of finding last_min to make sure it truly is last! \n#    BUT I should say this still fits the pattern of the last_min is the safe place for cut right before speaking resumes!\n#    TYPING wise lots of good examples nearby:\n#      next gaps: around 54seconds, 56 seconds (this one is medium length if I need any tests of that)\n# 147: ***! 58:28.16 => PROBLEMO!\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/new_silence/detector_notebook.py:30-49\n# %% \n# * noteworthy speech endings and gaps (fodder for test cases):\n#   from minute1 video\n#\n# 45: 24:05.20 => 25:05.88 (left speech cut off early ... simple pattern of breathing (down => up => crest => down => up (start right speech))  \n#\n# 71: speech ending at 33:03.20 => wild, longish gap after this... min(first_half) doesn't work \n#\n# 85: speech ending at 37:04.22 => very short break =>  0.126s total ... interesting first_min s/b == last_min b/c gap is down and up \n#      is it possible that first_min == last_min (and short duration) ==> signal to to merge the gap into the speech segments?\n#\n# 89: speech ending at 38:05.27 => erratic... first_min approach works where as old min(first_half) doesn't\n#\n# 135: speech ending at 55:20.27.. that next gap if you do first half it's wrong... first_min works nicely \n#\n# 47: speech ending at 25:05.20 => pretty normal breathing section BUT it has a slow decay in left_speech so this is good for testing cut points with my new approach \n#\n\n# * noteworthy stellar breathing test cases (fit my pattern of double dip w/ bounce):\n#   from minute1 video too\n\n\n## ~/repos/github/g0t4/private-auto-edit-suggests/auto_edit/tests/aligned-tests.py:74-75\ndef test_find_ratio_for_automatically_deciding_threshold_for_silence_detection(self):\n        pass\n",
      "role": "user"
    },
    {
      "content": "Please complete <|fim_middle|> in the following code (which has carefully preserved indentation):\n\ndef compute_speech_boundaries(rms_values, up_db=3):\n    window, analysis = win(rms_values)\n    mark_safe_speech_boundaries(window, analysis, up_db=up_db)\n    return window\n\nclass TestLabelingGaps:\n\n    def test_segment_builder_with_breathing_curve(self):\n        # FYI if I want to simulate curves better (not just linear)...\n        #   i.e. simulate breathing bounce/curve (rise somewhat quick, level off and stay high a few frames, then drop off )\n        count = 10\n        half = int(count / 2)\n        speaking_taper = -np.arange(0, 5)**2\n        breathing = -(np.arange(-half, half + 1, 1) / 2)**(2) + 6.25  # formula: -(x/2)^2 for x in [-half, half]\n\n        # test = start(-15, debug_me=True).down(5).add(np.array(breathing))\n        test = start(-10, debug_me=True).add(speaking_taper).add(np.array(breathing))\n        # test.plot() # FYI! plot segment\n        # assert test.values == [-15, -16, -17, -18, -19, -20, \\\n        assert test.values == [-10, \\\n                               # speaking taper:\n                               -10, -11, -14, -19, -26, \\\n                               # breathing rise\n                               -26.0, -23.75, -22.0, -20.75, -20.0, \\\n                               # peak:\n                               -19.75, \\\n                               # breathing taper\n                               -20.0, -20.75, -22.0, -23.75, -26.0\\\n                               # PRN add speaking rampup:\n                               ]\n\n    def test_segment_builder(self):\n        # FYI \\ plus () is placed to allow for multi line chaining... and comments to explain each part's purpose... the \\ blocks the formatter from messing with this (at all)\n        #  lolz yapf dies if \\ is after wards, on its own line right before closing )\n        items = ( \\\n            start(-20)\n                .down(5) # speech taper\n                .up(3).down(3) # breathing bounce\n                .up(4) # speech rampup\n        )\n\n        assert items.values == [ \\\n            -20,\n            -21, -22, -23, -24, -25, # speech taper\n            -24, -23, -22, # breathing starts\n            -23, -24, -25, # breathing tapers\n            -24, -23, -22, -21 # speech rampup\n        ]\n        # FYI \\ again is for splitting across lines, to stop formatter from putting shit back on one line\n\n    def test_double_dip_breath_finds__first_min__and__last_min(self):\n        # so far all breathing looks like this double dip pattern\n        # and that makes sense given when I edit the waveform, I always see the bounce w/ empty dips on each side\n        # and I always move boundary between clips so its over the dip time... and then mute the breathing gap\n        # so this all checks out intuitively\n        # only real variation is going to be the degree of bounce and how well I can detect the dips (timing wise)\n        #    and then positioning frame rounding over this region (using rms_values if needed to pick a winning frame to round up/down)\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(10).down(8) # breathing bounce\n                .up(10) # speech rampup\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n        # start == 1.0s\n        # 22050 samples/sec\n        # hop_len == 25  (take 25 at a time)\n        # (22050 samples/sec) / (25 samples) = 882 hops/sec\n        # hop_duration = 1/882 ~= 0.0011337868480725624\n        # 0.0011337868480725624 * 25 (samples) == 0.02834467\n        assert window.last_min_rms == -43\n        assert window.last_min_seconds == pytest.approx(1.0 + 43 / 882)  # 1.0 sec + 43 hops/ 882 hops (note just coincidence -43 is value, they are not the same thing here)\n\n    # PRN flat segment?\n    # PRN first_min == last_min (but when re-run using up_db=2 then it finds breathing bounce with different last_min)... accept in this case?\n    #    ONLY if breathing bounce is obviously in-between?\n\n    # TODO some integration tests too with real video files\n\n    def test_breathing_bounce_with_2dB_on_last_min(self):\n        # FYI edge case of (drop == up_db)\n        #    FYI convention of saying \"drop\" for this test case is by virtue of left to right (time based) reading of segment behavior\n\n        # minute1 example at end, 2dB breathing jump (decline technically into last_min)\n        # I might make a special use case for this or just generally speaking lower my threshold from 3 to 2\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(10).down(2) # breathing bounce\n                .up(10), # speech rampup\n            up_db=2\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min_rms == -37\n        assert window.last_min_seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n        #\n        # OR not use 2dB? and instead this will match first_min?\n        # assert window.last_min_rms == window.first_min_rms\n        # assert window.last_min_seconds == window.first_min_seconds\n\n    def test_breathing_bounce_with_2dB_on_first_min(self):\n        # FYI edge case of (jump == up_db)\n\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .down(25) # speech taper\n                .up(2).down(10) # breathing bounce\n                .up(10), # speech rampup\n            up_db=2\n        )\n\n        assert window.first_min_rms == -45\n        assert window.first_min_seconds == pytest.approx(1.0 + 25 / 882)  # 1.0 sec + 25 hops * 1/882 sec/hop ==> seconds of first_min\n\n        assert window.last_min_rms == -53\n        assert window.last_min_seconds == pytest.approx(1.0 + 37 / 882)  # 37/882\n\n    def test_mark_all_nearest_frames(self):\n        # FYI you might be able to drop marking the four frames later, if so that's fine\n        #  this is just a first step to computing the nearest and best choice per side (one for first_min/last_min)\n        #  but before I get to that, I want to just mark the frames\n        #  and handle any edge cases there... i.e. when gap.start_seconds is not on a frame boundary\n        #    vs when it is on a frame boundary\n        #\n        # TODO might need to pull apart compute_speech_boundaries to inject my own segment so I can mark its start?\n        # BTW 30FPS + 25 hop len => 29.4 hops per frame\n        window = compute_speech_boundaries( \\\n            start(-20)\n                .flat(40)\n                .down(1) # frame_min => 41 hops / 29.4 hops per frame =  1.39455782 frames (past start of segment which is @1sec/30frames)\n                .up(5).down(10) # breathing bounce\n                # last_min [ before up(1) ] => 56 hops (41 to first_min + 5+10 == 56) => 56 / 29.4 = <|fim_middle|>\n                .up(1) \n                .flat(40)\n                # .plot()\n           , up_db=2\n        )\n        assert window.first_min_seconds == pytest.approx(1.0 + 41 / 882)\n\n        # TODO implement:\n        assert window._frame_before_first_min == 31\n        assert window._frame_after_first_min == 32\n\n        # TODO later:\n        # assert window._frame_before_last_min is not None\n        # assert window._frame_after_last_min is not None\n\n    # TODO scenarios to consider covering for frame_before/after_first/last_min:\n    # FYI re-evaluate the need for these after I get other tests done above...\n    # - not sure I need these specifically unless they trigger a diff algorithm for picking nearest frame\n    # - TODO def test_left_speech_into_breathing_bounce_gap(self):\n    #   TODO def test_breathing_bounce_gap_into_right_speech(self):",
      "role": "user"
    }
  ],
  "options": [],
  "stream": true,
  "chat_template_kwargs": {
    "reasoning_effort": "low"
  },
  "top_p": 1,
  "max_tokens": 4096,
  "temperature": 1
}
